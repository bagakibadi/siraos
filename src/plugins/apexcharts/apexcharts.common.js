/*!
 * ApexCharts v3.15.2
 * (c) 2018-2020 Juned Chhipa
 * Released under the MIT License.
 */

function _typeof(t) { return (_typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t; })(t); } function _classCallCheck(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function'); } function _defineProperties(t, e) { for (let i = 0; i < e.length; i++) { const a = e[i]; a.enumerable = a.enumerable || !1, a.configurable = !0, 'value' in a && (a.writable = !0), Object.defineProperty(t, a.key, a); } } function _createClass(t, e, i) { return e && _defineProperties(t.prototype, e), i && _defineProperties(t, i), t; } function _defineProperty(t, e, i) {
  return e in t ? Object.defineProperty(t, e, {
    value: i, enumerable: !0, configurable: !0, writable: !0,
  }) : t[e] = i, t;
} function ownKeys(t, e) { const i = Object.keys(t); if (Object.getOwnPropertySymbols) { let a = Object.getOwnPropertySymbols(t); e && (a = a.filter(((e) => Object.getOwnPropertyDescriptor(t, e).enumerable))), i.push.apply(i, a); } return i; } function _objectSpread2(t) { for (let e = 1; e < arguments.length; e++) { var i = arguments[e] != null ? arguments[e] : {}; e % 2 ? ownKeys(Object(i), !0).forEach(((e) => { _defineProperty(t, e, i[e]); })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : ownKeys(Object(i)).forEach(((e) => { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e)); })); } return t; } function _inherits(t, e) { if (typeof e !== 'function' && e !== null) throw new TypeError('Super expression must either be null or a function'); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && _setPrototypeOf(t, e); } function _getPrototypeOf(t) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t); })(t); } function _setPrototypeOf(t, e) { return (_setPrototypeOf = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t; })(t, e); } function _assertThisInitialized(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; } function _possibleConstructorReturn(t, e) { return !e || typeof e !== 'object' && typeof e !== 'function' ? _assertThisInitialized(t) : e; } function _toConsumableArray(t) { return _arrayWithoutHoles(t) || _iterableToArray(t) || _nonIterableSpread(); } function _arrayWithoutHoles(t) { if (Array.isArray(t)) { for (var e = 0, i = new Array(t.length); e < t.length; e++)i[e] = t[e]; return i; } } function _iterableToArray(t) { if (Symbol.iterator in Object(t) || Object.prototype.toString.call(t) === '[object Arguments]') return Array.from(t); } function _nonIterableSpread() { throw new TypeError('Invalid attempt to spread non-iterable instance'); } const Utils = (function () {
  function t() { _classCallCheck(this, t); } return _createClass(t, [{ key: 'shadeRGBColor', value(t, e) { const i = e.split(','); const a = t < 0 ? 0 : 255; const s = t < 0 ? -1 * t : t; const r = parseInt(i[0].slice(4), 10); const n = parseInt(i[1], 10); const o = parseInt(i[2], 10); return `rgb(${Math.round((a - r) * s) + r},${Math.round((a - n) * s) + n},${Math.round((a - o) * s) + o})`; } }, { key: 'shadeHexColor', value(t, e) { const i = parseInt(e.slice(1), 16); const a = t < 0 ? 0 : 255; const s = t < 0 ? -1 * t : t; const r = i >> 16; const n = i >> 8 & 255; const o = 255 & i; return `#${(16777216 + 65536 * (Math.round((a - r) * s) + r) + 256 * (Math.round((a - n) * s) + n) + (Math.round((a - o) * s) + o)).toString(16).slice(1)}`; } }, { key: 'shadeColor', value(t, e) { return e.length > 7 ? this.shadeRGBColor(t, e) : this.shadeHexColor(t, e); } }], [{ key: 'bind', value(t, e) { return function () { return t.apply(e, arguments); }; } }, { key: 'isObject', value(t) { return t && _typeof(t) === 'object' && !Array.isArray(t) && t != null; } }, { key: 'listToArray', value(t) { let e; const i = []; for (e = 0; e < t.length; e++)i[e] = t[e]; return i; } }, { key: 'extend', value(t, e) { const i = this; typeof Object.assign !== 'function' && (Object.assign = function (t) { if (t == null) throw new TypeError('Cannot convert undefined or null to object'); for (var e = Object(t), i = 1; i < arguments.length; i++) { const a = arguments[i]; if (a != null) for (const s in a)a.hasOwnProperty(s) && (e[s] = a[s]); } return e; }); const a = { ...t }; return this.isObject(t) && this.isObject(e) && Object.keys(e).forEach(((s) => { i.isObject(e[s]) && s in t ? a[s] = i.extend(t[s], e[s]) : Object.assign(a, _defineProperty({}, s, e[s])); })), a; } }, { key: 'extendArray', value(e, i) { const a = []; return e.map(((e) => { a.push(t.extend(i, e)); })), e = a; } }, { key: 'monthMod', value(t) { return t % 12; } }, { key: 'clone', value(t) { if (Object.prototype.toString.call(t) === '[object Array]') { for (var e = [], i = 0; i < t.length; i++)e[i] = this.clone(t[i]); return e; } if (_typeof(t) === 'object') { const a = {}; for (const s in t)t.hasOwnProperty(s) && (a[s] = this.clone(t[s])); return a; } return t; } }, { key: 'log10', value(t) { return Math.log(t) / Math.LN10; } }, { key: 'roundToBase10', value(t) { return Math.pow(10, Math.floor(Math.log10(t))); } }, { key: 'roundToBase', value(t, e) { return Math.pow(e, Math.floor(Math.log(t) / Math.log(e))); } }, { key: 'parseNumber', value(t) { return t === null ? t : parseFloat(t); } }, { key: 'randomId', value() { return (Math.random() + 1).toString(36).substring(4); } }, { key: 'noExponents', value(t) { const e = String(t).split(/[eE]/); if (e.length === 1) return e[0]; let i = ''; const a = t < 0 ? '-' : ''; const s = e[0].replace('.', ''); let r = Number(e[1]) + 1; if (r < 0) { for (i = `${a}0.`; r++;)i += '0'; return i + s.replace(/^-/, ''); } for (r -= s.length; r--;)i += '0'; return s + i; } }, { key: 'getDimensions', value(t) { const e = getComputedStyle(t); const i = []; let a = t.clientHeight; let s = t.clientWidth; return a -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), s -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), i.push(s), i.push(a), i; } }, {
    key: 'getBoundingClientRect',
    value(t) {
      const e = t.getBoundingClientRect(); return {
        top: e.top, right: e.right, bottom: e.bottom, left: e.left, width: e.width, height: e.height, x: e.x, y: e.y,
      };
    },
  }, { key: 'getLargestStringFromArr', value(t) { return t.reduce(((t, e) => (Array.isArray(e) && (e = e.reduce(((t, e) => (t.length > e.length ? t : e)))), t.length > e.length ? t : e)), 0); } }, {
    key: 'hexToRgba',
    value() {
      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : '#999999'; const
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6; t.substring(0, 1) !== '#' && (t = '#999999'); let i = t.replace('#', ''); i = i.match(new RegExp(`(.{${i.length / 3}})`, 'g')); for (let a = 0; a < i.length; a++)i[a] = parseInt(i[a].length === 1 ? i[a] + i[a] : i[a], 16); return void 0 !== e && i.push(e), `rgba(${i.join(',')})`;
    },
  }, { key: 'getOpacityFromRGBA', value(t) { return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i))[3]; } }, { key: 'rgb2hex', value(t) { return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && t.length === 4 ? `#${(`0${parseInt(t[1], 10).toString(16)}`).slice(-2)}${(`0${parseInt(t[2], 10).toString(16)}`).slice(-2)}${(`0${parseInt(t[3], 10).toString(16)}`).slice(-2)}` : ''; } }, { key: 'isColorHex', value(t) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t); } }, { key: 'polarToCartesian', value(t, e, i, a) { const s = (a - 90) * Math.PI / 180; return { x: t + i * Math.cos(s), y: e + i * Math.sin(s) }; } }, {
    key: 'escapeString',
    value(t) {
      const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'x'; let
        i = t.toString().slice(); return i = i.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, e);
    },
  }, { key: 'negToZero', value(t) { return t < 0 ? 0 : t; } }, { key: 'moveIndexInArray', value(t, e, i) { if (i >= t.length) for (let a = i - t.length + 1; a--;)t.push(void 0); return t.splice(i, 0, t.splice(e, 1)[0]), t; } }, { key: 'extractNumber', value(t) { return parseFloat(t.replace(/[^\d.]*/g, '')); } }, { key: 'findAncestor', value(t, e) { for (;(t = t.parentElement) && !t.classList.contains(e););return t; } }, { key: 'setELstyles', value(t, e) { for (const i in e)e.hasOwnProperty(i) && (t.style.key = e[i]); } }, { key: 'isNumber', value(t) { return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10)); } }, { key: 'isFloat', value(t) { return Number(t) === t && t % 1 != 0; } }, { key: 'isSafari', value() { return /^((?!chrome|android).)*safari/i.test(navigator.userAgent); } }, { key: 'isFirefox', value() { return navigator.userAgent.toLowerCase().indexOf('firefox') > -1; } }, { key: 'isIE11', value() { if (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.appVersion.indexOf('Trident/') > -1) return !0; } }, { key: 'isIE', value() { const t = window.navigator.userAgent; const e = t.indexOf('MSIE '); if (e > 0) return parseInt(t.substring(e + 5, t.indexOf('.', e)), 10); if (t.indexOf('Trident/') > 0) { const i = t.indexOf('rv:'); return parseInt(t.substring(i + 3, t.indexOf('.', i)), 10); } const a = t.indexOf('Edge/'); return a > 0 && parseInt(t.substring(a + 5, t.indexOf('.', a)), 10); } }]), t;
}()); const Filters = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'getDefaultFilter', value(t, e) { const i = this.w; t.unfilter(!0), (new window.SVG.Filter()).size('120%', '180%', '-5%', '-40%'), i.config.states.normal.filter !== 'none' ? this.applyFilter(t, e, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e); } }, { key: 'addNormalFilter', value(t, e) { const i = this.w; i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e); } }, { key: 'addLightenFilter', value(t, e, i) { const a = this; const s = this.w; const r = i.intensity; if (!Utils.isFirefox()) { t.unfilter(!0); let n = new window.SVG.Filter(); n.size('120%', '180%', '-5%', '-40%'), t.filter(((t) => { const i = s.config.chart.dropShadow; (n = i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({ rgb: { type: 'linear', slope: 1.5, intercept: r } }); })), t.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse'); } } }, { key: 'addDarkenFilter', value(t, e, i) { const a = this; const s = this.w; const r = i.intensity; if (!Utils.isFirefox()) { t.unfilter(!0); let n = new window.SVG.Filter(); n.size('120%', '180%', '-5%', '-40%'), t.filter(((t) => { const i = s.config.chart.dropShadow; (n = i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({ rgb: { type: 'linear', slope: r } }); })), t.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse'); } } }, { key: 'applyFilter', value(t, e, i) { const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5; switch (i) { case 'none': this.addNormalFilter(t, e); break; case 'lighten': this.addLightenFilter(t, e, { intensity: a }); break; case 'darken': this.addDarkenFilter(t, e, { intensity: a }); } } }, {
    key: 'addShadow',
    value(t, e, i) {
      const a = i.blur; const s = i.top; const r = i.left; const n = i.color; const o = i.opacity; const l = t.flood(Array.isArray(n) ? n[e] : n, o).composite(t.sourceAlpha, 'in').offset(r, s).gaussianBlur(a)
        .merge(t.source); return t.blend(t.source, l);
    },
  }, {
    key: 'dropShadow',
    value(t, e) {
      const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const a = e.top; const s = e.left; const r = e.blur; let n = e.color; const o = e.opacity; const l = e.noUserSpaceOnUse; const h = this.w; if (t.unfilter(!0), Utils.isIE() && h.config.chart.type === 'radialBar') return t; n = Array.isArray(n) ? n[i] : n; const c = new window.SVG.Filter(); return c.size('120%', '180%', '-5%', '-40%'), t.filter(((t) => {
        let e = null; e = Utils.isSafari() || Utils.isFirefox() || Utils.isIE() ? t.flood(n, o).composite(t.sourceAlpha, 'in').offset(s, a).gaussianBlur(r) : t.flood(n, o).composite(t.sourceAlpha, 'in').offset(s, a).gaussianBlur(r)
          .merge(t.source), t.blend(t.source, e);
      })), l || t.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse'), t;
    },
  }, { key: 'setSelectionFilter', value(t, e, i) { const a = this.w; if (void 0 !== a.globals.selectedDataPoints[e] && a.globals.selectedDataPoints[e].indexOf(i) > -1) { t.node.setAttribute('selected', !0); const s = a.config.states.active.filter; s !== 'none' && this.applyFilter(t, e, s.type, s.value); } } }]), t;
}()); const Animations = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.setEasingFunctions(); } return _createClass(t, [{ key: 'setEasingFunctions', value() { let t; if (!this.w.globals.easing) { switch (this.w.config.chart.animations.easing) { case 'linear': t = '-'; break; case 'easein': t = '<'; break; case 'easeout': t = '>'; break; case 'easeinout': t = '<>'; break; case 'swing': t = function (t) { const e = 1.70158; return (t -= 1) * t * ((e + 1) * t + e) + 1; }; break; case 'bounce': t = function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }; break; case 'elastic': t = function (t) { return t === !!t ? t : Math.pow(2, -10 * t) * Math.sin((t - 0.075) * (2 * Math.PI) / 0.3) + 1; }; break; default: t = '<>'; } this.w.globals.easing = t; } } }, { key: 'animateLine', value(t, e, i, a) { t.attr(e).animate(a).attr(i); } }, { key: 'animateCircleRadius', value(t, e, i, a, s, r) { e || (e = 0), t.attr({ r: e }).animate(a, s).attr({ r: i }).afterAll((() => { r(); })); } }, { key: 'animateCircle', value(t, e, i, a, s) { t.attr({ r: e.r, cx: e.cx, cy: e.cy }).animate(a, s).attr({ r: i.r, cx: i.cx, cy: i.cy }); } }, { key: 'animateRect', value(t, e, i, a, s) { t.attr(e).animate(a).attr(i).afterAll((() => s())); } }, { key: 'animatePathsGradually', value(t) { const e = t.el; const i = t.realIndex; const a = t.j; const s = t.fill; const r = t.pathFrom; const n = t.pathTo; const o = t.speed; const l = t.delay; const h = this.w; let c = 0; h.config.chart.animations.animateGradually.enabled && (c = h.config.chart.animations.animateGradually.delay), h.config.chart.animations.dynamicAnimation.enabled && h.globals.dataChanged && (c = 0), this.morphSVG(e, i, a, h.config.chart.type !== 'line' || h.globals.comboCharts ? s : 'stroke', r, n, o, l * c); } }, { key: 'showDelayedElements', value() { this.w.globals.delayedElements.forEach(((t) => { t.el.classList.remove('apexcharts-element-hidden'); })); } }, { key: 'animationCompleted', value(t) { const e = this.w; e.globals.animationEnded || (e.globals.animationEnded = !0, typeof e.config.chart.events.animationEnd === 'function' && e.config.chart.events.animationEnd(this.ctx, { el: t, w: e })); } }, {
    key: 'morphSVG',
    value(t, e, i, a, s, r, n, o) {
      const l = this; const h = this.w; s || (s = t.attr('pathFrom')), r || (r = t.attr('pathTo')), (!s || s.indexOf('undefined') > -1 || s.indexOf('NaN') > -1) && (s = 'M 0 '.concat(h.globals.gridHeight), n = 1), (r.indexOf('undefined') > -1 || r.indexOf('NaN') > -1) && (r = 'M 0 '.concat(h.globals.gridHeight), n = 1), h.globals.shouldAnimate || (n = 1), t.plot(s).animate(1, h.globals.easing, o).plot(s).animate(n, h.globals.easing, o)
        .plot(r)
        .afterAll((() => { Utils.isNumber(i) ? i === h.globals.series[h.globals.maxValsInArrayIndex].length - 2 && h.globals.shouldAnimate && l.animationCompleted(t) : a !== 'none' && h.globals.shouldAnimate && (!h.globals.comboCharts && e === h.globals.series.length - 1 || h.globals.comboCharts) && l.animationCompleted(t), l.showDelayedElements(); }));
    },
  }]), t;
}()); const Graphics = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{
    key: 'drawLine',
    value(t, e, i, a) {
      const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : '#a8a8a8'; const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; const n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null; const o = this.w; const
        l = o.globals.dom.Paper.line().attr({
          x1: t, y1: e, x2: i, y2: a, stroke: s, 'stroke-dasharray': r, 'stroke-width': n,
        }); return l;
    },
  }, {
    key: 'drawRect',
    value() {
      const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0; const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0; const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : '#fefefe'; const n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1; const o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null; const l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null; const h = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0; const c = this.w; const d = c.globals.dom.Paper.rect(); return d.attr({
        x: t, y: e, width: i > 0 ? i : 0, height: a > 0 ? a : 0, rx: s, ry: s, fill: r, opacity: n, 'stroke-width': o !== null ? o : 0, stroke: l !== null ? l : 'none', 'stroke-dasharray': h,
      }), d;
    },
  }, {
    key: 'drawPolygon',
    value(t) {
      const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '#e1e1e1'; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'none'; const a = this.w; const
        s = a.globals.dom.Paper.polygon(t).attr({ fill: i, stroke: e }); return s;
    },
  }, { key: 'drawCircle', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const i = this.w; const a = i.globals.dom.Paper.circle(2 * t); return e !== null && a.attr(e), a; } }, {
    key: 'drawPath',
    value(t) {
      const e = t.d; let i = void 0 === e ? '' : e; const a = t.stroke; const s = void 0 === a ? '#a8a8a8' : a; const r = t.strokeWidth; const n = void 0 === r ? 1 : r; const o = t.fill; const l = t.fillOpacity; const h = void 0 === l ? 1 : l; const c = t.strokeOpacity; const d = void 0 === c ? 1 : c; const g = t.classes; const u = t.strokeLinecap; let p = void 0 === u ? null : u; const f = t.strokeDashArray; const x = void 0 === f ? 0 : f; const b = this.w; return p === null && (p = b.config.stroke.lineCap), (i.indexOf('undefined') > -1 || i.indexOf('NaN') > -1) && (i = 'M 0 '.concat(b.globals.gridHeight)), b.globals.dom.Paper.path(i).attr({
        fill: o, 'fill-opacity': h, stroke: s, 'stroke-opacity': d, 'stroke-linecap': p, 'stroke-width': n, 'stroke-dasharray': x, class: g,
      });
    },
  }, { key: 'group', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; const e = this.w; const i = e.globals.dom.Paper.group(); return t !== null && i.attr(t), i; } }, { key: 'move', value(t, e) { const i = ['M', t, e].join(' '); return i; } }, { key: 'line', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; let a = null; return i === null ? a = ['L', t, e].join(' ') : i === 'H' ? a = ['H', t].join(' ') : i === 'V' && (a = ['V', e].join(' ')), a; } }, { key: 'curve', value(t, e, i, a, s, r) { const n = ['C', t, e, i, a, s, r].join(' '); return n; } }, { key: 'quadraticCurve', value(t, e, i, a) { return ['Q', t, e, i, a].join(' '); } }, { key: 'arc', value(t, e, i, a, s, r, n) { const o = arguments.length > 7 && void 0 !== arguments[7] && arguments[7]; let l = 'A'; o && (l = 'a'); const h = [l, t, e, i, a, s, r, n].join(' '); return h; } }, {
    key: 'renderPaths',
    value(t) {
      let e; const i = t.j; const a = t.realIndex; const s = t.pathFrom; const r = t.pathTo; const n = t.stroke; const o = t.strokeWidth; const l = t.strokeLinecap; const h = t.fill; const c = t.animationDelay; const d = t.initialSpeed; const g = t.dataChangeSpeed; const u = t.className; const p = t.shouldClipToGrid; const f = void 0 === p || p; const x = t.bindEventsOnPaths; const b = void 0 === x || x; const m = t.drawShadow; const v = void 0 === m || m; const y = this.w; const w = new Filters(this.ctx); const k = new Animations(this.ctx); const C = this.w.config.chart.animations.enabled; const A = C && this.w.config.chart.animations.dynamicAnimation.enabled; const S = !!(C && !y.globals.resized || A && y.globals.dataChanged && y.globals.shouldAnimate); S ? e = s : (e = r, y.globals.animationEnded = !0); const L = y.config.stroke.dashArray; let P = 0; P = Array.isArray(L) ? L[a] : y.config.stroke.dashArray; const T = this.drawPath({
        d: e, stroke: n, strokeWidth: o, fill: h, fillOpacity: 1, classes: u, strokeLinecap: l, strokeDashArray: P,
      }); if (T.attr('index', a), f && T.attr({ 'clip-path': 'url(#gridRectMask'.concat(y.globals.cuid, ')') }), y.config.states.normal.filter.type !== 'none')w.getDefaultFilter(T, a); else if (y.config.chart.dropShadow.enabled && v && (!y.config.chart.dropShadow.enabledSeries || y.config.chart.dropShadow.enabledSeries && y.config.chart.dropShadow.enabledSeries.indexOf(a) !== -1)) { const z = y.config.chart.dropShadow; w.dropShadow(T, z, a); }b && (T.node.addEventListener('mouseenter', this.pathMouseEnter.bind(this, T)), T.node.addEventListener('mouseleave', this.pathMouseLeave.bind(this, T)), T.node.addEventListener('mousedown', this.pathMouseDown.bind(this, T))), T.attr({ pathTo: r, pathFrom: s }); const E = {
        el: T, j: i, realIndex: a, pathFrom: s, pathTo: r, fill: h, strokeWidth: o,
      }; return !C || y.globals.resized || y.globals.dataChanged ? !y.globals.resized && y.globals.dataChanged || k.showDelayedElements() : k.animatePathsGradually(_objectSpread2({}, E, { speed: d, delay: c })), y.globals.dataChanged && A && S && k.animatePathsGradually(_objectSpread2({}, E, { speed: g })), T;
    },
  }, {
    key: 'drawPattern',
    value(t, e, i) {
      const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : '#a8a8a8'; const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0; const r = this.w; const
        n = r.globals.dom.Paper.pattern(e, i, ((r) => { t === 'horizontalLines' ? r.line(0, 0, i, 0).stroke({ color: a, width: s + 1 }) : t === 'verticalLines' ? r.line(0, 0, 0, e).stroke({ color: a, width: s + 1 }) : t === 'slantedLines' ? r.line(0, 0, e, i).stroke({ color: a, width: s }) : t === 'squares' ? r.rect(e, i).fill('none').stroke({ color: a, width: s }) : t === 'circles' && r.circle(e).fill('none').stroke({ color: a, width: s }); })); return n;
    },
  }, {
    key: 'drawGradient',
    value(t, e, i, a, s) {
      let r; const n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null; const o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null; const l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null; const h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0; const c = this.w; e = Utils.hexToRgba(e, a), i = Utils.hexToRgba(i, s); let d = 0; let g = 1; let u = 1; let p = null; o !== null && (d = void 0 !== o[0] ? o[0] / 100 : 0, g = void 0 !== o[1] ? o[1] / 100 : 1, u = void 0 !== o[2] ? o[2] / 100 : 1, p = void 0 !== o[3] ? o[3] / 100 : null); const f = !(c.config.chart.type !== 'donut' && c.config.chart.type !== 'pie' && c.config.chart.type !== 'bubble'); if (r = l === null || l.length === 0 ? c.globals.dom.Paper.gradient(f ? 'radial' : 'linear', ((t) => { t.at(d, e, a), t.at(g, i, s), t.at(u, i, s), p !== null && t.at(p, e, a); })) : c.globals.dom.Paper.gradient(f ? 'radial' : 'linear', ((t) => { (Array.isArray(l[h]) ? l[h] : l).forEach(((e) => { t.at(e.offset / 100, e.color, e.opacity); })); })), f) {
        const x = c.globals.gridWidth / 2; const b = c.globals.gridHeight / 2; c.config.chart.type !== 'bubble' ? r.attr({
          gradientUnits: 'userSpaceOnUse', cx: x, cy: b, r: n,
        }) : r.attr({
          cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2,
        });
      } else t === 'vertical' ? r.from(0, 0).to(0, 1) : t === 'diagonal' ? r.from(0, 0).to(1, 1) : t === 'horizontal' ? r.from(0, 1).to(1, 1) : t === 'diagonal2' && r.from(0, 1).to(2, 2); return r;
    },
  }, {
    key: 'drawText',
    value(t) {
      let e; const i = t.x; const a = t.y; let s = t.text; let r = t.textAnchor; const n = t.fontSize; let o = t.fontFamily; let l = t.fontWeight; let h = t.foreColor; const c = t.opacity; const d = t.cssClass; const g = void 0 === d ? '' : d; const u = t.isPlainText; const p = void 0 === u || u; const f = this.w; return void 0 === s && (s = ''), r || (r = 'start'), h || (h = f.config.chart.foreColor), o = o || f.config.chart.fontFamily, l = l || 'regular', (e = Array.isArray(s) ? f.globals.dom.Paper.text(((t) => { for (let e = 0; e < s.length; e++)e === 0 ? t.tspan(s[e]) : t.tspan(s[e]).newLine(); })) : p ? f.globals.dom.Paper.plain(s) : f.globals.dom.Paper.text(((t) => t.tspan(s)))).attr({
        x: i, y: a, 'text-anchor': r, 'dominant-baseline': 'auto', 'font-size': n, 'font-family': o, 'font-weight': l, fill: h, class: `apexcharts-text ${g}`,
      }), e.node.style.fontFamily = o, e.node.style.opacity = c, e;
    },
  }, {
    key: 'drawMarker',
    value(t, e, i) {
      t = t || 0; let a = i.pSize || 0; let s = null; if (i.shape === 'square') {
        let r = void 0 === i.pRadius ? a / 2 : i.pRadius; e !== null && a || (a = 0, r = 0); const n = 1.2 * a + r; const o = this.drawRect(n, n, n, n, r); o.attr({
          x: t - n / 2, y: e - n / 2, cx: t, cy: e, class: i.class ? i.class : '', fill: i.pointFillColor, 'fill-opacity': i.pointFillOpacity ? i.pointFillOpacity : 1, stroke: i.pointStrokeColor, 'stroke-width': i.pWidth ? i.pWidth : 0, 'stroke-opacity': i.pointStrokeOpacity ? i.pointStrokeOpacity : 1,
        }), s = o;
      } else {
        i.shape !== 'circle' && i.shape || (Utils.isNumber(e) || (a = 0, e = 0), s = this.drawCircle(a, {
          cx: t, cy: e, class: i.class ? i.class : '', stroke: i.pointStrokeColor, fill: i.pointFillColor, 'fill-opacity': i.pointFillOpacity ? i.pointFillOpacity : 1, 'stroke-width': i.pWidth ? i.pWidth : 0, 'stroke-opacity': i.pointStrokeOpacity ? i.pointStrokeOpacity : 1,
        }));
      } return s;
    },
  }, { key: 'pathMouseEnter', value(t, e) { const i = this.w; const a = new Filters(this.ctx); const s = parseInt(t.node.getAttribute('index'), 10); const r = parseInt(t.node.getAttribute('j'), 10); if (typeof i.config.chart.events.dataPointMouseEnter === 'function' && i.config.chart.events.dataPointMouseEnter(e, this.ctx, { seriesIndex: s, dataPointIndex: r, w: i }), this.ctx.events.fireEvent('dataPointMouseEnter', [e, this.ctx, { seriesIndex: s, dataPointIndex: r, w: i }]), (i.config.states.active.filter.type === 'none' || t.node.getAttribute('selected') !== 'true') && i.config.states.hover.filter.type !== 'none' && i.config.states.active.filter.type !== 'none' && !i.globals.isTouchDevice) { const n = i.config.states.hover.filter; a.applyFilter(t, s, n.type, n.value); } } }, { key: 'pathMouseLeave', value(t, e) { const i = this.w; const a = new Filters(this.ctx); const s = parseInt(t.node.getAttribute('index'), 10); const r = parseInt(t.node.getAttribute('j'), 10); typeof i.config.chart.events.dataPointMouseLeave === 'function' && i.config.chart.events.dataPointMouseLeave(e, this.ctx, { seriesIndex: s, dataPointIndex: r, w: i }), this.ctx.events.fireEvent('dataPointMouseLeave', [e, this.ctx, { seriesIndex: s, dataPointIndex: r, w: i }]), i.config.states.active.filter.type !== 'none' && t.node.getAttribute('selected') === 'true' || i.config.states.hover.filter.type !== 'none' && a.getDefaultFilter(t, s); } }, {
    key: 'pathMouseDown',
    value(t, e) {
      const i = this.w; const a = new Filters(this.ctx); const s = parseInt(t.node.getAttribute('index'), 10); const r = parseInt(t.node.getAttribute('j'), 10); let n = 'false'; if (t.node.getAttribute('selected') === 'true') { if (t.node.setAttribute('selected', 'false'), i.globals.selectedDataPoints[s].indexOf(r) > -1) { const o = i.globals.selectedDataPoints[s].indexOf(r); i.globals.selectedDataPoints[s].splice(o, 1); } } else { if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) { i.globals.selectedDataPoints = []; const l = i.globals.dom.Paper.select('.apexcharts-series path').members; const h = i.globals.dom.Paper.select('.apexcharts-series circle, .apexcharts-series rect').members; const c = function (t) { Array.prototype.forEach.call(t, ((t) => { t.node.setAttribute('selected', 'false'), a.getDefaultFilter(t, s); })); }; c(l), c(h); }t.node.setAttribute('selected', 'true'), n = 'true', void 0 === i.globals.selectedDataPoints[s] && (i.globals.selectedDataPoints[s] = []), i.globals.selectedDataPoints[s].push(r); } if (n === 'true') { const d = i.config.states.active.filter; d !== 'none' && a.applyFilter(t, s, d.type, d.value); } else i.config.states.active.filter.type !== 'none' && a.getDefaultFilter(t, s); typeof i.config.chart.events.dataPointSelection === 'function' && i.config.chart.events.dataPointSelection(e, this.ctx, {
        selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: s, dataPointIndex: r, w: i,
      }), e && this.ctx.events.fireEvent('dataPointSelection', [e, this.ctx, {
        selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: s, dataPointIndex: r, w: i,
      }]);
    },
  }, { key: 'rotateAroundCenter', value(t) { const e = t.getBBox(); return { x: e.x + e.width / 2, y: e.y + e.height / 2 }; } }, {
    key: 'getTextRects',
    value(t, e, i, a) {
      const s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]; const r = this.w; const n = this.drawText({
        x: -200, y: -200, text: t, textAnchor: 'start', fontSize: e, fontFamily: i, foreColor: '#fff', opacity: 0,
      }); a && n.attr('transform', a), r.globals.dom.Paper.add(n); let o = n.bbox(); return s || (o = n.node.getBoundingClientRect()), n.remove(), { width: o.width, height: o.height };
    },
  }, { key: 'placeTextWithEllipsis', value(t, e, i) { if (typeof t.getComputedTextLength === 'function' && (t.textContent = e, e.length > 0 && t.getComputedTextLength() >= i / 0.8)) { for (let a = e.length - 3; a > 0; a -= 3) if (t.getSubStringLength(0, a) <= i / 0.8) return void (t.textContent = `${e.substring(0, a)}...`); t.textContent = '.'; } } }], [{ key: 'setAttrs', value(t, e) { for (const i in e)e.hasOwnProperty(i) && t.setAttribute(i, e[i]); } }]), t;
}()); const Helpers = (function () { function t(e) { _classCallCheck(this, t), this.w = e.w, this.annoCtx = e; } return _createClass(t, [{ key: 'setOrientations', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const i = this.w; if (t.label.orientation === 'vertical') { const a = e !== null ? e : 0; const s = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a, "']")); if (s !== null) { const r = s.getBoundingClientRect(); s.setAttribute('x', parseFloat(s.getAttribute('x')) - r.height + 4), t.label.position === 'top' ? s.setAttribute('y', parseFloat(s.getAttribute('y')) + r.width) : s.setAttribute('y', parseFloat(s.getAttribute('y')) - r.width); const n = this.annoCtx.graphics.rotateAroundCenter(s); const o = n.x; const l = n.y; s.setAttribute('transform', 'rotate(-90 '.concat(o, ' ').concat(l, ')')); } } } }, { key: 'addBackgroundToAnno', value(t, e) { const i = this.w; if (!e.label.text || e.label.text && !e.label.text.trim()) return null; const a = i.globals.dom.baseEl.querySelector('.apexcharts-grid').getBoundingClientRect(); const s = t.getBoundingClientRect(); let r = e.label.style.padding.left; let n = e.label.style.padding.right; let o = e.label.style.padding.top; let l = e.label.style.padding.bottom; e.label.orientation === 'vertical' && (o = e.label.style.padding.left, l = e.label.style.padding.right, r = e.label.style.padding.top, n = e.label.style.padding.bottom); const h = s.left - a.left - r; const c = s.top - a.top - o; const d = this.annoCtx.graphics.drawRect(h, c, s.width + r + n, s.height + o + l, 0, e.label.style.background, 1, e.label.borderWidth, e.label.borderColor, 0); return e.id && d.node.classList.add(e.id), d; } }, { key: 'annotationsBackground', value() { const t = this; const e = this.w; const i = function (i, a, s) { const r = e.globals.dom.baseEl.querySelector('.apexcharts-'.concat(s, '-annotations .apexcharts-').concat(s, "-annotation-label[rel='").concat(a, "']")); if (r) { const n = r.parentNode; const o = t.addBackgroundToAnno(r, i); o && n.insertBefore(o.node, r); } }; e.config.annotations.xaxis.map(((t, e) => { i(t, e, 'xaxis'); })), e.config.annotations.yaxis.map(((t, e) => { i(t, e, 'yaxis'); })), e.config.annotations.points.map(((t, e) => { i(t, e, 'point'); })); } }, { key: 'getStringX', value(t) { const e = this.w; let i = t; e.config.xaxis.convertedCatToNumeric && (t = e.globals.categoryLabels.indexOf(t) + 1); const a = e.globals.labels.indexOf(t); const s = e.globals.dom.baseEl.querySelector(`.apexcharts-xaxis-texts-g text:nth-child(${a + 1})`); return s && (i = parseFloat(s.getAttribute('x'))), i; } }]), t; }()); const XAnnotations = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.annoCtx = e, this.invertAxis = this.annoCtx.invertAxis; } return _createClass(t, [{
    key: 'addXaxisAnnotation',
    value(t, e, i) {
      const a = this.w; const s = this.invertAxis ? a.globals.minY : a.globals.minX; const r = this.invertAxis ? a.globals.maxY : a.globals.maxX; const n = this.invertAxis ? a.globals.yRange[0] : a.globals.xRange; let o = (t.x - s) / (n / a.globals.gridWidth); this.annoCtx.inversedReversedAxis && (o = (r - t.x) / (n / a.globals.gridWidth)); const l = t.label.text; a.config.xaxis.type !== 'category' && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || (o = this.annoCtx.helpers.getStringX(t.x)); const h = t.strokeDashArray; if (!(o < 0 || o > a.globals.gridWidth)) {
        if (t.x2 === null) { const c = this.annoCtx.graphics.drawLine(o + t.offsetX, 0 + t.offsetY, o + t.offsetX, a.globals.gridHeight + t.offsetY, t.borderColor, h, t.borderWidth); e.appendChild(c.node), t.id && c.node.classList.add(t.id); } else { let d = (t.x2 - s) / (n / a.globals.gridWidth); if (this.annoCtx.inversedReversedAxis && (d = (r - t.x2) / (n / a.globals.gridWidth)), a.config.xaxis.type !== 'category' && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || (d = this.annoCtx.helpers.getStringX(t.x2)), d < o) { const g = o; o = d, d = g; } if (l) { const u = this.annoCtx.graphics.drawRect(o + t.offsetX, 0 + t.offsetY, d - o, a.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, h); e.appendChild(u.node), t.id && u.node.classList.add(t.id); } } const p = t.label.position === 'top' ? -3 : a.globals.gridHeight; const f = this.annoCtx.graphics.getTextRects(l, parseFloat(t.label.style.fontSize)); const x = this.annoCtx.graphics.drawText({
          x: o + t.label.offsetX, y: p + t.label.offsetY - (t.label.position === 'top' ? f.width / 2 - 12 : -f.width / 2), text: l, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, foreColor: t.label.style.color, cssClass: 'apexcharts-xaxis-annotation-label '.concat(t.label.style.cssClass, ' ').concat(t.id ? t.id : ''),
        }); x.attr({ rel: i }), e.appendChild(x.node), this.annoCtx.helpers.setOrientations(t, i);
      }
    },
  }, { key: 'drawXAxisAnnotations', value() { const t = this; const e = this.w; const i = this.annoCtx.graphics.group({ class: 'apexcharts-xaxis-annotations' }); return e.config.annotations.xaxis.map(((e, a) => { t.addXaxisAnnotation(e, i.node, a); })), i; } }]), t;
}()); const YAnnotations = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.annoCtx = e; } return _createClass(t, [{
    key: 'addYaxisAnnotation',
    value(t, e, i) {
      let a; const s = this.w; const r = t.strokeDashArray; let n = this._getY1Y2('y1', t); const o = t.label.text; if (t.y2 === null) { const l = this.annoCtx.graphics.drawLine(0 + t.offsetX, n + t.offsetY, s.globals.gridWidth + t.offsetX, n + t.offsetY, t.borderColor, r, t.borderWidth); e.appendChild(l.node), t.id && l.node.classList.add(t.id); } else { if ((a = this._getY1Y2('y2', t)) > n) { const h = n; n = a, a = h; } if (o) { const c = this.annoCtx.graphics.drawRect(0 + t.offsetX, a + t.offsetY, s.globals.gridWidth + t.offsetX, n - a, 0, t.fillColor, t.opacity, 1, t.borderColor, r); e.appendChild(c.node), t.id && c.node.classList.add(t.id); } } const d = t.label.position === 'right' ? s.globals.gridWidth : 0; const g = this.annoCtx.graphics.drawText({
        x: d + t.label.offsetX, y: (a || n) + t.label.offsetY - 3, text: o, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, foreColor: t.label.style.color, cssClass: 'apexcharts-yaxis-annotation-label '.concat(t.label.style.cssClass, ' ').concat(t.id ? t.id : ''),
      }); g.attr({ rel: i }), e.appendChild(g.node);
    },
  }, { key: '_getY1Y2', value(t, e) { let i; const a = t === 'y1' ? e.y : e.y2; const s = this.w; if (this.annoCtx.invertAxis) { let r = s.globals.labels.indexOf(a); s.config.xaxis.convertedCatToNumeric && (r = s.globals.categoryLabels.indexOf(a)); const n = s.globals.dom.baseEl.querySelector(`.apexcharts-yaxis-texts-g text:nth-child(${r + 1})`); n && (i = parseFloat(n.getAttribute('y'))); } else i = s.globals.gridHeight - (a - s.globals.minYArr[e.yAxisIndex]) / (s.globals.yRange[e.yAxisIndex] / s.globals.gridHeight), s.config.yaxis[e.yAxisIndex] && s.config.yaxis[e.yAxisIndex].reversed && (i = (a - s.globals.minYArr[e.yAxisIndex]) / (s.globals.yRange[e.yAxisIndex] / s.globals.gridHeight)); return i; } }, { key: 'drawYAxisAnnotations', value() { const t = this; const e = this.w; const i = this.annoCtx.graphics.group({ class: 'apexcharts-yaxis-annotations' }); return e.config.annotations.yaxis.map(((e, a) => { t.addYaxisAnnotation(e, i.node, a); })), i; } }]), t;
}()); const PointAnnotations = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.annoCtx = e; } return _createClass(t, [{
    key: 'addPointAnnotation',
    value(t, e, i) {
      const a = this.w; let s = 0; let r = 0; let n = 0; if (this.annoCtx.invertAxis && console.warn('Point annotation is not supported in horizontal bar charts.'), typeof t.x === 'string') { let o = a.globals.labels.indexOf(t.x); a.config.xaxis.convertedCatToNumeric && (o = a.globals.categoryLabels.indexOf(t.x)), s = this.annoCtx.helpers.getStringX(t.x); let l = t.y; t.y === null && (l = a.globals.series[t.seriesIndex][o]), r = a.globals.gridHeight - (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight) - parseFloat(t.label.style.fontSize) - t.marker.size, n = a.globals.gridHeight - (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight), a.config.yaxis[t.yAxisIndex] && a.config.yaxis[t.yAxisIndex].reversed && (r = (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight) + parseFloat(t.label.style.fontSize) + t.marker.size, n = (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight)); } else s = (t.x - a.globals.minX) / (a.globals.xRange / a.globals.gridWidth), r = a.globals.gridHeight - (parseFloat(t.y) - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight) - parseFloat(t.label.style.fontSize) - t.marker.size, n = a.globals.gridHeight - (t.y - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight), a.config.yaxis[t.yAxisIndex] && a.config.yaxis[t.yAxisIndex].reversed && (r = (parseFloat(t.y) - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight) - parseFloat(t.label.style.fontSize) - t.marker.size, n = (t.y - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight)); if (!(s < 0 || s > a.globals.gridWidth)) {
        const h = {
          pSize: t.marker.size, pWidth: t.marker.strokeWidth, pointFillColor: t.marker.fillColor, pointStrokeColor: t.marker.strokeColor, shape: t.marker.shape, radius: t.marker.radius, class: 'apexcharts-point-annotation-marker '.concat(t.marker.cssClass, ' ').concat(t.id ? t.id : ''),
        }; const c = this.annoCtx.graphics.drawMarker(s + t.marker.offsetX, n + t.marker.offsetY, h); e.appendChild(c.node); const d = t.label.text ? t.label.text : ''; const
          g = this.annoCtx.graphics.drawText({
            x: s + t.label.offsetX, y: r + t.label.offsetY, text: d, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, foreColor: t.label.style.color, cssClass: 'apexcharts-point-annotation-label '.concat(t.label.style.cssClass, ' ').concat(t.id ? t.id : ''),
          }); if (g.attr({ rel: i }), e.appendChild(g.node), t.customSVG.SVG) { const u = this.annoCtx.graphics.group({ class: `apexcharts-point-annotations-custom-svg ${t.customSVG.cssClass}` }); u.attr({ transform: 'translate('.concat(s + t.customSVG.offsetX, ', ').concat(r + t.customSVG.offsetY, ')') }), u.node.innerHTML = t.customSVG.SVG, e.appendChild(u.node); }
      }
    },
  }, { key: 'drawPointAnnotations', value() { const t = this; const e = this.w; const i = this.annoCtx.graphics.group({ class: 'apexcharts-point-annotations' }); return e.config.annotations.points.map(((e, a) => { t.addPointAnnotation(e, i.node, a); })), i; } }]), t;
}()); const name = 'en'; const options = {
  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  toolbar: {
    exportToSVG: 'Download SVG', exportToPNG: 'Download PNG', exportToCSV: 'Download CSV', menu: 'Menu', selection: 'Selection', selectionZoom: 'Selection Zoom', zoomIn: 'Zoom In', zoomOut: 'Zoom Out', pan: 'Panning', reset: 'Reset Zoom',
  },
}; const en = { name: 'en', options }; const Options = (function () {
  function t() {
    _classCallCheck(this, t), this.yAxis = {
      show: !0,
      showAlways: !1,
      seriesName: void 0,
      opposite: !1,
      reversed: !1,
      logarithmic: !1,
      tickAmount: void 0,
      forceNiceScale: !1,
      max: void 0,
      min: void 0,
      floating: !1,
      decimalsInFloat: void 0,
      labels: {
        show: !0,
        minWidth: 0,
        maxWidth: 160,
        offsetX: 0,
        offsetY: 0,
        align: void 0,
        rotate: 0,
        padding: 20,
        style: {
          colors: [], fontSize: '11px', fontFamily: void 0, cssClass: '',
        },
        formatter: void 0,
      },
      axisBorder: {
        show: !1, color: '#e0e0e0', width: 1, offsetX: 0, offsetY: 0,
      },
      axisTicks: {
        show: !1, color: '#e0e0e0', width: 6, offsetX: 0, offsetY: 0,
      },
      title: {
        text: void 0,
        rotate: 90,
        offsetY: 0,
        offsetX: 0,
        style: {
          color: void 0, fontSize: '11px', fontFamily: void 0, cssClass: '',
        },
      },
      tooltip: { enabled: !1, offsetX: 0 },
      crosshairs: { show: !0, position: 'front', stroke: { color: '#b6b6b6', width: 1, dashArray: 0 } },
    }, this.pointAnnotation = {
      x: 0,
      y: null,
      yAxisIndex: 0,
      seriesIndex: 0,
      marker: {
        size: 4, fillColor: '#fff', strokeWidth: 2, strokeColor: '#333', shape: 'circle', offsetX: 0, offsetY: 0, radius: 2, cssClass: '',
      },
      label: {
        borderColor: '#c2c2c2',
        borderWidth: 1,
        text: void 0,
        textAnchor: 'middle',
        offsetX: 0,
        offsetY: -15,
        style: {
          background: '#fff',
          color: void 0,
          fontSize: '11px',
          fontFamily: void 0,
          cssClass: '',
          padding: {
            left: 5, right: 5, top: 2, bottom: 2,
          },
        },
      },
      customSVG: {
        SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0,
      },
    }, this.yAxisAnnotation = {
      y: 0,
      y2: null,
      strokeDashArray: 1,
      fillColor: '#c2c2c2',
      borderColor: '#c2c2c2',
      borderWidth: 1,
      opacity: 0.3,
      offsetX: 0,
      offsetY: 0,
      yAxisIndex: 0,
      label: {
        borderColor: '#c2c2c2',
        borderWidth: 1,
        text: void 0,
        textAnchor: 'end',
        position: 'right',
        offsetX: 0,
        offsetY: -3,
        style: {
          background: '#fff',
          color: void 0,
          fontSize: '11px',
          fontFamily: void 0,
          cssClass: '',
          padding: {
            left: 5, right: 5, top: 2, bottom: 2,
          },
        },
      },
    }, this.xAxisAnnotation = {
      x: 0,
      x2: null,
      strokeDashArray: 1,
      fillColor: '#c2c2c2',
      borderColor: '#c2c2c2',
      borderWidth: 1,
      opacity: 0.3,
      offsetX: 0,
      offsetY: 0,
      label: {
        borderColor: '#c2c2c2',
        borderWidth: 1,
        text: void 0,
        textAnchor: 'middle',
        orientation: 'vertical',
        position: 'top',
        offsetX: 0,
        offsetY: 0,
        style: {
          background: '#fff',
          color: void 0,
          fontSize: '11px',
          fontFamily: void 0,
          cssClass: '',
          padding: {
            left: 5, right: 5, top: 2, bottom: 2,
          },
        },
      },
    };
  } return _createClass(t, [{
    key: 'init',
    value() {
      return {
        annotations: {
          position: 'front', yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation],
        },
        chart: {
          animations: {
            enabled: !0, easing: 'easeinout', speed: 800, animateGradually: { delay: 150, enabled: !0 }, dynamicAnimation: { enabled: !0, speed: 350 },
          },
          background: 'transparent',
          locales: [en],
          defaultLocale: 'en',
          dropShadow: {
            enabled: !1, enabledSeries: void 0, top: 2, left: 2, blur: 4, color: '#000', opacity: 0.35,
          },
          events: {
            animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, zoomed: void 0, scrolled: void 0,
          },
          foreColor: '#373d3f',
          fontFamily: 'Helvetica, Arial, sans-serif',
          height: 'auto',
          parentHeightOffset: 15,
          redrawOnParentResize: !0,
          id: void 0,
          group: void 0,
          offsetX: 0,
          offsetY: 0,
          selection: {
            enabled: !1,
            type: 'x',
            fill: { color: '#24292e', opacity: 0.1 },
            stroke: {
              width: 1, color: '#24292e', opacity: 0.4, dashArray: 3,
            },
            xaxis: { min: void 0, max: void 0 },
            yaxis: { min: void 0, max: void 0 },
          },
          sparkline: { enabled: !1 },
          brush: { enabled: !1, autoScaleYaxis: !0, target: void 0 },
          stacked: !1,
          stackType: 'normal',
          toolbar: {
            show: !0,
            tools: {
              download: !0, selection: !0, zoom: !0, zoomin: !0, zoomout: !0, pan: !0, reset: !0, customIcons: [],
            },
            autoSelected: 'zoom',
          },
          type: 'line',
          width: '100%',
          zoom: {
            enabled: !0, type: 'x', autoScaleYaxis: !1, zoomedArea: { fill: { color: '#90CAF9', opacity: 0.4 }, stroke: { color: '#0D47A1', opacity: 0.4, width: 1 } },
          },
        },
        plotOptions: {
          bar: {
            horizontal: !1,
            columnWidth: '70%',
            barHeight: '70%',
            distributed: !1,
            endingShape: 'flat',
            colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1 },
            dataLabels: {
              position: 'top', maxItems: 100, hideOverflowingLabels: !0, orientation: 'horizontal',
            },
          },
          bubble: { minBubbleRadius: void 0, maxBubbleRadius: void 0 },
          candlestick: { colors: { upward: '#00B746', downward: '#EF403C' }, wick: { useFillColor: !0 } },
          heatmap: {
            radius: 2,
            enableShades: !0,
            shadeIntensity: 0.5,
            reverseNegativeShade: !1,
            distributed: !1,
            colorScale: {
              inverse: !1, ranges: [], min: void 0, max: void 0,
            },
          },
          radialBar: {
            size: void 0,
            inverseOrder: !1,
            startAngle: 0,
            endAngle: 360,
            offsetX: 0,
            offsetY: 0,
            hollow: {
              margin: 5,
              size: '50%',
              background: 'transparent',
              image: void 0,
              imageWidth: 150,
              imageHeight: 150,
              imageOffsetX: 0,
              imageOffsetY: 0,
              imageClipped: !0,
              position: 'front',
              dropShadow: {
                enabled: !1, top: 0, left: 0, blur: 3, color: '#000', opacity: 0.5,
              },
            },
            track: {
              show: !0,
              startAngle: void 0,
              endAngle: void 0,
              background: '#f2f2f2',
              strokeWidth: '97%',
              opacity: 1,
              margin: 5,
              dropShadow: {
                enabled: !1, top: 0, left: 0, blur: 3, color: '#000', opacity: 0.5,
              },
            },
            dataLabels: {
              show: !0,
              name: {
                show: !0, fontSize: '16px', fontFamily: void 0, color: void 0, offsetY: 0, formatter(t) { return t; },
              },
              value: {
                show: !0, fontSize: '14px', fontFamily: void 0, color: void 0, offsetY: 16, formatter(t) { return `${t}%`; },
              },
              total: {
                show: !1, label: 'Total', color: void 0, formatter(t) { return `${t.globals.seriesTotals.reduce(((t, e) => t + e), 0) / t.globals.series.length}%`; },
              },
            },
          },
          pie: {
            size: void 0,
            customScale: 1,
            offsetX: 0,
            offsetY: 0,
            expandOnClick: !0,
            dataLabels: { offset: 0, minAngleToShowLabel: 10 },
            donut: {
              size: '65%',
              background: 'transparent',
              labels: {
                show: !1,
                name: {
                  show: !0, fontSize: '16px', fontFamily: void 0, color: void 0, offsetY: -10, formatter(t) { return t; },
                },
                value: {
                  show: !0, fontSize: '20px', fontFamily: void 0, color: void 0, offsetY: 10, formatter(t) { return t; },
                },
                total: {
                  show: !1, showAlways: !1, label: 'Total', color: void 0, formatter(t) { return t.globals.seriesTotals.reduce(((t, e) => t + e), 0); },
                },
              },
            },
          },
          radar: {
            size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeColors: '#e8e8e8', connectorColors: '#e8e8e8', fill: { colors: void 0 } },
          },
        },
        colors: void 0,
        dataLabels: {
          enabled: !0,
          enabledOnSeries: void 0,
          formatter(t) { return t !== null ? t : ''; },
          textAnchor: 'middle',
          offsetX: 0,
          offsetY: 0,
          style: {
            fontSize: '12px', fontFamily: void 0, fontWeight: 'bold', colors: void 0,
          },
          background: {
            enabled: !0, foreColor: '#fff', borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: '#fff',
          },
          dropShadow: {
            enabled: !1, top: 1, left: 1, blur: 1, color: '#000', opacity: 0.45,
          },
        },
        fill: {
          type: 'solid',
          colors: void 0,
          opacity: 0.85,
          gradient: {
            shade: 'dark', type: 'horizontal', shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [],
          },
          image: { src: [], width: void 0, height: void 0 },
          pattern: {
            style: 'squares', width: 6, height: 6, strokeWidth: 2,
          },
        },
        grid: {
          show: !0,
          borderColor: '#e0e0e0',
          strokeDashArray: 0,
          position: 'back',
          xaxis: { lines: { show: !1 } },
          yaxis: { lines: { show: !0 } },
          row: { colors: void 0, opacity: 0.5 },
          column: { colors: void 0, opacity: 0.5 },
          padding: {
            top: 0, right: 10, bottom: 0, left: 12,
          },
        },
        labels: [],
        legend: {
          show: !0,
          showForSingleSeries: !1,
          showForNullSeries: !0,
          showForZeroSeries: !0,
          floating: !1,
          position: 'bottom',
          horizontalAlign: 'center',
          inverseOrder: !1,
          fontSize: '12px',
          fontFamily: void 0,
          width: void 0,
          height: void 0,
          formatter: void 0,
          tooltipHoverFormatter: void 0,
          offsetX: -20,
          offsetY: 0,
          labels: { colors: void 0, useSeriesColors: !1 },
          markers: {
            width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: '#fff', radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0,
          },
          itemMargin: { horizontal: 5, vertical: 0 },
          onItemClick: { toggleDataSeries: !0 },
          onItemHover: { highlightDataSeries: !0 },
        },
        markers: {
          discrete: [], size: 0, colors: void 0, strokeColors: '#fff', strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: 'circle', radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 },
        },
        noData: {
          text: void 0, align: 'center', verticalAlign: 'middle', offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: '14px', fontFamily: void 0 },
        },
        responsive: [],
        series: void 0,
        states: { normal: { filter: { type: 'none', value: 0 } }, hover: { filter: { type: 'lighten', value: 0.15 } }, active: { allowMultipleDataPointsSelection: !1, filter: { type: 'darken', value: 0.65 } } },
        title: {
          text: void 0, align: 'left', margin: 5, offsetX: 0, offsetY: 0, floating: !1, style: { fontSize: '14px', fontFamily: void 0, color: void 0 },
        },
        subtitle: {
          text: void 0, align: 'left', margin: 5, offsetX: 0, offsetY: 30, floating: !1, style: { fontSize: '12px', fontFamily: void 0, color: void 0 },
        },
        stroke: {
          show: !0, curve: 'smooth', lineCap: 'butt', width: 2, colors: void 0, dashArray: 0,
        },
        tooltip: {
          enabled: !0,
          enabledOnSeries: void 0,
          shared: !0,
          followCursor: !1,
          intersect: !1,
          inverseOrder: !1,
          custom: void 0,
          fillSeriesColor: !1,
          theme: 'light',
          style: { fontSize: '12px', fontFamily: void 0 },
          onDatasetHover: { highlightDataSeries: !1 },
          x: { show: !0, format: 'dd MMM', formatter: void 0 },
          y: { formatter: void 0, title: { formatter(t) { return t; } } },
          z: { formatter: void 0, title: 'Size: ' },
          marker: { show: !0, fillColors: void 0 },
          items: { display: 'flex' },
          fixed: {
            enabled: !1, position: 'topRight', offsetX: 0, offsetY: 0,
          },
        },
        xaxis: {
          type: 'category',
          categories: [],
          convertedCatToNumeric: !1,
          offsetX: 0,
          offsetY: 0,
          labels: {
            show: !0,
            rotate: -45,
            rotateAlways: !1,
            hideOverlappingLabels: !0,
            trim: !0,
            minHeight: void 0,
            maxHeight: 120,
            showDuplicates: !0,
            style: {
              colors: [], fontSize: '12px', fontFamily: void 0, cssClass: '',
            },
            offsetX: 0,
            offsetY: 0,
            format: void 0,
            formatter: void 0,
            datetimeUTC: !0,
            datetimeFormatter: {
              year: 'yyyy', month: "MMM 'yy", day: 'dd MMM', hour: 'HH:mm', minute: 'HH:mm:ss',
            },
          },
          axisBorder: {
            show: !0, color: '#e0e0e0', width: '100%', height: 1, offsetX: 0, offsetY: 0,
          },
          axisTicks: {
            show: !0, color: '#e0e0e0', height: 6, offsetX: 0, offsetY: 0,
          },
          tickAmount: void 0,
          tickPlacement: 'on',
          min: void 0,
          max: void 0,
          range: void 0,
          floating: !1,
          position: 'bottom',
          title: {
            text: void 0,
            offsetX: 0,
            offsetY: 0,
            style: {
              color: void 0, fontSize: '12px', fontFamily: void 0, cssClass: '',
            },
          },
          crosshairs: {
            show: !0,
            width: 1,
            position: 'back',
            opacity: 0.9,
            stroke: { color: '#b6b6b6', width: 1, dashArray: 3 },
            fill: {
              type: 'solid',
              color: '#B1B9C4',
              gradient: {
                colorFrom: '#D8E3F0', colorTo: '#BED1E6', stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5,
              },
            },
            dropShadow: {
              enabled: !1, left: 0, top: 0, blur: 1, opacity: 0.4,
            },
          },
          tooltip: {
            enabled: !0, offsetY: 0, formatter: void 0, style: { fontSize: '12px', fontFamily: void 0 },
          },
        },
        yaxis: this.yAxis,
        theme: {
          mode: 'light',
          palette: 'palette1',
          monochrome: {
            enabled: !1, color: '#008FFB', shadeTo: 'light', shadeIntensity: 0.65,
          },
        },
      };
    },
  }]), t;
}()); const Annotations = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.graphics = new Graphics(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new Helpers(this), this.xAxisAnnotations = new XAnnotations(this), this.yAxisAnnotations = new YAnnotations(this), this.pointsAnnotations = new PointAnnotations(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints; } return _createClass(t, [{ key: 'drawAnnotations', value() { const t = this.w; if (t.globals.axisCharts) { for (let e = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), a = this.pointsAnnotations.drawPointAnnotations(), s = t.config.chart.animations.enabled, r = [e, i, a], n = [i.node, e.node, a.node], o = 0; o < 3; o++)t.globals.dom.elGraphical.add(r[o]), !s || t.globals.resized || t.globals.dataChanged || t.config.chart.type !== 'scatter' && t.config.chart.type !== 'bubble' && n[o].classList.add('apexcharts-element-hidden'), t.globals.delayedElements.push({ el: n[o], index: 0 }); this.helpers.annotationsBackground(); } } }, { key: 'addXaxisAnnotation', value(t, e, i) { this.xAxisAnnotations.addXaxisAnnotation(t, e, i); } }, { key: 'addYaxisAnnotation', value(t, e, i) { this.yAxisAnnotations.addYaxisAnnotation(t, e, i); } }, { key: 'addPointAnnotation', value(t, e, i) { this.pointsAnnotations.addPointAnnotation(t, e, i); } }, { key: 'clearAnnotations', value(t) { const e = t.w; let i = e.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations'); e.globals.memory.methodsToExec.map(((t, i) => { t.label !== 'addText' && t.label !== 'addAnnotation' || e.globals.memory.methodsToExec.splice(i, 1); })), i = Utils.listToArray(i), Array.prototype.forEach.call(i, ((t) => { for (;t.firstChild;)t.removeChild(t.firstChild); })); } }, { key: 'removeAnnotation', value(t, e) { const i = t.w; const a = i.globals.dom.baseEl.querySelectorAll('.'.concat(e)); a && (i.globals.memory.methodsToExec.map(((t, a) => { t.id === e && i.globals.memory.methodsToExec.splice(a, 1); })), Array.prototype.forEach.call(a, ((t) => { t.parentElement.removeChild(t); }))); } }, {
    key: 'addText',
    value(t, e, i) {
      const a = t.x; const s = t.y; const r = t.text; const n = t.textAnchor; const o = t.appendTo; const l = void 0 === o ? '.apexcharts-inner' : o; const h = t.foreColor; const c = t.fontSize; const d = t.fontFamily; const g = t.cssClass; const u = t.backgroundColor; const p = t.borderWidth; const f = t.strokeDashArray; const x = t.radius; const b = t.borderColor; const m = t.paddingLeft; const v = void 0 === m ? 4 : m; const y = t.paddingRight; const w = void 0 === y ? 4 : y; const k = t.paddingBottom; const C = void 0 === k ? 2 : k; const A = t.paddingTop; const S = void 0 === A ? 2 : A; const L = i; const P = L.w; const T = P.globals.dom.baseEl.querySelector(l); const z = this.graphics.drawText({
        x: a, y: s, text: r, textAnchor: n || 'start', fontSize: c || '12px', fontFamily: d || P.config.chart.fontFamily, foreColor: h || P.config.chart.foreColor, cssClass: g,
      }); T.appendChild(z.node); const E = z.bbox(); if (r) { const M = this.graphics.drawRect(E.x - v, E.y - S, E.width + v + w, E.height + C + S, x, u, 1, p, b, f); T.insertBefore(M.node, z.node); } return e && P.globals.memory.methodsToExec.push({
        context: L, method: L.addText, label: 'addText', params: t,
      }), i;
    },
  }, {
    key: 'addXaxisAnnotationExternal',
    value(t, e, i) {
      return this.addAnnotationExternal({
        params: t, pushToMemory: e, context: i, type: 'xaxis', contextMethod: i.addXaxisAnnotation,
      }), i;
    },
  }, {
    key: 'addYaxisAnnotationExternal',
    value(t, e, i) {
      return this.addAnnotationExternal({
        params: t, pushToMemory: e, context: i, type: 'yaxis', contextMethod: i.addYaxisAnnotation,
      }), i;
    },
  }, {
    key: 'addPointAnnotationExternal',
    value(t, e, i) {
      return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({
        params: t, pushToMemory: e, context: i, type: 'point', contextMethod: i.addPointAnnotation,
      }), i;
    },
  }, {
    key: 'addAnnotationExternal',
    value(t) {
      const e = t.params; const i = t.pushToMemory; const a = t.context; const s = t.type; const r = t.contextMethod; const n = a; const o = n.w; const l = o.globals.dom.baseEl.querySelector('.apexcharts-'.concat(s, '-annotations')); const h = l.childNodes.length + 1; const c = new Options(); const d = { ...(s === 'xaxis' ? c.xAxisAnnotation : s === 'yaxis' ? c.yAxisAnnotation : c.pointAnnotation) }; const g = Utils.extend(d, e); switch (s) { case 'xaxis': this.addXaxisAnnotation(g, l, h); break; case 'yaxis': this.addYaxisAnnotation(g, l, h); break; case 'point': this.addPointAnnotation(g, l, h); } const u = o.globals.dom.baseEl.querySelector('.apexcharts-'.concat(s, '-annotations .apexcharts-').concat(s, "-annotation-label[rel='").concat(h, "']")); const p = this.helpers.addBackgroundToAnno(u, g); return p && l.insertBefore(p.node, u), i && o.globals.memory.methodsToExec.push({
        context: n, id: g.id ? g.id : Utils.randomId(), method: r, label: 'addAnnotation', params: e,
      }), a;
    },
  }]), t;
}()); const DateTime = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]; } return _createClass(t, [{ key: 'isValidDate', value(t) { return !isNaN(this.parseDate(t)); } }, { key: 'getTimeStamp', value(t) { return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t; } }, { key: 'getDate', value(t) { return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t); } }, { key: 'parseDate', value(t) { const e = Date.parse(t); if (!isNaN(e)) return this.getTimeStamp(t); let i = Date.parse(t.replace(/-/g, '/').replace(/[a-z]+/gi, ' ')); return i = this.getTimeStamp(i); } }, { key: 'formatDate', value(t, e) { const i = this.w.globals.locale; const a = this.w.config.xaxis.labels.datetimeUTC; const s = ['\0'].concat(_toConsumableArray(i.months)); const r = ['\x01'].concat(_toConsumableArray(i.shortMonths)); const n = ['\x02'].concat(_toConsumableArray(i.days)); const o = ['\x03'].concat(_toConsumableArray(i.shortDays)); function l(t, e) { let i = `${t}`; for (e = e || 2; i.length < e;)i = `0${i}`; return i; } const h = a ? t.getUTCFullYear() : t.getFullYear(); e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, `$1${h}`)).replace(/(^|[^\\])yy/g, `$1${h.toString().substr(2, 2)}`)).replace(/(^|[^\\])y/g, `$1${h}`); const c = (a ? t.getUTCMonth() : t.getMonth()) + 1; e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, `$1${s[0]}`)).replace(/(^|[^\\])MMM/g, `$1${r[0]}`)).replace(/(^|[^\\])MM/g, `$1${l(c)}`)).replace(/(^|[^\\])M/g, `$1${c}`); const d = a ? t.getUTCDate() : t.getDate(); e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, `$1${n[0]}`)).replace(/(^|[^\\])ddd/g, `$1${o[0]}`)).replace(/(^|[^\\])dd/g, `$1${l(d)}`)).replace(/(^|[^\\])d/g, `$1${d}`); const g = a ? t.getUTCHours() : t.getHours(); const u = g > 12 ? g - 12 : g === 0 ? 12 : g; e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, `$1${l(g)}`)).replace(/(^|[^\\])H/g, `$1${g}`)).replace(/(^|[^\\])hh+/g, `$1${l(u)}`)).replace(/(^|[^\\])h/g, `$1${u}`); const p = a ? t.getUTCMinutes() : t.getMinutes(); e = (e = e.replace(/(^|[^\\])mm+/g, `$1${l(p)}`)).replace(/(^|[^\\])m/g, `$1${p}`); const f = a ? t.getUTCSeconds() : t.getSeconds(); e = (e = e.replace(/(^|[^\\])ss+/g, `$1${l(f)}`)).replace(/(^|[^\\])s/g, `$1${f}`); let x = a ? t.getUTCMilliseconds() : t.getMilliseconds(); e = e.replace(/(^|[^\\])fff+/g, `$1${l(x, 3)}`), x = Math.round(x / 10), e = e.replace(/(^|[^\\])ff/g, `$1${l(x)}`), x = Math.round(x / 10); const b = g < 12 ? 'AM' : 'PM'; e = (e = (e = e.replace(/(^|[^\\])f/g, `$1${x}`)).replace(/(^|[^\\])TT+/g, `$1${b}`)).replace(/(^|[^\\])T/g, `$1${b.charAt(0)}`); const m = b.toLowerCase(); e = (e = e.replace(/(^|[^\\])tt+/g, `$1${m}`)).replace(/(^|[^\\])t/g, `$1${m.charAt(0)}`); let v = -t.getTimezoneOffset(); let y = a || !v ? 'Z' : v > 0 ? '+' : '-'; if (!a) { const w = (v = Math.abs(v)) % 60; y += `${l(Math.floor(v / 60))}:${l(w)}`; }e = e.replace(/(^|[^\\])K/g, `$1${y}`); const k = (a ? t.getUTCDay() : t.getDay()) + 1; return e = (e = (e = (e = (e = e.replace(new RegExp(n[0], 'g'), n[k])).replace(new RegExp(o[0], 'g'), o[k])).replace(new RegExp(s[0], 'g'), s[c])).replace(new RegExp(r[0], 'g'), r[c])).replace(/\\(.)/g, '$1'); } }, {
    key: 'getTimeUnitsfromTimestamp',
    value(t, e, i) {
      const a = this.w; void 0 !== a.config.xaxis.min && (t = a.config.xaxis.min), void 0 !== a.config.xaxis.max && (e = a.config.xaxis.max); const s = this.getDate(t); const r = this.getDate(e); const n = this.formatDate(s, 'yyyy MM dd HH mm').split(' '); const o = this.formatDate(r, 'yyyy MM dd HH mm').split(' '); return {
        minMinute: parseInt(n[4], 10), maxMinute: parseInt(o[4], 10), minHour: parseInt(n[3], 10), maxHour: parseInt(o[3], 10), minDate: parseInt(n[2], 10), maxDate: parseInt(o[2], 10), minMonth: parseInt(n[1], 10) - 1, maxMonth: parseInt(o[1], 10) - 1, minYear: parseInt(n[0], 10), maxYear: parseInt(o[0], 10),
      };
    },
  }, { key: 'isLeapYear', value(t) { return t % 4 == 0 && t % 100 != 0 || t % 400 == 0; } }, { key: 'calculcateLastDaysOfMonth', value(t, e, i) { return this.determineDaysOfMonths(t, e) - i; } }, { key: 'determineDaysOfYear', value(t) { let e = 365; return this.isLeapYear(t) && (e = 366), e; } }, { key: 'determineRemainingDaysOfYear', value(t, e, i) { let a = this.daysCntOfYear[e] + i; return e > 1 && this.isLeapYear() && a++, a; } }, { key: 'determineDaysOfMonths', value(t, e) { let i = 30; switch (t = Utils.monthMod(t), !0) { case this.months30.indexOf(t) > -1: t === 2 && (i = this.isLeapYear(e) ? 29 : 28); break; case this.months31.indexOf(t) > -1: default: i = 31; } return i; } }]), t;
}()); const Defaults = (function () {
  function t(e) { _classCallCheck(this, t), this.opts = e; } return _createClass(t, [{
    key: 'line',
    value() {
      return {
        chart: { animations: { easing: 'swing' } }, dataLabels: { enabled: !1 }, stroke: { width: 5, curve: 'straight' }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } },
      };
    },
  }, {
    key: 'sparkline',
    value(t) {
      this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = '', this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0; return Utils.extend(t, {
        grid: {
          show: !1,
          padding: {
            left: 0, right: 0, top: 0, bottom: 0,
          },
        },
        legend: { show: !1 },
        xaxis: {
          labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 },
        },
        chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } },
        dataLabels: { enabled: !1 },
      });
    },
  }, {
    key: 'bar',
    value() {
      return {
        chart: { stacked: !1, animations: { easing: 'swing' } },
        plotOptions: { bar: { dataLabels: { position: 'center' } } },
        dataLabels: { style: { colors: ['#fff'] } },
        stroke: { width: 0 },
        fill: { opacity: 0.85 },
        legend: { markers: { shape: 'square', radius: 2, size: 8 } },
        tooltip: { shared: !1 },
        xaxis: {
          tooltip: { enabled: !1 },
          tickPlacement: 'between',
          crosshairs: {
            width: 'barWidth', position: 'back', fill: { type: 'gradient' }, dropShadow: { enabled: !1 }, stroke: { width: 0 },
          },
        },
      };
    },
  }, {
    key: 'candlestick',
    value() {
      return {
        stroke: { width: 1, colors: ['#333'] }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom(t) { const e = t.seriesIndex; const i = t.dataPointIndex; const a = t.w; return `<div class="apexcharts-tooltip-candlestick"><div>Open: <span class="value">${a.globals.seriesCandleO[e][i]}</span></div><div>High: <span class="value">${a.globals.seriesCandleH[e][i]}</span></div><div>Low: <span class="value">${a.globals.seriesCandleL[e][i]}</span></div><div>Close: <span class="value">${a.globals.seriesCandleC[e][i]}</span></div></div>`; } }, states: { active: { filter: { type: 'none' } } }, xaxis: { crosshairs: { width: 1 } },
      };
    },
  }, {
    key: 'rangeBar',
    value() {
      return {
        stroke: { width: 0 }, plotOptions: { bar: { dataLabels: { position: 'center' } } }, dataLabels: { enabled: !1, formatter(t, e) { e.ctx; const i = e.seriesIndex; const a = e.dataPointIndex; const s = e.w; const r = s.globals.seriesRangeStart[i][a]; return s.globals.seriesRangeEnd[i][a] - r; }, style: { colors: ['#fff'] } }, tooltip: { shared: !1, followCursor: !0, custom(t) { const e = t.ctx; const i = t.seriesIndex; const a = t.dataPointIndex; const s = t.y1; const r = t.y2; const n = t.w; let o = n.globals.seriesRangeStart[i][a]; let l = n.globals.seriesRangeEnd[i][a]; let h = n.globals.labels[a]; s && r && (o = s, l = r, n.config.series[i].data[a].x && (h = n.config.series[i].data[a].x)); let c = ''; let d = ''; const g = n.globals.colors[i]; if (void 0 === n.config.tooltip.x.formatter) if (n.config.xaxis.type === 'datetime') { const u = new DateTime(e); c = u.formatDate(u.getDate(o), n.config.tooltip.x.format), d = u.formatDate(u.getDate(l), n.config.tooltip.x.format); } else c = o, d = l; else c = n.config.tooltip.x.formatter(o), d = n.config.tooltip.x.formatter(l); return `<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ${g}">${n.config.series[i].name ? n.config.series[i].name : ''}</span></div><div> <span class="category">${h}: </span> <span class="value start-value">${c}</span> <span class="separator">-</span> <span class="value end-value">${d}</span></div></div>`; } }, xaxis: { tickPlacement: 'between', tooltip: { enabled: !1 }, crosshairs: { stroke: { width: 0 } } },
      };
    },
  }, {
    key: 'area',
    value() {
      return {
        stroke: { width: 4 },
        fill: {
          type: 'gradient',
          gradient: {
            inverseColors: !1, shade: 'light', type: 'vertical', opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100],
          },
        },
        markers: { size: 0, hover: { sizeOffset: 6 } },
        tooltip: { followCursor: !1 },
      };
    },
  }, {
    key: 'brush',
    value(t) {
      return Utils.extend(t, {
        chart: { toolbar: { autoSelected: 'selection', show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 }, stroke: { width: 1 }, tooltip: { enabled: !1 }, xaxis: { tooltip: { enabled: !1 } },
      });
    },
  }, { key: 'stacked100', value(t) { t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0; const e = t.dataLabels.formatter; return t.yaxis.forEach(((e, i) => { t.yaxis[i].min = 0, t.yaxis[i].max = 100; })), t.chart.type === 'bar' && (t.dataLabels.formatter = e || function (t) { return typeof t === 'number' && t ? `${t.toFixed(0)}%` : t; }), t; } }, { key: 'convertCatToNumeric', value(t) { return t.xaxis.convertedCatToNumeric = !0, t; } }, { key: 'convertCatToNumericXaxis', value(t, e, i) { t.xaxis.type = 'numeric', t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function (t) { return Utils.isNumber(t) ? Math.floor(t) : t; }; const a = t.xaxis.labels.formatter; let s = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels; return i && i.length && (s = i.map(((t) => t.toString()))), s && s.length && (t.xaxis.labels.formatter = function (t) { return Utils.isNumber(t) ? a(s[Math.floor(t) - 1]) : a(t); }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = 'dataPoints', t; } }, {
    key: 'bubble',
    value() {
      return {
        dataLabels: { style: { colors: ['#fff'] } },
        tooltip: { shared: !1, intersect: !0 },
        xaxis: { crosshairs: { width: 0 } },
        fill: {
          type: 'solid',
          gradient: {
            shade: 'light', inverse: !0, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8,
          },
        },
      };
    },
  }, { key: 'scatter', value() { return { dataLabels: { enabled: !1 }, tooltip: { shared: !1, intersect: !0 }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } }; } }, {
    key: 'heatmap',
    value() {
      return {
        chart: { stacked: !1 }, fill: { opacity: 1 }, dataLabels: { style: { colors: ['#fff'] } }, stroke: { colors: ['#fff'] }, tooltip: { followCursor: !0, marker: { show: !1 }, x: { show: !1 } }, legend: { position: 'top', markers: { shape: 'square', size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } },
      };
    },
  }, {
    key: 'pie',
    value() {
      return {
        chart: { toolbar: { show: !1 } },
        plotOptions: { pie: { donut: { labels: { show: !1 } } } },
        dataLabels: { formatter(t) { return `${t.toFixed(1)}%`; }, style: { colors: ['#fff'] }, dropShadow: { enabled: !0 } },
        stroke: { colors: ['#fff'] },
        fill: {
          opacity: 1,
          gradient: {
            shade: 'dark', shadeIntensity: 0.35, inverseColors: !1, stops: [0, 100, 100],
          },
        },
        padding: { right: 0, left: 0 },
        tooltip: { theme: 'dark', fillSeriesColor: !0 },
        legend: { position: 'right' },
      };
    },
  }, {
    key: 'donut',
    value() {
      return {
        chart: { toolbar: { show: !1 } },
        dataLabels: { formatter(t) { return `${t.toFixed(1)}%`; }, style: { colors: ['#fff'] }, dropShadow: { enabled: !0 } },
        stroke: { colors: ['#fff'] },
        fill: {
          opacity: 1,
          gradient: {
            shade: 'dark', shadeIntensity: 0.4, inverseColors: !1, type: 'vertical', opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100],
          },
        },
        padding: { right: 0, left: 0 },
        tooltip: { theme: 'dark', fillSeriesColor: !0 },
        legend: { position: 'right' },
      };
    },
  }, {
    key: 'radar',
    value() {
      return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
        dataLabels: { enabled: !1, style: { fontSize: '11px' } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, grid: { show: !1 }, xaxis: { labels: { formatter(t) { return t; }, style: { colors: ['#a8a8a8'], fontSize: '11px' } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } },
      };
    },
  }, {
    key: 'radialBar',
    value() {
      return {
        chart: { animations: { dynamicAnimation: { enabled: !0, speed: 800 } }, toolbar: { show: !1 } },
        fill: {
          gradient: {
            shade: 'dark', shadeIntensity: 0.4, inverseColors: !1, type: 'diagonal2', opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100],
          },
        },
        padding: { right: 0, left: 0 },
        legend: { show: !1, position: 'right' },
        tooltip: { enabled: !1, fillSeriesColor: !0 },
      };
    },
  }]), t;
}()); const Config = (function () { function t(e) { _classCallCheck(this, t), this.opts = e; } return _createClass(t, [{ key: 'init', value(t) { const e = t.responsiveOverride; let i = this.opts; const a = new Options(); const s = new Defaults(i); this.chartType = i.chart.type, this.chartType === 'histogram' && (i.chart.type = 'bar', i = Utils.extend({ plotOptions: { bar: { columnWidth: '99.99%' } } }, i)), i = this.extendYAxis(i), i = this.extendAnnotations(i); let r = a.init(); let n = {}; if (i && _typeof(i) === 'object') { let o = {}; o = ['line', 'area', 'bar', 'candlestick', 'rangeBar', 'histogram', 'bubble', 'scatter', 'heatmap', 'pie', 'donut', 'radar', 'radialBar'].indexOf(i.chart.type) !== -1 ? s[i.chart.type]() : s.line(), i.chart.brush && i.chart.brush.enabled && (o = s.brush(o)), i.chart.stacked && i.chart.stackType === '100%' && (i = s.stacked100(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, e || (i.xaxis.convertedCatToNumeric = !1), ((i = this.checkForCatToNumericXAxis(this.chartType, o, i)).chart.sparkline && i.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (o = s.sparkline(o)), n = Utils.extend(r, o); } const l = Utils.extend(n, window.Apex); return r = Utils.extend(l, i), r = this.handleUserInputErrors(r); } }, { key: 'checkForCatToNumericXAxis', value(t, e, i) { const a = new Defaults(i); const s = t === 'bar' && i.plotOptions && i.plotOptions.bar && i.plotOptions.bar.horizontal; const r = t === 'pie' || t === 'donut' || t === 'radar' || t === 'radialBar' || t === 'heatmap'; const n = i.xaxis.type !== 'datetime' && i.xaxis.type !== 'numeric'; const o = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : e.xaxis && e.xaxis.tickPlacement; return s || r || !n || o === 'between' || (i = a.convertCatToNumeric(i)), i; } }, { key: 'extendYAxis', value(t) { const e = new Options(); (void 0 === t.yaxis || !t.yaxis || Array.isArray(t.yaxis) && t.yaxis.length === 0) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = Utils.extend(t.yaxis, window.Apex.yaxis)), t.yaxis.constructor !== Array ? t.yaxis = [Utils.extend(e.yAxis, t.yaxis)] : t.yaxis = Utils.extendArray(t.yaxis, e.yAxis); let i = !1; return t.yaxis.forEach(((t) => { t.logarithmic && (i = !0); })), i && t.series.length !== t.yaxis.length && (t.yaxis = t.series.map(((i, a) => { if (i.name || (t.series[a].name = 'series-'.concat(a + 1)), t.yaxis[a]) return t.yaxis[a].seriesName = t.series[a].name, t.yaxis[a]; const s = Utils.extend(e.yAxis, t.yaxis[0]); return s.show = !1, s; }))), t; } }, { key: 'extendAnnotations', value(t) { return void 0 === t.annotations && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), t = this.extendPointAnnotations(t); } }, { key: 'extendYAxisAnnotations', value(t) { const e = new Options(); return t.annotations.yaxis = Utils.extendArray(void 0 !== t.annotations.yaxis ? t.annotations.yaxis : [], e.yAxisAnnotation), t; } }, { key: 'extendXAxisAnnotations', value(t) { const e = new Options(); return t.annotations.xaxis = Utils.extendArray(void 0 !== t.annotations.xaxis ? t.annotations.xaxis : [], e.xAxisAnnotation), t; } }, { key: 'extendPointAnnotations', value(t) { const e = new Options(); return t.annotations.points = Utils.extendArray(void 0 !== t.annotations.points ? t.annotations.points : [], e.pointAnnotation), t; } }, { key: 'checkForDarkTheme', value(t) { t.theme && t.theme.mode === 'dark' && (t.tooltip || (t.tooltip = {}), t.tooltip.theme !== 'light' && (t.tooltip.theme = 'dark'), t.chart.foreColor || (t.chart.foreColor = '#f6f7f8'), t.theme.palette || (t.theme.palette = 'palette4')); } }, { key: 'handleUserInputErrors', value(t) { const e = t; if (e.tooltip.shared && e.tooltip.intersect) throw new Error('tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.'); if ((e.chart.type === 'bar' || e.chart.type === 'rangeBar') && e.plotOptions.bar.horizontal) { if (e.yaxis.length > 1) throw new Error('Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false'); e.yaxis[0].reversed && (e.yaxis[0].opposite = !0), e.xaxis.tooltip.enabled = !1, e.yaxis[0].tooltip.enabled = !1, e.chart.zoom.enabled = !1; } return e.chart.type !== 'bar' && e.chart.type !== 'rangeBar' || e.tooltip.shared && (e.xaxis.crosshairs.width === 'barWidth' && e.series.length > 1 && (console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.'), e.xaxis.crosshairs.width = 'tickWidth'), e.plotOptions.bar.horizontal && (e.states.hover.type = 'none', e.tooltip.shared = !1), e.tooltip.followCursor || (console.warn('followCursor option in shared columns cannot be turned off. Please set %ctooltip.followCursor: true', 'color: blue;'), e.tooltip.followCursor = !0)), e.chart.type === 'candlestick' && e.yaxis[0].reversed && (console.warn('Reversed y-axis in candlestick chart is not supported.'), e.yaxis[0].reversed = !1), e.chart.group && e.yaxis[0].labels.minWidth === 0 && console.warn('It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour.'), Array.isArray(e.stroke.width) && e.chart.type !== 'line' && e.chart.type !== 'area' && (console.warn('stroke.width option accepts array only for line and area charts. Reverted back to Number'), e.stroke.width = e.stroke.width[0]), e; } }]), t; }()); const Globals = (function () {
  function t() { _classCallCheck(this, t); } return _createClass(t, [{ key: 'initGlobalVars', value(t) { t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRangeBarTimeline = [], t.seriesPercent = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.x2SpaceAvailable = 0, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0; } }, {
    key: 'globalVars',
    value(t) {
      return {
        chartID: null,
        cuid: null,
        events: {
          beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [],
        },
        colors: [],
        clientX: null,
        clientY: null,
        fill: { colors: [] },
        stroke: { colors: [] },
        dataLabels: { style: { colors: [] } },
        radarPolygons: { fill: { colors: [] } },
        markers: { colors: [], size: t.markers.size, largestSize: 0 },
        animationEnded: !1,
        isTouchDevice: 'ontouchstart' in window || navigator.msMaxTouchPoints,
        isDirty: !1,
        isExecCalled: !1,
        initialConfig: null,
        lastXAxis: [],
        lastYAxis: [],
        columnSeries: null,
        labels: [],
        timescaleLabels: [],
        noLabelsProvided: !1,
        allSeriesCollapsed: !1,
        collapsedSeries: [],
        collapsedSeriesIndices: [],
        ancillaryCollapsedSeries: [],
        ancillaryCollapsedSeriesIndices: [],
        risingSeries: [],
        dataFormatXNumeric: !1,
        capturedSeriesIndex: -1,
        capturedDataPointIndex: -1,
        selectedDataPoints: [],
        goldenPadding: 35,
        invalidLogScale: !1,
        ignoreYAxisIndexes: [],
        yAxisSameScaleIndices: [],
        maxValsInArrayIndex: 0,
        radialSize: 0,
        zoomEnabled: t.chart.toolbar.autoSelected === 'zoom' && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled,
        panEnabled: t.chart.toolbar.autoSelected === 'pan' && t.chart.toolbar.tools.pan,
        selectionEnabled: t.chart.toolbar.autoSelected === 'selection' && t.chart.toolbar.tools.selection,
        yaxis: null,
        mousedown: !1,
        lastClientPosition: {},
        visibleXRange: void 0,
        yValueDecimal: 0,
        total: 0,
        SVGNS: 'http://www.w3.org/2000/svg',
        svgWidth: 0,
        svgHeight: 0,
        noData: !1,
        locale: {},
        dom: {},
        memory: { methodsToExec: [] },
        shouldAnimate: !0,
        skipLastTimelinelabel: !1,
        skipFirstTimelinelabel: !1,
        delayedElements: [],
        axisCharts: !0,
        isDataXYZ: !1,
        resized: !1,
        resizeTimer: null,
        comboCharts: !1,
        dataChanged: !1,
        previousPaths: [],
        allSeriesHasEqualX: !0,
        pointsArray: [],
        dataLabelsRects: [],
        lastDrawnDataLabelsIndexes: [],
        x2SpaceAvailable: 0,
        hasNullValues: !1,
        easing: null,
        zoomed: !1,
        gridWidth: 0,
        gridHeight: 0,
        rotateXLabels: !1,
        defaultLabels: !1,
        xLabelFormatter: void 0,
        yLabelFormatters: [],
        xaxisTooltipFormatter: void 0,
        ttKeyFormatter: void 0,
        ttVal: void 0,
        ttZFormatter: void 0,
        LINE_HEIGHT_RATIO: 1.618,
        xAxisLabelsHeight: 0,
        yAxisLabelsWidth: 0,
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0,
        translateYAxisX: [],
        yAxisWidths: [],
        translateXAxisY: 0,
        translateXAxisX: 0,
        tooltip: null,
      };
    },
  }, { key: 'init', value(t) { const e = this.globalVars(t); return this.initGlobalVars(e), e.initialConfig = Utils.extend({}, t), e.initialSeries = JSON.parse(JSON.stringify(e.initialConfig.series)), e.lastXAxis = JSON.parse(JSON.stringify(e.initialConfig.xaxis)), e.lastYAxis = JSON.parse(JSON.stringify(e.initialConfig.yaxis)), e; } }]), t;
}()); const Base = (function () { function t(e) { _classCallCheck(this, t), this.opts = e; } return _createClass(t, [{ key: 'init', value() { const t = new Config(this.opts).init({ responsiveOverride: !1 }); return { config: t, globals: (new Globals()).init(t) }; } }]), t; }()); const CoreUtils = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'getStackedSeriesTotals', value() { const t = this.w; const e = []; if (t.globals.series.length === 0) return e; for (let i = 0; i < t.globals.series[t.globals.maxValsInArrayIndex].length; i++) { for (var a = 0, s = 0; s < t.globals.series.length; s++) void 0 !== t.globals.series[s][i] && (a += t.globals.series[s][i]); e.push(a); } return t.globals.stackedSeriesTotals = e, e; } }, { key: 'getSeriesTotalByIndex', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; return t === null ? this.w.config.series.reduce(((t, e) => t + e), 0) : this.w.globals.series[t].reduce(((t, e) => t + e), 0); } }, { key: 'isSeriesNull', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; return (t === null ? this.w.config.series.filter(((t) => t !== null)) : this.w.globals.series[t].filter(((t) => t !== null))).length === 0; } }, { key: 'seriesHaveSameValues', value(t) { return this.w.globals.series[t].every(((t, e, i) => t === i[0])); } }, { key: 'getCategoryLabels', value(t) { const e = this.w; let i = t.slice(); return e.config.xaxis.convertedCatToNumeric && (i = t.map(((t) => e.config.xaxis.labels.formatter(t - e.globals.minX + 1)))), i; } }, { key: 'getLargestSeries', value() { const t = this.w; t.globals.maxValsInArrayIndex = t.globals.series.map(((t) => t.length)).indexOf(Math.max.apply(Math, t.globals.series.map(((t) => t.length)))); } }, { key: 'getLargestMarkerSize', value() { const t = this.w; let e = 0; return t.globals.markers.size.forEach(((t) => { e = Math.max(e, t); })), t.globals.markers.largestSize = e, e; } }, { key: 'getSeriesTotals', value() { const t = this.w; t.globals.seriesTotals = t.globals.series.map(((t, e) => { let i = 0; if (Array.isArray(t)) for (let a = 0; a < t.length; a++)i += t[a]; else i += t; return i; })); } }, { key: 'getSeriesTotalsXRange', value(t, e) { const i = this.w; return i.globals.series.map(((a, s) => { for (var r = 0, n = 0; n < a.length; n++)i.globals.seriesX[s][n] > t && i.globals.seriesX[s][n] < e && (r += a[n]); return r; })); } }, { key: 'getPercentSeries', value() { const t = this.w; t.globals.seriesPercent = t.globals.series.map(((e, i) => { const a = []; if (Array.isArray(e)) for (let s = 0; s < e.length; s++) { const r = t.globals.stackedSeriesTotals[s]; let n = 0; r && (n = 100 * e[s] / r), a.push(n); } else { const o = 100 * e / t.globals.seriesTotals.reduce(((t, e) => t + e), 0); a.push(o); } return a; })); } }, {
    key: 'getCalculatedRatios',
    value() {
      let t; let e; let i; let a; const s = this.w.globals; const r = []; let n = 0; let o = []; let l = 0.1; let h = 0; if (s.yRange = [], s.isMultipleYAxis) for (let c = 0; c < s.minYArr.length; c++)s.yRange.push(Math.abs(s.minYArr[c] - s.maxYArr[c])), o.push(0); else s.yRange.push(Math.abs(s.minY - s.maxY)); s.xRange = Math.abs(s.maxX - s.minX), s.zRange = Math.abs(s.maxZ - s.minZ); for (let d = 0; d < s.yRange.length; d++)r.push(s.yRange[d] / s.gridHeight); if (e = s.xRange / s.gridWidth, i = Math.abs(s.initialMaxX - s.initialMinX) / s.gridWidth, t = s.yRange / s.gridWidth, a = s.xRange / s.gridHeight, (n = s.zRange / s.gridHeight * 16) || (n = 1), s.minY !== Number.MIN_VALUE && Math.abs(s.minY) !== 0 && (s.hasNegs = !0), s.isMultipleYAxis) { o = []; for (let g = 0; g < r.length; g++)o.push(-s.minYArr[g] / r[g]); } else o.push(-s.minY / r[0]), s.minY !== Number.MIN_VALUE && Math.abs(s.minY) !== 0 && (l = -s.minY / t, h = s.minX / e); return {
        yRatio: r, invertedYRatio: t, zRatio: n, xRatio: e, initialXRatio: i, invertedXRatio: a, baseLineInvertedY: l, baseLineY: o, baseLineX: h,
      };
    },
  }, { key: 'getLogSeries', value(t) { const e = this.w; return e.globals.seriesLog = t.map(((t, i) => (e.config.yaxis[i] && e.config.yaxis[i].logarithmic ? t.map(((t) => (t===null?null:(Math.log(t) - Math.log(e.globals.minYArr[i])) / (Math.log(e.globals.maxYArr[i]) - Math.log(e.globals.minYArr[i]))))) : t))), e.globals.invalidLogScale ? t : e.globals.seriesLog; } }, { key: 'getLogYRatios', value(t) { const e = this; const i = this.w; const a = this.w.globals; return a.yLogRatio = t.slice(), a.logYRange = a.yRange.map(((t, s) => { if (i.config.yaxis[s] && e.w.config.yaxis[s].logarithmic) { let r; let n = -Number.MAX_VALUE; let o = Number.MIN_VALUE; return a.seriesLog.forEach(((t, e) => { t.forEach(((t) => { i.config.yaxis[e] && i.config.yaxis[e].logarithmic && (n = Math.max(t, n), o = Math.min(t, o)); })); })), r = Math.pow(a.yRange[s], Math.abs(o - n) / a.yRange[s]), a.yLogRatio[s] = r / a.gridHeight, r; } })), a.invalidLogScale ? t.slice() : a.yLogRatio; } }], [{ key: 'checkComboSeries', value(t) { let e = !1; let i = 0; return t.length && void 0 !== t[0].type && (e = !0, t.forEach(((t) => { t.type !== 'bar' && t.type !== 'column' && t.type !== 'candlestick' || i++; }))), { comboBarCount: i, comboCharts: e }; } }, { key: 'extendArrayProps', value(t, e) { return e.yaxis && (e = t.extendYAxis(e)), e.annotations && (e.annotations.yaxis && (e = t.extendYAxisAnnotations(e)), e.annotations.xaxis && (e = t.extendXAxisAnnotations(e)), e.annotations.points && (e = t.extendPointAnnotations(e))), e; } }]), t;
}()); const Fill = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0; } return _createClass(t, [{
    key: 'clippedImgArea',
    value(t) {
      const e = this.w; const i = e.config; const a = parseInt(e.globals.gridWidth, 10); const s = parseInt(e.globals.gridHeight, 10); const r = a > s ? a : s; const n = t.image; let o = 0; let l = 0; void 0 === t.width && void 0 === t.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o = i.fill.image.width + 1, l = i.fill.image.height) : (o = r + 1, l = r) : (o = t.width, l = t.height); const h = document.createElementNS(e.globals.SVGNS, 'pattern'); Graphics.setAttrs(h, {
        id: t.patternID, patternUnits: t.patternUnits ? t.patternUnits : 'userSpaceOnUse', width: `${o}px`, height: `${l}px`,
      }); const c = document.createElementNS(e.globals.SVGNS, 'image'); h.appendChild(c), c.setAttributeNS('http://www.w3.org/1999/xlink', 'href', n), Graphics.setAttrs(c, {
        x: 0, y: 0, preserveAspectRatio: 'none', width: `${o}px`, height: `${l}px`,
      }), c.style.opacity = t.opacity, e.globals.dom.elDefs.node.appendChild(h);
    },
  }, { key: 'getSeriesIndex', value(t) { const e = this.w; return (e.config.chart.type === 'bar' || e.config.chart.type === 'rangeBar') && e.config.plotOptions.bar.distributed || e.config.chart.type === 'heatmap' ? this.seriesIndex = t.seriesNumber : this.seriesIndex = t.seriesNumber % e.globals.series.length, this.seriesIndex; } }, {
    key: 'fillPath',
    value(t) {
      const e = this.w; this.opts = t; let i; let a; let s; const r = this.w.config; this.seriesIndex = this.getSeriesIndex(t); let n = this.getFillColors()[this.seriesIndex]; typeof n === 'function' && (n = n({ seriesIndex: this.seriesIndex, value: t.value, w: e })); const o = this.getFillType(this.seriesIndex); let l = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity; let h = n; if (t.color && (n = t.color), n.indexOf('rgb') === -1 ? h = Utils.hexToRgba(n, l) : n.indexOf('rgba') > -1 && (l = `0.${Utils.getOpacityFromRGBA(n)}`), t.opacity && (l = t.opacity), o === 'pattern' && (a = this.handlePatternFill(a, n, l, h)), o === 'gradient' && (s = this.handleGradientFill(s, n, l, this.seriesIndex)), o === 'image') {
        const c = r.fill.image.src; const d = t.patternID ? t.patternID : ''; this.clippedImgArea({
          opacity: l, image: Array.isArray(c) ? t.seriesNumber < c.length ? c[t.seriesNumber] : c[0] : c, width: t.width ? t.width : void 0, height: t.height ? t.height : void 0, patternUnits: t.patternUnits, patternID: 'pattern'.concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d),
        }), i = 'url(#pattern'.concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d, ')');
      } else i = o === 'gradient' ? s : o === 'pattern' ? a : h; return t.solid && (i = h), i;
    },
  }, { key: 'getFillType', value(t) { const e = this.w; return Array.isArray(e.config.fill.type) ? e.config.fill.type[t] : e.config.fill.type; } }, { key: 'getFillColors', value() { const t = this.w; const e = t.config; const i = this.opts; let a = []; return t.globals.comboCharts ? t.config.series[this.seriesIndex].type === 'line' ? t.globals.stroke.colors instanceof Array ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : t.globals.fill.colors instanceof Array ? a = t.globals.fill.colors : a.push(t.globals.fill.colors) : e.chart.type === 'line' ? t.globals.stroke.colors instanceof Array ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : t.globals.fill.colors instanceof Array ? a = t.globals.fill.colors : a.push(t.globals.fill.colors), void 0 !== i.fillColors && (a = [], i.fillColors instanceof Array ? a = i.fillColors.slice() : a.push(i.fillColors)), a; } }, { key: 'handlePatternFill', value(t, e, i, a) { const s = this.w.config; const r = this.opts; const n = new Graphics(this.ctx); const o = void 0 === s.fill.pattern.strokeWidth ? Array.isArray(s.stroke.width) ? s.stroke.width[this.seriesIndex] : s.stroke.width : Array.isArray(s.fill.pattern.strokeWidth) ? s.fill.pattern.strokeWidth[this.seriesIndex] : s.fill.pattern.strokeWidth; const l = e; s.fill.pattern.style instanceof Array ? t = void 0 !== s.fill.pattern.style[r.seriesNumber] ? n.drawPattern(s.fill.pattern.style[r.seriesNumber], s.fill.pattern.width, s.fill.pattern.height, l, o, i) : a : t = n.drawPattern(s.fill.pattern.style, s.fill.pattern.width, s.fill.pattern.height, l, o, i); return t; } }, { key: 'handleGradientFill', value(t, e, i, a) { let s; let r; const n = this.w.config; const o = this.opts; const l = new Graphics(this.ctx); const h = new Utils(); const c = n.fill.gradient.type; const d = void 0 === n.fill.gradient.opacityFrom ? i : Array.isArray(n.fill.gradient.opacityFrom) ? n.fill.gradient.opacityFrom[a] : n.fill.gradient.opacityFrom; const g = void 0 === n.fill.gradient.opacityTo ? i : Array.isArray(n.fill.gradient.opacityTo) ? n.fill.gradient.opacityTo[a] : n.fill.gradient.opacityTo; if (s = e, r = void 0 === n.fill.gradient.gradientToColors || n.fill.gradient.gradientToColors.length === 0 ? n.fill.gradient.shade === 'dark' ? h.shadeColor(-1 * parseFloat(n.fill.gradient.shadeIntensity), e) : h.shadeColor(parseFloat(n.fill.gradient.shadeIntensity), e) : n.fill.gradient.gradientToColors[o.seriesNumber], n.fill.gradient.inverseColors) { const u = s; s = r, r = u; } return l.drawGradient(c, s, r, d, g, o.size, n.fill.gradient.stops, n.fill.gradient.colorStops, a); } }]), t;
}()); const Markers = (function () {
  function t(e, i) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'setGlobalMarkerSize', value() { const t = this.w; if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) { if (t.globals.markers.size.length < t.globals.series.length + 1) for (let e = 0; e <= t.globals.series.length; e++) void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0]); } else t.globals.markers.size = t.config.series.map(((e) => t.config.markers.size)); } }, { key: 'plotChartMarkers', value(t, e, i) { let a; const s = this.w; const r = e; const n = t; let o = null; const l = new Graphics(this.ctx); if (s.globals.markers.size[e] > 0 && (o = l.group({ class: 'apexcharts-series-markers' })).attr('clip-path', 'url(#gridRectMarkerMask'.concat(s.globals.cuid, ')')), n.x instanceof Array) for (let h = 0; h < n.x.length; h++) { let c = i; i === 1 && h === 0 && (c = 0), i === 1 && h === 1 && (c = 1); let d = 'apexcharts-marker'; if (s.config.chart.type !== 'line' && s.config.chart.type !== 'area' || s.globals.comboCharts || s.config.tooltip.intersect || (d += ' no-pointer-events'), Array.isArray(s.config.markers.size) ? s.globals.markers.size[e] > 0 : s.config.markers.size > 0) { Utils.isNumber(n.y[h]) ? d += ' w'.concat(Utils.randomId()) : d = 'apexcharts-nullpoint'; const g = this.getMarkerConfig(d, e, c); s.config.series[r].data[i] && (s.config.series[r].data[i].fillColor && (g.pointFillColor = s.config.series[r].data[i].fillColor), s.config.series[r].data[i].strokeColor && (g.pointStrokeColor = s.config.series[r].data[i].strokeColor)), (a = l.drawMarker(n.x[h], n.y[h], g)).attr('rel', c), a.attr('j', c), a.attr('index', e), a.node.setAttribute('default-marker-size', g.pSize), new Filters(this.ctx).setSelectionFilter(a, e, c), this.addEvents(a), o && o.add(a); } else void 0 === s.globals.pointsArray[e] && (s.globals.pointsArray[e] = []), s.globals.pointsArray[e].push([n.x[h], n.y[h]]); } return o; } }, {
    key: 'getMarkerConfig',
    value(t, e) {
      const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const a = this.w; const s = this.getMarkerStyle(e); let r = a.globals.markers.size[e]; const n = a.config.markers; return i !== null && n.discrete.length && n.discrete.map(((t) => { t.seriesIndex === e && t.dataPointIndex === i && (s.pointStrokeColor = t.strokeColor, s.pointFillColor = t.fillColor, r = t.size); })), {
        pSize: r, pRadius: n.radius, pWidth: n.strokeWidth instanceof Array ? n.strokeWidth[e] : n.strokeWidth, pointStrokeColor: s.pointStrokeColor, pointFillColor: s.pointFillColor, shape: n.shape instanceof Array ? n.shape[e] : n.shape, class: t, pointStrokeOpacity: n.strokeOpacity instanceof Array ? n.strokeOpacity[e] : n.strokeOpacity, pointStrokeDashArray: n.strokeDashArray instanceof Array ? n.strokeDashArray[e] : n.strokeDashArray, pointFillOpacity: n.fillOpacity instanceof Array ? n.fillOpacity[e] : n.fillOpacity, seriesIndex: e,
      };
    },
  }, { key: 'addEvents', value(t) { const e = this.w; const i = new Graphics(this.ctx); t.node.addEventListener('mouseenter', i.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener('mouseleave', i.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener('mousedown', i.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener('click', e.config.markers.onClick), t.node.addEventListener('dblclick', e.config.markers.onDblClick), t.node.addEventListener('touchstart', i.pathMouseDown.bind(this.ctx, t), { passive: !0 }); } }, { key: 'getMarkerStyle', value(t) { const e = this.w; const i = e.globals.markers.colors; const a = e.config.markers.strokeColor || e.config.markers.strokeColors; return { pointStrokeColor: a instanceof Array ? a[t] : a, pointFillColor: i instanceof Array ? i[t] : i }; } }]), t;
}()); const Scatter = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled; } return _createClass(t, [{ key: 'draw', value(t, e, i) { const a = this.w; const s = new Graphics(this.ctx); const r = i.realIndex; const n = i.pointsPos; const o = i.zRatio; const l = i.elParent; const h = s.group({ class: 'apexcharts-series-markers apexcharts-series-'.concat(a.config.chart.type) }); if (h.attr('clip-path', 'url(#gridRectMarkerMask'.concat(a.globals.cuid, ')')), n.x instanceof Array) for (let c = 0; c < n.x.length; c++) { let d = e + 1; let g = !0; e === 0 && c === 0 && (d = 0), e === 0 && c === 1 && (d = 1); let u = 0; let p = a.globals.markers.size[r]; if (o !== 1 / 0) { p = a.globals.seriesZ[r][d] / o; const f = a.config.plotOptions.bubble; f.minBubbleRadius && p < f.minBubbleRadius && (p = f.minBubbleRadius), f.maxBubbleRadius && p > f.maxBubbleRadius && (p = f.maxBubbleRadius); }a.config.chart.animations.enabled || (u = p); const x = n.x[c]; const b = n.y[c]; if (u = u || 0, b !== null && void 0 !== a.globals.series[r][d] || (g = !1), g) { const m = this.drawPoint(x, b, u, p, r, d, e); h.add(m); }l.add(h); } } }, {
    key: 'drawPoint',
    value(t, e, i, a, s, r, n) {
      const o = this.w; const l = s; const h = new Animations(this.ctx); const c = new Filters(this.ctx); const d = new Fill(this.ctx); const g = new Markers(this.ctx); const u = new Graphics(this.ctx); const p = g.getMarkerConfig('apexcharts-marker', l); let f = d.fillPath({ seriesNumber: s, patternUnits: 'objectBoundingBox', value: o.globals.series[s][n] }); const x = u.drawCircle(i); if (o.config.series[l].data[r] && o.config.series[l].data[r].fillColor && (f = o.config.series[l].data[r].fillColor), x.attr({
        cx: t, cy: e, fill: f, stroke: p.pointStrokeColor, 'stroke-width': p.pWidth, 'stroke-dasharray': p.pointStrokeDashArray, 'stroke-opacity': p.pointStrokeOpacity,
      }), o.config.chart.dropShadow.enabled) { const b = o.config.chart.dropShadow; c.dropShadow(x, b, s); } if (this.initialAnim && !o.globals.dataChanged) { let m = 1; o.globals.resized || (m = o.config.chart.animations.speed), h.animateCircleRadius(x, 0, a, m, o.globals.easing, (() => { window.setTimeout((() => { h.animationCompleted(x); }), 100); })); } if (o.globals.dataChanged) if (this.dynamicAnim) { let v; let y; let w; let k; let C = o.config.chart.animations.dynamicAnimation.speed; (k = o.globals.previousPaths[s] && o.globals.previousPaths[s][n]) != null && (v = k.x, y = k.y, w = void 0 !== k.r ? k.r : a); for (let A = 0; A < o.globals.collapsedSeries.length; A++)o.globals.collapsedSeries[A].index === s && (C = 1, a = 0); t === 0 && e === 0 && (a = 0), h.animateCircle(x, { cx: v, cy: y, r: w }, { cx: t, cy: e, r: a }, C, o.globals.easing); } else x.attr({ r: a }); return x.attr({
        rel: r, j: r, index: s, 'default-marker-size': a,
      }), c.setSelectionFilter(x, s, r), g.addEvents(x), x.node.classList.add('apexcharts-marker'), x;
    },
  }, { key: 'centerTextInBubble', value(t) { const e = this.w; return { y: t += parseInt(e.config.dataLabels.style.fontSize, 10) / 4 }; } }]), t;
}()); const DataLabels = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{
    key: 'dataLabelsCorrection',
    value(t, e, i, a, s, r, n) {
      const o = this.w; let l = !1; const h = new Graphics(this.ctx).getTextRects(i, n); const c = h.width; const d = h.height; void 0 === o.globals.dataLabelsRects[a] && (o.globals.dataLabelsRects[a] = []), o.globals.dataLabelsRects[a].push({
        x: t, y: e, width: c, height: d,
      }); const g = o.globals.dataLabelsRects[a].length - 2; const u = void 0 !== o.globals.lastDrawnDataLabelsIndexes[a] ? o.globals.lastDrawnDataLabelsIndexes[a][o.globals.lastDrawnDataLabelsIndexes[a].length - 1] : 0; if (void 0 !== o.globals.dataLabelsRects[a][g]) { const p = o.globals.dataLabelsRects[a][u]; (t > p.x + p.width + 2 || e > p.y + p.height + 2 || t + c < p.x) && (l = !0); } return (s === 0 || r) && (l = !0), {
        x: t, y: e, textRects: h, drawnextLabel: l,
      };
    },
  }, {
    key: 'drawDataLabel',
    value(t, e, i) {
      const a = this; const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2; const r = this.w; const n = new Graphics(this.ctx); const o = r.config.dataLabels; let l = 0; let h = 0; let c = i; let d = null; if (!o.enabled || t.x instanceof Array != !0) return d; d = n.group({ class: 'apexcharts-data-labels' }); for (let g = 0; g < t.x.length; g++) {
        if (l = t.x[g] + o.offsetX, h = t.y[g] + o.offsetY + s, !isNaN(l)) {
          i === 1 && g === 0 && (c = 0), i === 1 && g === 1 && (c = 1); let u = r.globals.series[e][c]; let p = ''; const f = function (t) {
            return r.config.dataLabels.formatter(t, {
              ctx: a.ctx, seriesIndex: e, dataPointIndex: c, w: r,
            });
          }; if (r.config.chart.type === 'bubble') { p = f(u = r.globals.seriesZ[e][c]), h = t.y[g] + r.config.dataLabels.offsetY; const x = new Scatter(this.ctx); const b = x.centerTextInBubble(h, e, c); h = b.y; } else void 0 !== u && (p = f(u)); this.plotDataLabelsText({
            x: l, y: h, text: p, i: e, j: c, parent: d, offsetCorrection: !0, dataLabelsConfig: r.config.dataLabels,
          });
        }
      } return d;
    },
  }, {
    key: 'plotDataLabelsText',
    value(t) {
      const e = this.w; const i = new Graphics(this.ctx); let a = t.x; let s = t.y; const r = t.i; const n = t.j; let o = t.text; const l = t.textAnchor; const h = t.parent; const c = t.dataLabelsConfig; const d = t.color; const g = t.alwaysDrawDataLabel; const u = t.offsetCorrection; if (!(Array.isArray(e.config.dataLabels.enabledOnSeries) && e.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
        let p = { x: a, y: s, drawnextLabel: !0 }; u && (p = this.dataLabelsCorrection(a, s, o, r, n, g, parseInt(c.style.fontSize, 10))), e.globals.zoomed || (a = p.x, s = p.y), p.textRects && (a + p.textRects.width < 10 || a > e.globals.gridWidth + 10) && (o = ''); let f = e.globals.dataLabels.style.colors[r]; if (e.config.chart.type !== 'bar' && e.config.chart.type !== 'rangeBar' || !e.config.plotOptions.bar.distributed || (f = e.globals.dataLabels.style.colors[n]), d && (f = d), p.drawnextLabel) {
          const x = i.drawText({
            width: 100, height: parseInt(c.style.fontSize, 10), x: a, y: s, foreColor: f, textAnchor: l || c.textAnchor, text: o, fontSize: c.style.fontSize, fontFamily: c.style.fontFamily, fontWeight: c.style.fontWeight || 'normal',
          }); if (x.attr({ class: 'apexcharts-datalabel', cx: a, cy: s }), c.dropShadow.enabled) { const b = c.dropShadow; new Filters(this.ctx).dropShadow(x, b); }h.add(x), void 0 === e.globals.lastDrawnDataLabelsIndexes[r] && (e.globals.lastDrawnDataLabelsIndexes[r] = []), e.globals.lastDrawnDataLabelsIndexes[r].push(n);
        }
      }
    },
  }, { key: 'addBackgroundToDataLabel', value(t, e) { const i = this.w; const a = i.config.dataLabels.background; const s = a.padding; const r = a.padding / 2; const n = e.width; const o = e.height; return new Graphics(this.ctx).drawRect(e.x - s, e.y - r / 2, n + 2 * s, o + r, a.borderRadius, i.config.chart.background === 'transparent' ? '#fff' : i.config.chart.background, a.opacity, a.borderWidth, a.borderColor); } }, { key: 'dataLabelsBackground', value() { const t = this.w; const e = t.config.chart.type; if (e !== 'bar' && e !== 'rangeBar' && e !== 'bubble') for (let i = t.globals.dom.baseEl.querySelectorAll('.apexcharts-datalabels text'), a = 0; a < i.length; a++) { const s = i[a]; const r = s.getBBox(); let n = null; if (r.width && r.height && (n = this.addBackgroundToDataLabel(s, r)), n) { s.parentNode.insertBefore(n.node, s); const o = s.getAttribute('fill'); t.config.chart.animations.enabled && !t.globals.resized && !t.globals.dataChanged ? n.animate().attr({ fill: o }) : n.attr({ fill: o }), s.setAttribute('fill', t.config.dataLabels.background.foreColor); } } } }, { key: 'bringForward', value() { for (let t = this.w, e = t.globals.dom.baseEl.querySelectorAll('.apexcharts-datalabels'), i = t.globals.dom.baseEl.querySelector('.apexcharts-plot-series:last-child'), a = 0; a < e.length; a++)i && i.insertBefore(e[a], i.nextSibling); } }]), t;
}()); const Series = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'getAllSeriesEls', value() { return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series'); } }, { key: 'getSeriesByName', value(t) { return this.w.globals.dom.baseEl.querySelector("[seriesName='".concat(Utils.escapeString(t), "']")); } }, { key: 'isSeriesHidden', value(t) { const e = this.getSeriesByName(t); const i = parseInt(e.getAttribute('data:realIndex'), 10); return { isHidden: e.classList.contains('apexcharts-series-collapsed'), realIndex: i }; } }, { key: 'addCollapsedClassToSeries', value(t, e) { const i = this.w; function a(i) { for (let a = 0; a < i.length; a++)i[a].index === e && t.node.classList.add('apexcharts-series-collapsed'); }a(i.globals.collapsedSeries), a(i.globals.ancillaryCollapsedSeries); } }, { key: 'toggleSeries', value(t) { const e = this.isSeriesHidden(t); return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden; } }, { key: 'showSeries', value(t) { const e = this.isSeriesHidden(t); e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0); } }, { key: 'hideSeries', value(t) { const e = this.isSeriesHidden(t); e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1); } }, { key: 'resetSeries', value() { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; const e = this.w; const i = e.globals.initialSeries.slice(); e.config.series = i, e.globals.collapsedSeries = [], e.globals.ancillaryCollapsedSeries = [], e.globals.collapsedSeriesIndices = [], e.globals.ancillaryCollapsedSeriesIndices = [], e.globals.previousPaths = [], t && this.ctx.updateHelpers._updateSeries(i, e.config.chart.animations.dynamicAnimation.enabled); } }, { key: 'toggleSeriesOnHover', value(t, e) { const i = this.w; const a = i.globals.dom.baseEl.querySelectorAll('.apexcharts-series'); if (t.type === 'mousemove') { const s = parseInt(e.getAttribute('rel'), 10) - 1; let r = null; r = i.globals.axisCharts || i.config.chart.type === 'radialBar' ? i.globals.axisCharts ? i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s, "']")) : i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "']")) : i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "'] path")); for (let n = 0; n < a.length; n++)a[n].classList.add('legend-mouseover-inactive'); r !== null && (i.globals.axisCharts || r.parentNode.classList.remove('legend-mouseover-inactive'), r.classList.remove('legend-mouseover-inactive')); } else if (t.type === 'mouseout') for (let o = 0; o < a.length; o++)a[o].classList.remove('legend-mouseover-inactive'); } }, { key: 'highlightRangeInSeries', value(t, e) { const i = this.w; const a = i.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap-rect'); const s = function () { for (let t = 0; t < a.length; t++)a[t].classList.remove('legend-mouseover-inactive'); }; if (t.type === 'mousemove') { const r = parseInt(e.getAttribute('rel'), 10) - 1; s(), (function () { for (let t = 0; t < a.length; t++)a[t].classList.add('legend-mouseover-inactive'); }()), (function (t) { for (let e = 0; e < a.length; e++) { const i = parseInt(a[e].getAttribute('val'), 10); i >= t.from && i <= t.to && a[e].classList.remove('legend-mouseover-inactive'); } }(i.config.plotOptions.heatmap.colorScale.ranges[r])); } else t.type === 'mouseout' && s(); } }, { key: 'getActiveSeriesIndex', value() { const t = this.w; let e = 0; if (t.globals.series.length > 1) for (let i = t.globals.series.map(((e, i) => (e.length > 0 && t.config.series[i].type !== 'bar' && t.config.series[i].type !== 'column' ? i : -1))), a = 0; a < i.length; a++) if (i[a] !== -1) { e = i[a]; break; } return e; } }, { key: 'getActiveConfigSeriesIndex', value() { const t = this.w; let e = 0; if (t.config.series.length > 1) for (let i = t.config.series.map(((t, e) => (t.data && t.data.length > 0 ? e : -1))), a = 0; a < i.length; a++) if (i[a] !== -1) { e = i[a]; break; } return e; } }, { key: 'getPreviousPaths', value() { const t = this.w; function e(e, i, a) { for (var s = e[i].childNodes, r = { type: a, paths: [], realIndex: e[i].getAttribute('data:realIndex') }, n = 0; n < s.length; n++) if (s[n].hasAttribute('pathTo')) { const o = s[n].getAttribute('pathTo'); r.paths.push({ d: o }); }t.globals.previousPaths.push(r); }t.globals.previousPaths = []; const i = t.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-series'); if (i.length > 0) for (let a = i.length - 1; a >= 0; a--)e(i, a, 'line'); const s = t.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-series'); if (s.length > 0) for (let r = s.length - 1; r >= 0; r--)e(s, r, 'area'); const n = t.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series .apexcharts-series'); if (n.length > 0) for (let o = 0; o < n.length; o++)e(n, o, 'bar'); const l = t.globals.dom.baseEl.querySelectorAll('.apexcharts-candlestick-series .apexcharts-series'); if (l.length > 0) for (let h = 0; h < l.length; h++)e(l, h, 'candlestick'); const c = t.globals.dom.baseEl.querySelectorAll('.apexcharts-radar-series .apexcharts-series'); if (c.length > 0) for (let d = 0; d < c.length; d++)e(c, d, 'radar'); const g = t.globals.dom.baseEl.querySelectorAll('.apexcharts-bubble-series .apexcharts-series'); if (g.length > 0) for (let u = 0; u < g.length; u++) { for (var p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-bubble-series .apexcharts-series[data\\:realIndex='".concat(u, "'] circle")), f = [], x = 0; x < p.length; x++)f.push({ x: p[x].getAttribute('cx'), y: p[x].getAttribute('cy'), r: p[x].getAttribute('r') }); t.globals.previousPaths.push(f); } const b = t.globals.dom.baseEl.querySelectorAll('.apexcharts-scatter-series .apexcharts-series'); if (b.length > 0) for (let m = 0; m < b.length; m++) { for (var v = t.globals.dom.baseEl.querySelectorAll(".apexcharts-scatter-series .apexcharts-series[data\\:realIndex='".concat(m, "'] circle")), y = [], w = 0; w < v.length; w++)y.push({ x: v[w].getAttribute('cx'), y: v[w].getAttribute('cy'), r: v[w].getAttribute('r') }); t.globals.previousPaths.push(y); } const k = t.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap .apexcharts-series'); if (k.length > 0) for (let C = 0; C < k.length; C++) { for (var A = t.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series[data\\:realIndex='".concat(C, "'] rect")), S = [], L = 0; L < A.length; L++)S.push({ color: A[L].getAttribute('color') }); t.globals.previousPaths.push(S); }t.globals.axisCharts || (t.globals.previousPaths = t.globals.series); } }, { key: 'clearPreviousPaths', value() { const t = this.w; t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1, t.globals.collapsedSeries = [], t.globals.collapsedSeriesIndices = []; } }, {
    key: 'handleNoData',
    value() {
      const t = this.w; const e = t.config.noData; const i = new Graphics(this.ctx); let a = t.globals.svgWidth / 2; let s = t.globals.svgHeight / 2; let r = 'middle'; if (t.globals.noData = !0, t.globals.animationEnded = !0, e.align === 'left' ? (a = 10, r = 'start') : e.align === 'right' && (a = t.globals.svgWidth - 10, r = 'end'), e.verticalAlign === 'top' ? s = 50 : e.verticalAlign === 'bottom' && (s = t.globals.svgHeight - 50), a += e.offsetX, s = s + parseInt(e.style.fontSize, 10) + 2 + e.offsetY, void 0 !== e.text && e.text !== '') {
        const n = i.drawText({
          x: a, y: s, text: e.text, textAnchor: r, fontSize: e.style.fontSize, fontFamily: e.style.fontFamily, foreColor: e.style.color, opacity: 1, class: 'apexcharts-text-nodata',
        }); t.globals.dom.Paper.add(n);
      }
    },
  }, { key: 'setNullSeriesToZeroValues', value(t) { for (let e = this.w, i = 0; i < t.length; i++) if (t[i].length === 0) for (let a = 0; a < t[e.globals.maxValsInArrayIndex].length; a++)t[i].push(0); return t; } }, { key: 'hasAllSeriesEqualX', value() { for (var t = !0, e = this.w, i = this.filteredSeriesX(), a = 0; a < i.length - 1; a++) if (i[a][0] !== i[a + 1][0]) { t = !1; break; } return e.globals.allSeriesHasEqualX = t, t; } }, { key: 'filteredSeriesX', value() { const t = this.w.globals.seriesX.map(((t) => (t.length > 0 ? t : []))); return t; } }]), t;
}()); const Data = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.coreUtils = new CoreUtils(this.ctx); } return _createClass(t, [{ key: 'isMultiFormat', value() { return this.isFormatXY() || this.isFormat2DArray(); } }, { key: 'isFormatXY', value() { const t = this.w.config.series.slice(); const e = new Series(this.ctx); if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && t[this.activeSeriesIndex].data[0] !== null && void 0 !== t[this.activeSeriesIndex].data[0].x && t[this.activeSeriesIndex].data[0] !== null) return !0; } }, { key: 'isFormat2DArray', value() { const t = this.w.config.series.slice(); const e = new Series(this.ctx); if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && void 0 !== t[this.activeSeriesIndex].data[0] && t[this.activeSeriesIndex].data[0] !== null && t[this.activeSeriesIndex].data[0].constructor === Array) return !0; } }, { key: 'handleFormat2DArray', value(t, e) { for (var i = this.w.config, a = this.w.globals, s = 0; s < t[e].data.length; s++) if (void 0 !== t[e].data[s][1] && (Array.isArray(t[e].data[s][1]) && t[e].data[s][1].length === 4 ? this.twoDSeries.push(Utils.parseNumber(t[e].data[s][1][3])) : t[e].data[s].length === 5 ? this.twoDSeries.push(Utils.parseNumber(t[e].data[s][4])) : this.twoDSeries.push(Utils.parseNumber(t[e].data[s][1])), a.dataFormatXNumeric = !0), i.xaxis.type === 'datetime') { let r = new Date(t[e].data[s][0]); r = new Date(r).getTime(), this.twoDSeriesX.push(r); } else this.twoDSeriesX.push(t[e].data[s][0]); for (let n = 0; n < t[e].data.length; n++) void 0 !== t[e].data[n][2] && (this.threeDSeries.push(t[e].data[n][2]), a.isDataXYZ = !0); } }, { key: 'handleFormatXY', value(t, e) { const i = this.w.config; const a = this.w.globals; const s = new DateTime(this.ctx); let r = e; a.collapsedSeriesIndices.indexOf(e) > -1 && (r = this.activeSeriesIndex); for (let n = 0; n < t[e].data.length; n++) void 0 !== t[e].data[n].y && (Array.isArray(t[e].data[n].y) ? this.twoDSeries.push(Utils.parseNumber(t[e].data[n].y[t[e].data[n].y.length - 1])) : this.twoDSeries.push(Utils.parseNumber(t[e].data[n].y))); for (let o = 0; o < t[r].data.length; o++) { const l = typeof t[r].data[o].x === 'string'; const h = Array.isArray(t[r].data[o].x); const c = !h && !!s.isValidDate(t[r].data[o].x.toString()); l || c ? l || i.xaxis.convertedCatToNumeric ? i.xaxis.type !== 'datetime' || a.isRangeData ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : this.twoDSeriesX.push(s.parseDate(t[r].data[o].x)) : i.xaxis.type === 'datetime' ? this.twoDSeriesX.push(s.parseDate(t[r].data[o].x.toString())) : (a.dataFormatXNumeric = !0, a.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[r].data[o].x))) : h ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : (a.isXNumeric = !0, a.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[r].data[o].x)); } if (t[e].data[0] && void 0 !== t[e].data[0].z) { for (let d = 0; d < t[e].data.length; d++) this.threeDSeries.push(t[e].data[d].z); a.isDataXYZ = !0; } } }, { key: 'handleRangeData', value(t, e) { const i = this.w.config; const a = this.w.globals; let s = {}; return this.isFormat2DArray() ? s = this.handleRangeDataFormat('array', t, e) : this.isFormatXY() && (s = this.handleRangeDataFormat('xy', t, e)), a.seriesRangeStart.push(s.start), a.seriesRangeEnd.push(s.end), i.xaxis.type === 'datetime' && a.seriesRangeBarTimeline.push(s.rangeUniques), a.seriesRangeBarTimeline.forEach(((t, e) => { t && t.forEach(((t, e) => { t.y.forEach(((e, i) => { for (let a = 0; a < t.y.length; a++) if (i !== a) { const s = e.y1; const r = e.y2; const n = t.y[a].y1; s <= t.y[a].y2 && n <= r && (t.overlaps.indexOf(e.rangeName) < 0 && t.overlaps.push(e.rangeName), t.overlaps.indexOf(t.y[a].rangeName) < 0 && t.overlaps.push(t.y[a].rangeName)); } })); })); })), s; } }, { key: 'handleCandleStickData', value(t, e) { const i = this.w.globals; let a = {}; return this.isFormat2DArray() ? a = this.handleCandleStickDataFormat('array', t, e) : this.isFormatXY() && (a = this.handleCandleStickDataFormat('xy', t, e)), i.seriesCandleO[e] = a.o, i.seriesCandleH[e] = a.h, i.seriesCandleL[e] = a.l, i.seriesCandleC[e] = a.c, a; } }, { key: 'handleRangeDataFormat', value(t, e, i) { const a = []; const s = []; const r = e[i].data.filter(((t, e, i) => e === i.findIndex(((e) => e.x === t.x)))).map(((t, e) => ({ x: t.x, overlaps: [], y: [] }))); const n = 'Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts'; const o = new Series(this.ctx).getActiveConfigSeriesIndex(); if (t === 'array') { if (e[o].data[0][1].length !== 2) throw new Error(n); for (let l = 0; l < e[i].data.length; l++)a.push(e[i].data[l][1][0]), s.push(e[i].data[l][1][1]); } else if (t === 'xy') { if (e[o].data[0].y.length !== 2) throw new Error(n); for (let h = function (t) { const n = Utils.randomId(); const o = e[i].data[t].x; const l = { y1: e[i].data[t].y[0], y2: e[i].data[t].y[1], rangeName: n }; e[i].data[t].rangeName = n; const h = r.findIndex(((t) => t.x === o)); r[h].y.push(l), a.push(l.y1), s.push(l.y2); }, c = 0; c < e[i].data.length; c++)h(c); } return { start: a, end: s, rangeUniques: r }; } }, {
    key: 'handleCandleStickDataFormat',
    value(t, e, i) {
      const a = []; const s = []; const r = []; const n = []; const o = 'Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick'; if (t === 'array') { if (!Array.isArray(e[i].data[0][1]) && e[i].data[0].length !== 5 || Array.isArray(e[i].data[0][1]) && e[i].data[0][1].length !== 4) throw new Error(o); if (e[i].data[0].length === 5) for (let l = 0; l < e[i].data.length; l++)a.push(e[i].data[l][1]), s.push(e[i].data[l][2]), r.push(e[i].data[l][3]), n.push(e[i].data[l][4]); else for (let h = 0; h < e[i].data.length; h++)a.push(e[i].data[h][1][0]), s.push(e[i].data[h][1][1]), r.push(e[i].data[h][1][2]), n.push(e[i].data[h][1][3]); } else if (t === 'xy') { if (e[i].data[0].y.length !== 4) throw new Error(o); for (let c = 0; c < e[i].data.length; c++)a.push(e[i].data[c].y[0]), s.push(e[i].data[c].y[1]), r.push(e[i].data[c].y[2]), n.push(e[i].data[c].y[3]); } return {
        o: a, h: s, l: r, c: n,
      };
    },
  }, { key: 'parseDataAxisCharts', value(t) { for (var e = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a = this.w.config, s = this.w.globals, r = new DateTime(i), n = a.labels.length > 0 ? a.labels.slice() : a.xaxis.categories.slice(), o = function () { for (let t = 0; t < n.length; t++) if (typeof n[t] === 'string') { if (!r.isValidDate(n[t])) throw new Error('You have provided invalid Date format. Please provide a valid JavaScript Date'); e.twoDSeriesX.push(r.parseDate(n[t])); } else { if (String(n[t]).length !== 13) throw new Error('Please provide a valid JavaScript timestamp'); e.twoDSeriesX.push(n[t]); } }, l = 0; l < t.length; l++) { if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t[l].data) return void console.error("It is a possibility that you may have not included 'data' property in series."); if (a.chart.type !== 'rangeBar' && a.chart.type !== 'rangeArea' && t[l].type !== 'rangeBar' && t[l].type !== 'rangeArea' || (s.isRangeData = !0, this.handleRangeData(t, l)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t, l) : this.isFormatXY() && this.handleFormatXY(t, l), a.chart.type !== 'candlestick' && t[l].type !== 'candlestick' || this.handleCandleStickData(t, l), s.series.push(this.twoDSeries), s.labels.push(this.twoDSeriesX), s.seriesX.push(this.twoDSeriesX), l !== this.activeSeriesIndex || this.fallbackToCategory || (s.isXNumeric = !0); else { a.xaxis.type === 'datetime' ? (s.isXNumeric = !0, o(), s.seriesX.push(this.twoDSeriesX)) : a.xaxis.type === 'numeric' && (s.isXNumeric = !0, n.length > 0 && (this.twoDSeriesX = n, s.seriesX.push(this.twoDSeriesX))), s.labels.push(this.twoDSeriesX); const h = t[l].data.map(((t) => Utils.parseNumber(t))); s.series.push(h); }s.seriesZ.push(this.threeDSeries), void 0 !== t[l].name ? s.seriesNames.push(t[l].name) : s.seriesNames.push(`series-${parseInt(l + 1, 10)}`); } return this.w; } }, { key: 'parseDataNonAxisCharts', value(t) { const e = this.w.globals; const i = this.w.config; e.series = t.slice(), e.seriesNames = i.labels.slice(); for (let a = 0; a < e.series.length; a++) void 0 === e.seriesNames[a] && e.seriesNames.push(`series-${a + 1}`); return this.w; } }, { key: 'handleExternalLabelsData', value(t) { const e = this.w.config; const i = this.w.globals; if (e.xaxis.categories.length > 0)i.labels = e.xaxis.categories; else if (e.labels.length > 0)i.labels = e.labels.slice(); else if (this.fallbackToCategory) { if (i.labels = i.labels[0], i.seriesRangeBarTimeline.length && (i.seriesRangeBarTimeline.map(((t) => { t.forEach(((t) => { i.labels.indexOf(t.x) < 0 && t.x && i.labels.push(t.x); })); })), i.labels = i.labels.filter(((t, e, i) => i.indexOf(t) === e))), e.xaxis.convertedCatToNumeric) new Defaults(e).convertCatToNumericXaxis(e, this.ctx, i.seriesX[0]), this._generateExternalLabels(t); } else this._generateExternalLabels(t); } }, { key: '_generateExternalLabels', value(t) { const e = this.w.globals; const i = this.w.config; let a = []; if (e.axisCharts) { if (e.series.length > 0) for (let s = 0; s < e.series[e.maxValsInArrayIndex].length; s++)a.push(s + 1); e.seriesX = []; for (let r = 0; r < t.length; r++)e.seriesX.push(a); e.isXNumeric = !0; } if (a.length === 0) { a = e.axisCharts ? [0, 10] : e.series.map(((t, e) => e + 1)); for (let n = 0; n < t.length; n++)e.seriesX.push(a); }e.labels = a, i.xaxis.convertedCatToNumeric && (e.categoryLabels = a.map(((t) => i.xaxis.labels.formatter(t)))), e.noLabelsProvided = !0; } }, { key: 'parseData', value(t) { const e = this.w; const i = e.config; const a = e.globals; if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a.axisCharts ? this.parseDataAxisCharts(t) : this.parseDataNonAxisCharts(t), this.coreUtils.getLargestSeries(), i.chart.type === 'bar' && i.chart.stacked) { const s = new Series(this.ctx); a.series = s.setNullSeriesToZeroValues(a.series); } this.coreUtils.getSeriesTotals(), a.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), a.dataFormatXNumeric || a.isXNumeric && (i.xaxis.type !== 'numeric' || i.labels.length !== 0 || i.xaxis.categories.length !== 0) || this.handleExternalLabelsData(t); for (let r = this.coreUtils.getCategoryLabels(a.labels), n = 0; n < r.length; n++) if (Array.isArray(r[n])) { a.isMultiLineX = !0; break; } } }, { key: 'excludeCollapsedSeriesInYAxis', value() { const t = this; const e = this.w; e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map(((e, i) => { if (t.w.globals.isMultipleYAxis) return e.index; })); } }]), t;
}()); const Formatters = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.tooltipKeyFormat = 'dd MMM'; } return _createClass(t, [{ key: 'xLabelFormat', value(t, e, i) { const a = this.w; if (a.config.xaxis.type === 'datetime' && void 0 === a.config.xaxis.labels.formatter && void 0 === a.config.tooltip.x.formatter) { const s = new DateTime(this.ctx); return s.formatDate(s.getDate(e), a.config.tooltip.x.format); } return t(e, i); } }, { key: 'defaultGeneralFormatter', value(t) { return Array.isArray(t) ? t.map(((t) => t)) : t; } }, { key: 'defaultYFormatter', value(t, e, i) { const a = this.w; return Utils.isNumber(t) && (t = a.globals.yValueDecimal !== 0 ? t.toFixed(void 0 !== e.decimalsInFloat ? e.decimalsInFloat : a.globals.yValueDecimal) : a.globals.maxYArr[i] - a.globals.minYArr[i] < 10 ? t.toFixed(1) : t.toFixed(0)), t; } }, { key: 'setLabelFormatters', value() { const t = this; const e = this.w; return e.globals.xLabelFormatter = function (e) { return t.defaultGeneralFormatter(e); }, e.globals.xaxisTooltipFormatter = function (e) { return t.defaultGeneralFormatter(e); }, e.globals.ttKeyFormatter = function (e) { return t.defaultGeneralFormatter(e); }, e.globals.ttZFormatter = function (t) { return t; }, e.globals.legendFormatter = function (e) { return t.defaultGeneralFormatter(e); }, void 0 !== e.config.xaxis.labels.formatter ? e.globals.xLabelFormatter = e.config.xaxis.labels.formatter : e.globals.xLabelFormatter = function (t) { if (Utils.isNumber(t)) { if (!e.config.xaxis.convertedCatToNumeric && e.config.xaxis.type === 'numeric' && e.globals.dataPoints < 50) return t.toFixed(1); if (e.globals.isBarHorizontal) if (e.globals.maxY - e.globals.minYArr < 4) return t.toFixed(1); return t.toFixed(0); } return t; }, typeof e.config.tooltip.x.formatter === 'function' ? e.globals.ttKeyFormatter = e.config.tooltip.x.formatter : e.globals.ttKeyFormatter = e.globals.xLabelFormatter, typeof e.config.xaxis.tooltip.formatter === 'function' && (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter), Array.isArray(e.config.tooltip.y) ? e.globals.ttVal = e.config.tooltip.y : void 0 !== e.config.tooltip.y.formatter && (e.globals.ttVal = e.config.tooltip.y), void 0 !== e.config.tooltip.z.formatter && (e.globals.ttZFormatter = e.config.tooltip.z.formatter), void 0 !== e.config.legend.formatter && (e.globals.legendFormatter = e.config.legend.formatter), e.config.yaxis.forEach(((i, a) => { void 0 !== i.labels.formatter ? e.globals.yLabelFormatters[a] = i.labels.formatter : e.globals.yLabelFormatters[a] = function (s) { return e.globals.xyCharts ? Array.isArray(s) ? s.map(((e) => t.defaultYFormatter(e, i, a))) : t.defaultYFormatter(s, i, a) : s; }; })), e.globals; } }, { key: 'heatmapLabelFormatters', value() { const t = this.w; if (t.config.chart.type === 'heatmap') { t.globals.yAxisScale[0].result = t.globals.seriesNames.slice(); const e = t.globals.seriesNames.reduce(((t, e) => (t.length > e.length ? t : e)), 0); t.globals.yAxisScale[0].niceMax = e, t.globals.yAxisScale[0].niceMin = e; } } }]), t; }()); const AxesUtils = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{
    key: 'getLabel',
    value(t, e, i, a) {
      const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : []; const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : '12px'; const n = this.w; const o = void 0 === t[a] ? '' : t[a]; let l = o; const h = n.globals.xLabelFormatter; const c = n.config.xaxis.labels.formatter; let d = !1; const g = new Formatters(this.ctx); const u = o; l = g.xLabelFormat(h, o, u), void 0 !== c && (l = c(o, t[a], a)); const p = function (t) { let i = null; return e.forEach(((t) => { t.unit === 'month' ? i = 'year' : t.unit === 'day' ? i = 'month' : t.unit === 'hour' ? i = 'day' : t.unit === 'minute' && (i = 'hour'); })), i === t; }; e.length > 0 ? (d = p(e[a].unit), i = e[a].position, l = e[a].value) : n.config.xaxis.type === 'datetime' && void 0 === c && (l = ''), void 0 === l && (l = ''), l = Array.isArray(l) ? l : l.toString(); const f = new Graphics(this.ctx); let x = {}; return x = n.globals.rotateXLabels ? f.getTextRects(l, parseInt(r, 10), null, 'rotate('.concat(n.config.xaxis.labels.rotate, ' 0 0)'), !1) : f.getTextRects(l, parseInt(r, 10)), !Array.isArray(l) && (l.indexOf('NaN') === 0 || l.toLowerCase().indexOf('invalid') === 0 || l.toLowerCase().indexOf('infinity') >= 0 || s.indexOf(l) >= 0 && !n.config.xaxis.labels.showDuplicates) && (l = ''), {
        x: i, text: l, textRect: x, isBold: d,
      };
    },
  }, { key: 'checkForOverflowingLabels', value(t, e, i, a, s) { const r = this.w; if (t === 0 && r.globals.skipFirstTimelinelabel && (e.text = ''), t === i - 1 && r.globals.skipLastTimelinelabel && (e.text = ''), r.config.xaxis.labels.hideOverlappingLabels && a.length > 0) { const n = s[s.length - 1]; e.x < n.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 12 : 1.1) + n.x && (e.text = ''); } return e; } }, { key: 'checkForReversedLabels', value(t, e) { const i = this.w; return i.config.yaxis[t] && i.config.yaxis[t].reversed && e.reverse(), e; } }, { key: 'drawYAxisTicks', value(t, e, i, a, s, r, n) { const o = this.w; const l = new Graphics(this.ctx); let h = o.globals.translateY; if (a.show && e > 0) { !0 === o.config.yaxis[s].opposite && (t += a.width); for (let c = e; c >= 0; c--) { let d = h + e / 10 + o.config.yaxis[s].labels.offsetY - 1; o.globals.isBarHorizontal && (d = r * c), o.config.chart.type === 'heatmap' && (d += r / 2); const g = l.drawLine(t + i.offsetX - a.width + a.offsetX, d + a.offsetY, t + i.offsetX + a.offsetX, d + a.offsetY, a.color); n.add(g), h += r; } } } }]), t;
}()); const Exports = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'getSvgString', value() { return this.w.globals.dom.Paper.svg(); } }, { key: 'cleanup', value() { const t = this.w; const e = t.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs'); const i = t.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs'); e && (e.setAttribute('x', -500), e.setAttribute('x1', -500), e.setAttribute('x2', -500)), i && (i.setAttribute('y', -100), i.setAttribute('y1', -100), i.setAttribute('y2', -100)); } }, { key: 'svgUrl', value() { this.cleanup(); const t = this.getSvgString(); const e = new Blob([t], { type: 'image/svg+xml;charset=utf-8' }); return URL.createObjectURL(e); } }, { key: 'dataURI', value() { const t = this; return new Promise((((e) => { const i = t.w; t.cleanup(); const a = document.createElement('canvas'); a.width = i.globals.svgWidth, a.height = parseInt(i.globals.dom.elWrap.style.height, 10); const s = i.config.chart.background === 'transparent' ? '#fff' : i.config.chart.background; const r = a.getContext('2d'); r.fillStyle = s, r.fillRect(0, 0, a.width, a.height); const n = window.URL || window.webkitURL || window; const o = new Image(); o.crossOrigin = 'anonymous'; const l = t.getSvgString(); const h = `data:image/svg+xml,${encodeURIComponent(l)}`; o.onload = function () { r.drawImage(o, 0, 0), n.revokeObjectURL(h); const t = a.toDataURL('image/png'); e(t); }, o.src = h; }))); } }, { key: 'exportToSVG', value() { this.triggerDownload(this.svgUrl(), '.svg'); } }, { key: 'exportToPng', value() { const t = this; this.dataURI().then(((e) => { t.triggerDownload(e, '.png'); })); } }, { key: 'exportToCSV', value(t) { const e = this; const i = t.series; const a = t.columnDelimiter; const s = void 0 === a ? ',' : a; const r = t.lineDelimiter; const n = void 0 === r ? '\n' : r; const o = this.w; let l = []; const h = []; let c = 'data:text/csv;charset=utf-8,'; const d = new Data(this.ctx); const g = new AxesUtils(this.ctx); const u = function (t) { let i = ''; if (o.globals.axisCharts) { if (o.config.xaxis.type === 'category' || o.config.xaxis.convertedCatToNumeric) if (o.globals.isBarHorizontal) { const a = o.globals.yLabelFormatters[0]; const s = new Series(e.ctx).getActiveSeriesIndex(); i = a(o.globals.labels[t], { seriesIndex: s, dataPointIndex: t, w: o }); } else i = g.getLabel(o.globals.labels, o.globals.timescaleLabels, 0, t).text; o.config.xaxis.type === 'datetime' && (o.config.xaxis.categories.length ? i = o.config.xaxis.categories[t] : o.config.labels.length && (i = o.config.labels[t])); } else i = o.config.labels[t]; return i; }; i.map(((t, e) => { o.globals.axisCharts ? (function (t, e) { if (h.push(t.name), (l = []).push('x'), l.push('y'), h.push(l.join(s)), t.data && t.data.length) for (let a = 0; a < t.data.length; a++) { l = []; let r = u(a); r || (d.isFormatXY() ? r = i[e].data[a].x : d.isFormat2DArray() && (r = i[e].data[a] ? i[e].data[a][0] : '')), l.push(r), l.push(o.globals.series[e][a]), (o.config.chart.type === 'candlestick' || t.type && t.type === 'candlestick') && (l.pop(), l.push(o.globals.seriesCandleO[e][a]), l.push(o.globals.seriesCandleH[e][a]), l.push(o.globals.seriesCandleL[e][a]), l.push(o.globals.seriesCandleC[e][a])), o.config.chart.type === 'rangeBar' && (l.pop(), l.push(o.globals.seriesRangeStart[e][a]), l.push(o.globals.seriesRangeEnd[e][a])), h.push(l.join(s)); } }(t, e)) : ((l = []).push(o.globals.labels[e]), l.push(o.globals.series[e]), h.push(l.join(s))); })), c += h.join(n), this.triggerDownload(encodeURI(c), '.csv'); } }, { key: 'triggerDownload', value(t, e) { const i = document.createElement('a'); i.href = t, i.download = this.w.globals.chartID + e, document.body.appendChild(i), i.click(), document.body.removeChild(i); } }]), t; }()); const XAxis = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; const i = this.w; this.axesUtils = new AxesUtils(e), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), this.drawnLabels = [], this.drawnLabelsRects = [], i.config.xaxis.position === 'top' ? this.offY = 0 : this.offY = i.globals.gridHeight + 1, this.offY += i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = i.config.chart.type === 'bar' && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf('%') > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0]; } return _createClass(t, [{
    key: 'drawXaxis',
    value() {
      let t; const e = this; const i = this.w; const a = new Graphics(this.ctx); const s = a.group({ class: 'apexcharts-xaxis', transform: 'translate('.concat(i.config.xaxis.offsetX, ', ').concat(i.config.xaxis.offsetY, ')') }); const r = a.group({ class: 'apexcharts-xaxis-texts-g', transform: 'translate('.concat(i.globals.translateXAxisX, ', ').concat(i.globals.translateXAxisY, ')') }); s.add(r); for (var n = i.globals.padHorizontal, o = [], l = 0; l < this.xaxisLabels.length; l++)o.push(this.xaxisLabels[l]); if (i.globals.isXNumeric) { const h = o.length > 1 ? o.length - 1 : o.length; t = i.globals.gridWidth / h, n = n + t / 2 + i.config.xaxis.labels.offsetX; } else t = i.globals.gridWidth / o.length, n = n + t + i.config.xaxis.labels.offsetX; const c = o.length; if (i.config.xaxis.labels.show) {
        for (let d = function (s) {
            let l = n - t / 2 + i.config.xaxis.labels.offsetX; s === 0 && c === 1 && t / 2 === n && i.globals.dataPoints === 1 && (l = i.globals.gridWidth / 2); let h = e.axesUtils.getLabel(o, i.globals.timescaleLabels, l, s, e.drawnLabels, e.xaxisFontSize); let d = 28; i.globals.rotateXLabels && (d = 22), h = e.axesUtils.checkForOverflowingLabels(s, h, c, e.drawnLabels, e.drawnLabelsRects); const g = a.drawText({
              x: h.x, y: e.offY + i.config.xaxis.labels.offsetY + d, text: h.text, textAnchor: 'middle', fontWeight: h.isBold ? 600 : 400, fontSize: e.xaxisFontSize, fontFamily: e.xaxisFontFamily, foreColor: Array.isArray(e.xaxisForeColors) ? i.config.xaxis.convertedCatToNumeric ? e.xaxisForeColors[i.globals.minX + s - 1] : e.xaxisForeColors[s] : e.xaxisForeColors, isPlainText: !1, cssClass: `apexcharts-xaxis-label ${i.config.xaxis.labels.style.cssClass}`,
            }); r.add(g); const u = document.createElementNS(i.globals.SVGNS, 'title'); u.textContent = h.text, g.node.appendChild(u), h.text !== '' && (e.drawnLabels.push(h.text), e.drawnLabelsRects.push(h)), n += t;
          }, g = 0; g <= c - 1; g++)d(g);
      } if (void 0 !== i.config.xaxis.title.text) {
        const u = a.group({ class: 'apexcharts-xaxis-title' }); const p = a.drawText({
          x: i.globals.gridWidth / 2 + i.config.xaxis.title.offsetX, y: this.offY - parseFloat(this.xaxisFontSize) + i.globals.xAxisLabelsHeight + i.config.xaxis.title.offsetY, text: i.config.xaxis.title.text, textAnchor: 'middle', fontSize: i.config.xaxis.title.style.fontSize, fontFamily: i.config.xaxis.title.style.fontFamily, foreColor: i.config.xaxis.title.style.color, cssClass: `apexcharts-xaxis-title-text ${i.config.xaxis.title.style.cssClass}`,
        }); u.add(p), s.add(u);
      } if (i.config.xaxis.axisBorder.show) { let f = 0; i.config.chart.type === 'bar' && i.globals.isXNumeric && (f -= 15); const x = a.drawLine(i.globals.padHorizontal + f + i.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, i.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight); s.add(x); } return s;
    },
  }, {
    key: 'drawXaxisInversed',
    value(t) {
      let e; let i; const a = this.w; const s = new Graphics(this.ctx); const r = a.config.yaxis[0].opposite ? a.globals.translateYAxisX[t] : 0; const n = s.group({ class: 'apexcharts-yaxis apexcharts-xaxis-inversed', rel: t }); const o = s.group({ class: 'apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g', transform: `translate(${r}, 0)` }); n.add(o); const l = []; if (a.config.yaxis[t].show) for (let h = 0; h < this.xaxisLabels.length; h++)l.push(this.xaxisLabels[h]); i = -(e = a.globals.gridHeight / l.length) / 2.2; const c = a.globals.yLabelFormatters[0]; const d = a.config.yaxis[0].labels; if (d.show) {
        for (let g = 0; g <= l.length - 1; g++) {
          let u = void 0 === l[g] ? '' : l[g]; u = c(u, { seriesIndex: t, dataPointIndex: g, w: a }); let p = 0; Array.isArray(u) && (p = u.length / 2 * parseInt(d.style.fontSize, 10)); const f = s.drawText({
            x: d.offsetX - 15, y: i + e + d.offsetY - p, text: u, textAnchor: this.yaxis.opposite ? 'start' : 'end', foreColor: d.style.color ? d.style.color : d.style.colors[g], fontSize: d.style.fontSize, fontFamily: d.style.fontFamily, isPlainText: !1, cssClass: `apexcharts-yaxis-label ${d.style.cssClass}`,
          }); o.add(f); const x = document.createElementNS(a.globals.SVGNS, 'title'); if (x.textContent = u.text, f.node.appendChild(x), a.config.yaxis[t].labels.rotate !== 0) { const b = s.rotateAroundCenter(f.node); f.node.setAttribute('transform', 'rotate('.concat(a.config.yaxis[t].labels.rotate, ' 0 ').concat(b.y, ')')); }i += e;
        }
      } if (void 0 !== a.config.yaxis[0].title.text) {
        const m = s.group({ class: 'apexcharts-yaxis-title apexcharts-xaxis-title-inversed', transform: `translate(${r}, 0)` }); const v = s.drawText({
          x: 0, y: a.globals.gridHeight / 2, text: a.config.yaxis[0].title.text, textAnchor: 'middle', foreColor: a.config.yaxis[0].title.style.color, fontSize: a.config.yaxis[0].title.style.fontSize, fontFamily: a.config.yaxis[0].title.style.fontFamily, cssClass: `apexcharts-yaxis-title-text ${a.config.yaxis[0].title.style.cssClass}`,
        }); m.add(v), n.add(m);
      } let y = 0; this.isCategoryBarHorizontal && a.config.yaxis[0].opposite && (y = a.globals.gridWidth); const w = a.config.xaxis.axisBorder; if (w.show) { const k = s.drawLine(a.globals.padHorizontal + w.offsetX + y, 1 + w.offsetY, a.globals.padHorizontal + w.offsetX + y, a.globals.gridHeight + w.offsetY, w.color, 0); n.add(k); } return a.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(y, l.length, a.config.yaxis[0].axisBorder, a.config.yaxis[0].axisTicks, 0, e, n), n;
    },
  }, { key: 'drawXaxisTicks', value(t, e) { const i = this.w; const a = t; if (!(t < 0 || t - 2 > i.globals.gridWidth)) { const s = this.offY + i.config.xaxis.axisTicks.offsetY; const r = s + i.config.xaxis.axisTicks.height; if (i.config.xaxis.axisTicks.show) { const n = new Graphics(this.ctx).drawLine(t + i.config.xaxis.axisTicks.offsetX, s + i.config.xaxis.offsetY, a + i.config.xaxis.axisTicks.offsetX, r + i.config.xaxis.offsetY, i.config.xaxis.axisTicks.color); e.add(n), n.node.classList.add('apexcharts-xaxis-tick'); } } } }, { key: 'getXAxisTicksPositions', value() { const t = this.w; const e = []; const i = this.xaxisLabels.length; let a = t.globals.padHorizontal; if (t.globals.timescaleLabels.length > 0) for (let s = 0; s < i; s++)a = this.xaxisLabels[s].position, e.push(a); else for (let r = i, n = 0; n < r; n++) { let o = r; t.globals.isXNumeric && t.config.chart.type !== 'bar' && (o -= 1), a += t.globals.gridWidth / o, e.push(a); } return e; } }, { key: 'xAxisLabelCorrections', value() { const t = this.w; const e = new Graphics(this.ctx); const i = t.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g'); const a = t.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-texts-g text'); const s = t.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-inversed text'); const r = t.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-inversed-texts-g text tspan'); if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways) for (let n = 0; n < a.length; n++) { const o = e.rotateAroundCenter(a[n]); o.y -= 1, o.x += 1, a[n].setAttribute('transform', 'rotate('.concat(t.config.xaxis.labels.rotate, ' ').concat(o.x, ' ').concat(o.y, ')')), a[n].setAttribute('text-anchor', 'end'); i.setAttribute('transform', 'translate(0, '.concat(-10, ')')); const l = a[n].childNodes; t.config.xaxis.labels.trim && Array.prototype.forEach.call(l, ((i) => { e.placeTextWithEllipsis(i, i.textContent, t.config.xaxis.labels.maxHeight - (t.config.legend.position === 'bottom' ? 20 : 10)); })); } else !(function () { for (var i = t.globals.gridWidth / (t.globals.labels.length + 1), s = 0; s < a.length; s++) { const r = a[s].childNodes; t.config.xaxis.labels.trim && t.config.xaxis.type !== 'datetime' && Array.prototype.forEach.call(r, ((t) => { e.placeTextWithEllipsis(t, t.textContent, i); })); } }()); if (s.length > 0) { const h = s[s.length - 1].getBBox(); const c = s[0].getBBox(); h.x < -20 && s[s.length - 1].parentNode.removeChild(s[s.length - 1]), c.x + c.width > t.globals.gridWidth && !t.globals.isBarHorizontal && s[0].parentNode.removeChild(s[0]); for (let d = 0; d < r.length; d++)e.placeTextWithEllipsis(r[d], r[d].textContent, t.config.yaxis[0].labels.maxWidth - 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) - 20); } } }]), t;
}()); const Grid = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; const i = this.w; this.xaxisLabels = i.globals.labels.slice(), this.axesUtils = new AxesUtils(e), this.isTimelineBar = i.config.xaxis.type === 'datetime' && i.globals.seriesRangeBarTimeline.length, i.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i.globals.timescaleLabels.slice()); } return _createClass(t, [{ key: 'drawGridArea', value() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; const e = this.w; const i = new Graphics(this.ctx); t === null && (t = i.group({ class: 'apexcharts-grid' })); const a = i.drawLine(e.globals.padHorizontal, 1, e.globals.padHorizontal, e.globals.gridHeight, 'transparent'); const s = i.drawLine(e.globals.padHorizontal, e.globals.gridHeight, e.globals.gridWidth, e.globals.gridHeight, 'transparent'); return t.add(s), t.add(a), t; } }, { key: 'drawGrid', value() { const t = this.w.globals; let e = null; return t.axisCharts && (e = this.renderGrid(), t.dom.elGraphical.add(e.el), this.drawGridArea(e.el)), e; } }, { key: 'createGridMask', value() { const t = this.w; const e = t.globals; const i = new Graphics(this.ctx); let a = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width; if (Array.isArray(t.config.stroke.width)) { let s = 0; t.config.stroke.width.forEach(((t) => { s = Math.max(s, t); })), a = s; }e.dom.elGridRectMask = document.createElementNS(e.SVGNS, 'clipPath'), e.dom.elGridRectMask.setAttribute('id', 'gridRectMask'.concat(e.cuid)), e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, 'clipPath'), e.dom.elGridRectMarkerMask.setAttribute('id', 'gridRectMarkerMask'.concat(e.cuid)); const r = t.config.chart.type; let n = 0; let o = 0; (r === 'bar' || r === 'rangeBar' || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (n = t.config.grid.padding.left, o = t.config.grid.padding.right, e.barPadForNumericAxis > n && (n = e.barPadForNumericAxis, o = e.barPadForNumericAxis)), e.dom.elGridRect = i.drawRect(-a / 2 - n - 2, -a / 2, e.gridWidth + a + o + n + 4, e.gridHeight + a, 0, '#fff'), new CoreUtils(this).getLargestMarkerSize(); const l = t.globals.markers.largestSize + 1; e.dom.elGridRectMarker = i.drawRect(-l, -l, e.gridWidth + 2 * l, e.gridHeight + 2 * l, 0, '#fff'), e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node), e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node); const h = e.dom.baseEl.querySelector('defs'); h.appendChild(e.dom.elGridRectMask), h.appendChild(e.dom.elGridRectMarkerMask); } }, {
    key: '_drawGridLines',
    value(t) {
      const e = t.i; const i = t.x1; const a = t.y1; const s = t.x2; const r = t.y2; const n = t.xCount; const o = t.parent; const l = this.w; e === 0 && l.globals.skipFirstTimelinelabel || e === n - 1 && l.globals.skipLastTimelinelabel || l.config.chart.type === 'radar' || (l.config.grid.xaxis.lines.show && this._drawGridLine({
        x1: i, y1: a, x2: s, y2: r, parent: o,
      }), new XAxis(this.ctx).drawXaxisTicks(i, this.elg));
    },
  }, { key: '_drawGridLine', value(t) { const e = t.x1; const i = t.y1; const a = t.x2; const s = t.y2; const r = t.parent; const n = this.w; const o = n.config.grid.strokeDashArray; const l = new Graphics(this).drawLine(e, i, a, s, n.config.grid.borderColor, o); l.node.classList.add('apexcharts-gridline'), r.add(l); } }, { key: '_drawGridBandRect', value(t) { const e = t.c; const i = t.x1; const a = t.y1; const s = t.x2; const r = t.y2; const n = t.type; const o = this.w; const l = new Graphics(this.ctx); if (n !== 'column' || o.config.xaxis.type !== 'datetime') { const h = o.config.grid[n].colors[e]; const c = l.drawRect(i, a, s, r, 0, h, o.config.grid[n].opacity); this.elg.add(c), c.node.classList.add('apexcharts-grid-'.concat(n)); } } }, {
    key: '_drawXYLines',
    value(t) {
      const e = this; let i = t.xCount; const a = t.tickAmount; const s = this.w; if (s.config.grid.xaxis.lines.show || s.config.xaxis.axisTicks.show) {
        const r = s.globals.padHorizontal; const n = s.globals.gridHeight; s.globals.timescaleLabels.length ? (function (t) {
          for (let a = t.xC, s = t.x1, r = t.y1, n = t.x2, o = t.y2, l = 0; l < a; l++) {
            s = e.xaxisLabels[l].position, n = e.xaxisLabels[l].position, e._drawGridLines({
              i: l, x1: s, y1: r, x2: n, y2: o, xCount: i, parent: e.elgridLinesV,
            });
          }
        }({
          xC: i, x1: r, y1: 0, x2: void 0, y2: n,
        })) : (s.globals.isXNumeric && (i = s.globals.xAxisScale.result.length), (function (t) {
          for (let a = t.xC, r = t.x1, n = t.y1, o = t.x2, l = t.y2, h = 0; h < a + (s.globals.isXNumeric ? 0 : 1); h++) {
            h === 0 && a === 1 && s.globals.dataPoints === 1 && (r = s.globals.gridWidth / 2), e._drawGridLines({
              i: h, x1: r, y1: n, x2: o, y2: l, xCount: i, parent: e.elgridLinesV,
            }), o = r += s.globals.gridWidth / (s.globals.isXNumeric ? a - 1 : a);
          }
        }({
          xC: i, x1: r, y1: 0, x2: void 0, y2: n,
        })));
      } if (s.config.grid.yaxis.lines.show) {
        let o = 0; let l = 0; const h = s.globals.gridWidth; let c = a + 1; this.isTimelineBar && (c = s.globals.labels.length); for (let d = 0; d < c + (this.isTimelineBar ? 1 : 0); d++) {
          this._drawGridLine({
            x1: 0, y1: o, x2: h, y2: l, parent: this.elgridLinesH,
          }), l = o += s.globals.gridHeight / (this.isTimelineBar ? c : a);
        }
      }
    },
  }, {
    key: '_drawInvertedXYLines',
    value(t) {
      const e = t.xCount; const i = this.w; if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) {
        for (var a, s = i.globals.padHorizontal, r = i.globals.gridHeight, n = 0; n < e + 1; n++) {
          i.config.grid.xaxis.lines.show && this._drawGridLine({
            x1: s, y1: 0, x2: a, y2: r, parent: this.elgridLinesV,
          }), new XAxis(this.ctx).drawXaxisTicks(s, this.elg), a = s = s + i.globals.gridWidth / e + 0.3;
        }
      } if (i.config.grid.yaxis.lines.show) {
        for (let o = 0, l = 0, h = i.globals.gridWidth, c = 0; c < i.globals.dataPoints + 1; c++) {
          this._drawGridLine({
            x1: 0, y1: o, x2: h, y2: l, parent: this.elgridLinesH,
          }), l = o += i.globals.gridHeight / i.globals.dataPoints;
        }
      }
    },
  }, { key: 'renderGrid', value() { const t = this.w; const e = new Graphics(this.ctx); this.elg = e.group({ class: 'apexcharts-grid' }), this.elgridLinesH = e.group({ class: 'apexcharts-gridlines-horizontal' }), this.elgridLinesV = e.group({ class: 'apexcharts-gridlines-vertical' }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide()); for (var i, a = 8, s = 0; s < t.globals.series.length && (void 0 !== t.globals.yAxisScale[s] && (a = t.globals.yAxisScale[s].result.length - 1), !(a > 2)); s++);return !t.globals.isBarHorizontal || this.isTimelineBar ? (i = this.xaxisLabels.length, this.isTimelineBar && (a = t.globals.labels.length), this._drawXYLines({ xCount: i, tickAmount: a })) : (i = a, this._drawInvertedXYLines({ xCount: i, tickAmount: a })), this.drawGridBands(i, a), { el: this.elg, xAxisTickWidth: t.globals.gridWidth / i }; } }, {
    key: 'drawGridBands',
    value(t, e) {
      const i = this.w; if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0) {
        for (let a = 0, s = i.globals.gridHeight / e, r = i.globals.gridWidth, n = 0, o = 0; n < e; n++, o++) {
          o >= i.config.grid.row.colors.length && (o = 0), this._drawGridBandRect({
            c: o, x1: 0, y1: a, x2: r, y2: s, type: 'row',
          }), a += i.globals.gridHeight / e;
        }
      } if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0) {
        for (let l = i.config.xaxis.type === 'category' || i.config.xaxis.convertedCatToNumeric ? t - 1 : t, h = i.globals.padHorizontal, c = i.globals.padHorizontal + i.globals.gridWidth / l, d = i.globals.gridHeight, g = 0, u = 0; g < t; g++, u++) {
          u >= i.config.grid.column.colors.length && (u = 0), this._drawGridBandRect({
            c: u, x1: h, y1: 0, x2: c, y2: d, type: 'column',
          }), h += i.globals.gridWidth / l;
        }
      }
    },
  }]), t;
}()); const Range = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'niceScale', value(t, e, i) { const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0; let s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 10; const r = arguments.length > 5 ? arguments[5] : void 0; const n = this.w; if (s === 'dataPoints' && (s = n.globals.dataPoints - 1), t === Number.MIN_VALUE && e === 0 || !Utils.isNumber(t) && !Utils.isNumber(e) || t === Number.MIN_VALUE && e === -Number.MAX_VALUE) { t = 0, e = s; const o = this.linearScale(t, e, s); return o; }t > e ? (console.warn('axis.min cannot be greater than axis.max'), e = t + 0.1) : t === e && (t = t === 0 ? 0 : t - 0.5, e = e === 0 ? 2 : e + 0.5); let l = []; const h = Math.abs(e - t); h < 1 && r && (n.config.chart.type === 'candlestick' || n.config.series[a].type === 'candlestick' || n.globals.isRangeData) && (e *= 1.01); let c = s + 1; c < 2 ? c = 2 : c > 2 && (c -= 2); const d = h / c; const g = Math.floor(Utils.log10(d)); const u = Math.pow(10, g); let p = Math.round(d / u); p < 1 && (p = 1); const f = p * u; const x = f * Math.floor(t / f); const b = f * Math.ceil(e / f); let m = x; if (r && h > 2) { for (;l.push(m), !((m += f) > b););return { result: l, niceMin: l[0], niceMax: l[l.length - 1] }; } let v = t; (l = []).push(v); for (let y = Math.abs(e - t) / s, w = 0; w <= s; w++)v += y, l.push(v); return l[l.length - 1] >= e && l.pop(), { result: l, niceMin: l[0], niceMax: l[l.length - 1] }; } }, { key: 'linearScale', value(t, e) { let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10; const a = Math.abs(e - t); let s = a / i; i === Number.MAX_VALUE && (i = 10, s = 1); for (var r = [], n = t; i >= 0;)r.push(n), n += s, i -= 1; return { result: r, niceMin: r[0], niceMax: r[r.length - 1] }; } }, { key: 'logarithmicScale', value(t, e, i, a) { (e < 0 || e === Number.MIN_VALUE) && (e = 0.01); for (var s = Math.log(e) / Math.log(10), r = Math.log(i) / Math.log(10), n = Math.abs(i - e) / a, o = [], l = e; a >= 0;)o.push(l), l += n, a -= 1; const h = o.map(((t, a) => { t <= 0 && (t = 0.01); const n = (r - s) / (i - e); const o = Math.pow(10, s + n * (t - s)); return Math.round(o / Utils.roundToBase(o, 10)) * Utils.roundToBase(o, 10); })); return h[0] === 0 && (h[0] = 1), { result: h, niceMin: h[0], niceMax: h[h.length - 1] }; } }, { key: 'setYScaleForIndex', value(t, e, i) { const a = this.w.globals; const s = this.w.config; const r = a.isBarHorizontal ? s.xaxis : s.yaxis[t]; void 0 === a.yAxisScale[t] && (a.yAxisScale[t] = []); const n = Math.abs(i - e); if (r.logarithmic && n <= 5 && (a.invalidLogScale = !0), r.logarithmic && n > 5)a.allSeriesCollapsed = !1, a.yAxisScale[t] = this.logarithmicScale(t, e, i, r.tickAmount ? r.tickAmount : Math.floor(Math.log10(i))); else if (i !== -Number.MAX_VALUE && Utils.isNumber(i)) if (a.allSeriesCollapsed = !1, void 0 === r.min && void 0 === r.max || r.forceNiceScale) { const o = void 0 === s.yaxis[t].max && void 0 === s.yaxis[t].min || s.yaxis[t].forceNiceScale; a.yAxisScale[t] = this.niceScale(e, i, n, t, r.tickAmount ? r.tickAmount : n < 5 && n > 1 ? n + 1 : 5, o); } else a.yAxisScale[t] = this.linearScale(e, i, r.tickAmount); else a.yAxisScale[t] = this.linearScale(0, 5, 5); } }, { key: 'setXScale', value(t, e) { const i = this.w; const a = i.globals; const s = i.config.xaxis; const r = Math.abs(e - t); return e !== -Number.MAX_VALUE && Utils.isNumber(e) ? a.xAxisScale = this.niceScale(t, e, r, 0, s.tickAmount ? s.tickAmount : r < 5 && r > 1 ? r + 1 : 5) : a.xAxisScale = this.linearScale(0, 5, 5), a.xAxisScale; } }, { key: 'setMultipleYScales', value() { const t = this; const e = this.w.globals; const i = this.w.config; const a = e.minYArr.concat([]); const s = e.maxYArr.concat([]); const r = []; i.yaxis.forEach(((n, o) => { let l = o; i.series.forEach(((t, i) => { t.name === n.seriesName && e.collapsedSeriesIndices.indexOf(i) === -1 && (l = i, o !== i ? r.push({ index: i, similarIndex: o, alreadyExists: !0 }) : r.push({ index: i })); })); const h = a[l]; const c = s[l]; t.setYScaleForIndex(o, h, c); })), this.sameScaleInMultipleAxes(a, s, r); } }, { key: 'sameScaleInMultipleAxes', value(t, e, i) { const a = this; const s = this.w.config; const r = this.w.globals; let n = []; i.forEach(((t) => { t.alreadyExists && (void 0 === n[t.index] && (n[t.index] = []), n[t.index].push(t.index), n[t.index].push(t.similarIndex)); })), r.yAxisSameScaleIndices = n, n.forEach(((t, e) => { n.forEach(((i, a) => { let s; let r; e !== a && (s = t, r = i, s.filter(((t) => r.indexOf(t) !== -1))).length > 0 && (n[e] = n[e].concat(n[a])); })); })); const o = n.map(((t) => t.filter(((e, i) => t.indexOf(e) === i)))).map(((t) => t.sort())); n = n.filter(((t) => !!t)); let l = o.slice(); const h = l.map(((t) => JSON.stringify(t))); l = l.filter(((t, e) => h.indexOf(JSON.stringify(t)) === e)); const c = []; const d = []; t.forEach(((t, i) => { l.forEach(((a, s) => { a.indexOf(i) > -1 && (void 0 === c[s] && (c[s] = [], d[s] = []), c[s].push({ key: i, value: t }), d[s].push({ key: i, value: e[i] })); })); })); const g = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE); const u = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE); c.forEach(((t, e) => { t.forEach(((t, i) => { g[e] = Math.min(t.value, g[e]); })); })), d.forEach(((t, e) => { t.forEach(((t, i) => { u[e] = Math.max(t.value, u[e]); })); })), t.forEach(((t, e) => { d.forEach(((t, i) => { let n = g[i]; let o = u[i]; s.chart.stacked && (o = 0, t.forEach(((t, e) => { o += t.value, n !== Number.MIN_VALUE && (n += c[i][e].value); }))), t.forEach(((i, l) => { t[l].key === e && (void 0 !== s.yaxis[e].min && (n = typeof s.yaxis[e].min === 'function' ? s.yaxis[e].min(r.minY) : s.yaxis[e].min), void 0 !== s.yaxis[e].max && (o = typeof s.yaxis[e].max === 'function' ? s.yaxis[e].max(r.maxY) : s.yaxis[e].max), a.setYScaleForIndex(e, n, o)); })); })); })); } }, { key: 'autoScaleY', value(t, e, i) { t || (t = this); const a = t.w; if (a.globals.isMultipleYAxis || a.globals.collapsedSeries.length) return console.warn('autoScaleYaxis is not supported in a multi-yaxis chart.'), e; const s = a.globals.seriesX[0]; const r = a.config.chart.stacked; return e.forEach(((t, n) => { for (var o = 0, l = 0; l < s.length; l++) if (s[l] >= i.xaxis.min) { o = l; break; } let h; let c; const d = a.globals.minYArr[n]; const g = a.globals.maxYArr[n]; const u = a.globals.stackedSeriesTotals; a.globals.series.forEach(((n, l) => { let p = n[o]; r ? (p = u[o], h = c = p, u.forEach(((t, e) => { s[e] <= i.xaxis.max && s[e] >= i.xaxis.min && (t > c && t !== null && (c = t), n[e] < h && n[e] !== null && (h = n[e])); }))) : (h = c = p, n.forEach(((t, e) => { if (s[e] <= i.xaxis.max && s[e] >= i.xaxis.min) { let r = t; let n = t; a.globals.series.forEach(((i, a) => { t !== null && (r = Math.min(i[e], r), n = Math.max(i[e], n)); })), n > c && n !== null && (c = n), r < h && r !== null && (h = r); } }))), void 0 === h && void 0 === c && (h = d, c = g), (c *= c < 0 ? 0.9 : 1.1) < 0 && c < g && (c = g), (h *= h < 0 ? 1.1 : 0.9) < 0 && h > d && (h = d), e.length > 1 ? (e[l].min = void 0 === t.min ? h : t.min, e[l].max = void 0 === t.max ? c : t.max) : (e[0].min = void 0 === t.min ? h : t.min, e[0].max = void 0 === t.max ? c : t.max); })); })), e; } }]), t; }()); const Range$1 = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.scales = new Range(e); } return _createClass(t, [{ key: 'init', value() { this.setYRange(), this.setXRange(), this.setZRange(); } }, {
    key: 'getMinYMaxY',
    value(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE; let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE; let a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; const s = this.w.config; const r = this.w.globals; let n = -Number.MAX_VALUE; let o = Number.MIN_VALUE; a === null && (a = t + 1); const l = r.series; let h = l; let c = l; s.chart.type === 'candlestick' ? (h = r.seriesCandleL, c = r.seriesCandleH) : r.isRangeData && (h = r.seriesRangeStart, c = r.seriesRangeEnd); for (let d = t; d < a; d++) { r.dataPoints = Math.max(r.dataPoints, l[d].length); for (let g = 0; g < r.series[d].length; g++) { let u = l[d][g]; u !== null && Utils.isNumber(u) ? (n = Math.max(n, c[d][g]), e = Math.min(e, h[d][g]), i = Math.max(i, h[d][g]), this.w.config.chart.type === 'candlestick' && (n = Math.max(n, r.seriesCandleO[d][g]), n = Math.max(n, r.seriesCandleH[d][g]), n = Math.max(n, r.seriesCandleL[d][g]), i = n = Math.max(n, r.seriesCandleC[d][g])), Utils.isFloat(u) && (u = Utils.noExponents(u), r.yValueDecimal = Math.max(r.yValueDecimal, u.toString().split('.')[1].length)), o > h[d][g] && h[d][g] < 0 && (o = h[d][g])) : r.hasNullValues = !0; } } return s.chart.type === 'rangeBar' && r.seriesRangeStart.length && s.xaxis.type === 'datetime' && (o = e), s.chart.type === 'bar' && o < 0 && n < 0 && (n = 0), {
        minY: o, maxY: n, lowestY: e, highestY: i,
      };
    },
  }, {
    key: 'setYRange',
    value() {
      const t = this.w.globals; const e = this.w.config; t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE; let i = Number.MAX_VALUE; if (t.isMultipleYAxis) for (let a = 0; a < t.series.length; a++) { const s = this.getMinYMaxY(a, i, null, a + 1); t.minYArr.push(s.minY), t.maxYArr.push(s.maxY), i = s.lowestY; } const r = this.getMinYMaxY(0, i, null, t.series.length); if (t.minY = r.minY, t.maxY = r.maxY, i = r.lowestY, e.chart.stacked) { const n = []; const o = []; if (t.series.length) for (let l = 0; l < t.series[t.maxValsInArrayIndex].length; l++) for (let h = 0, c = 0, d = 0; d < t.series.length; d++)t.series[d][l] !== null && Utils.isNumber(t.series[d][l]) && (t.series[d][l] > 0 ? h = h + parseFloat(t.series[d][l]) + 1e-4 : c += parseFloat(t.series[d][l])), d === t.series.length - 1 && (n.push(h), o.push(c)); for (let g = 0; g < n.length; g++)t.maxY = Math.max(t.maxY, n[g]), t.minY = Math.min(t.minY, o[g]); } if ((e.chart.type === 'line' || e.chart.type === 'area' || e.chart.type === 'candlestick') && t.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t.maxY) { let u = t.maxY - i; i >= 0 && i <= 10 && (u = 0), t.minY = i - 5 * u / 100, i > 0 && t.minY < 0 && (t.minY = 0), t.maxY += 5 * u / 100; } return e.yaxis.map(((e, i) => { void 0 !== e.max && (typeof e.max === 'number' ? t.maxYArr[i] = e.max : typeof e.max === 'function' && (t.maxYArr[i] = e.max(t.maxY)), t.maxY = t.maxYArr[i]), void 0 !== e.min && (typeof e.min === 'number' ? t.minYArr[i] = e.min : typeof e.min === 'function' && (t.minYArr[i] = e.min(t.minY)), t.minY = t.minYArr[i]); })), t.isBarHorizontal && (void 0 !== e.xaxis.min && typeof e.xaxis.min === 'number' && (t.minY = e.xaxis.min), void 0 !== e.xaxis.max && typeof e.xaxis.max === 'number' && (t.maxY = e.xaxis.max)), t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = i, t.yAxisScale.forEach(((e, i) => { t.minYArr[i] = e.niceMin, t.maxYArr[i] = e.niceMax; }))) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), {
        minY: t.minY, maxY: t.maxY, minYArr: t.minYArr, maxYArr: t.maxYArr,
      };
    },
  }, { key: 'setXRange', value() { const t = this.w.globals; const e = this.w.config; const i = e.xaxis.type === 'numeric' || e.xaxis.type === 'datetime' || e.xaxis.type === 'category' && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric; if (t.isXNumeric) for (let a = 0; a < t.series.length; a++) if (t.labels[a]) for (let s = 0; s < t.labels[a].length; s++)t.labels[a][s] !== null && Utils.isNumber(t.labels[a][s]) && (t.maxX = Math.max(t.maxX, t.labels[a][s]), t.initialMaxX = Math.max(t.maxX, t.labels[a][s]), t.minX = Math.min(t.minX, t.labels[a][s]), t.initialMinX = Math.min(t.minX, t.labels[a][s])); if (t.noLabelsProvided && e.xaxis.categories.length === 0 && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) { let r; if (void 0 === e.xaxis.tickAmount ? (r = Math.round(t.svgWidth / 150), e.xaxis.type === 'numeric' && t.dataPoints < 30 && (r = t.dataPoints - 1), r > t.dataPoints && t.dataPoints !== 0 && (r = t.dataPoints - 1)) : e.xaxis.tickAmount === 'dataPoints' ? (t.series.length > 1 && (r = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (r = t.maxX - t.minX - 1)) : r = e.xaxis.tickAmount, t.xTickAmount = r, void 0 !== e.xaxis.max && typeof e.xaxis.max === 'number' && (t.maxX = e.xaxis.max), void 0 !== e.xaxis.min && typeof e.xaxis.min === 'number' && (t.minX = e.xaxis.min), void 0 !== e.xaxis.range && (t.minX = t.maxX - e.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE) if (e.xaxis.convertedCatToNumeric) { for (var n = [], o = t.minX - 1; o < t.maxX; o++)n.push(o + 1); t.xAxisScale = { result: n, niceMin: n[0], niceMax: n[n.length - 1] }; } else t.xAxisScale = this.scales.setXScale(t.minX, t.maxX); else t.xAxisScale = this.scales.linearScale(1, r, r), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, r - 1), t.seriesX = t.labels.slice()); i && (t.labels = t.xAxisScale.result.slice()); } if (t.minX === t.maxX) { const l = new DateTime(this.ctx); if (e.xaxis.type === 'datetime') { const h = e.xaxis.labels.datetimeUTC; const c = l.getDate(t.minX); h ? c.setUTCDate(c.getDate() - 2) : c.setDate(c.getDate() - 2), t.minX = new Date(c).getTime(); const d = l.getDate(t.maxX); h ? d.setUTCDate(d.getDate() + 2) : d.setDate(d.getDate() + 2), t.maxX = new Date(d).getTime(); } else (e.xaxis.type === 'numeric' || e.xaxis.type === 'category' && !t.noLabelsProvided) && (t.minX -= 2, t.initialMinX = t.minX, t.maxX += 2, t.initialMaxX = t.maxX); } return t.isXNumeric && t.seriesX.forEach(((e, i) => { e.length === 1 && e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]); const a = e.slice(); a.sort(((t, e) => t - e)), a.forEach(((e, a) => { if (a > 0) { const s = e - t.seriesX[i][a - 1]; s > 0 && (t.minXDiff = Math.min(s, t.minXDiff)); } })), t.dataPoints === 1 && t.minXDiff === Number.MAX_VALUE && (t.minXDiff = 0.5); })), { minX: t.minX, maxX: t.maxX }; } }, { key: 'setZRange', value() { const t = this.w.globals; if (t.isDataXYZ) for (let e = 0; e < t.series.length; e++) if (void 0 !== t.seriesZ[e]) for (let i = 0; i < t.seriesZ[e].length; i++)t.seriesZ[e][i] !== null && Utils.isNumber(t.seriesZ[e][i]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[e][i]), t.minZ = Math.min(t.minZ, t.seriesZ[e][i])); } }]), t;
}()); const YAxis = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; const i = this.w; this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = i.config.chart.type === 'bar' && i.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, i.config.xaxis.position === 'bottom' && (this.xAxisoffX = i.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new AxesUtils(e); } return _createClass(t, [{
    key: 'drawYaxis',
    value(t) {
      const e = this.w; const i = new Graphics(this.ctx); const a = e.config.yaxis[t].labels.style.fontSize; const s = e.config.yaxis[t].labels.style.fontFamily; const r = i.group({ class: 'apexcharts-yaxis', rel: t, transform: `translate(${e.globals.translateYAxisX[t]}, 0)` }); if (!e.config.yaxis[t].show) return r; const n = i.group({ class: 'apexcharts-yaxis-texts-g' }); r.add(n); const o = e.globals.yAxisScale[t].result.length - 1; const l = e.globals.gridHeight / o; let h = e.globals.translateY; const c = e.globals.yLabelFormatters[t]; let d = e.globals.yAxisScale[t].result.slice(); d = this.axesUtils.checkForReversedLabels(t, d); let g = ''; if (e.config.yaxis[t].labels.show) {
        for (let u = o; u >= 0; u--) {
          let p = d[u]; p = c(p, u); let f = e.config.yaxis[t].labels.padding; e.config.yaxis[t].opposite && e.config.yaxis.length !== 0 && (f *= -1); const x = i.drawText({
            x: f, y: h + o / 10 + e.config.yaxis[t].labels.offsetY + 1, text: p, textAnchor: e.config.yaxis[t].opposite ? 'start' : 'end', fontSize: a, fontFamily: s, foreColor: e.config.yaxis[t].labels.style.color, isPlainText: !1, cssClass: `apexcharts-yaxis-label ${e.config.yaxis[t].labels.style.cssClass}`,
          }); if (u === o && (g = x), n.add(x), e.config.yaxis[t].labels.rotate !== 0) { const b = i.rotateAroundCenter(g.node); const m = i.rotateAroundCenter(x.node); x.node.setAttribute('transform', 'rotate('.concat(e.config.yaxis[t].labels.rotate, ' ').concat(b.x, ' ').concat(m.y, ')')); }h += l;
        }
      } if (void 0 !== e.config.yaxis[t].title.text) {
        const v = i.group({ class: 'apexcharts-yaxis-title' }); let y = 0; e.config.yaxis[t].opposite && (y = e.globals.translateYAxisX[t]); const w = i.drawText({
          x: y, y: e.globals.gridHeight / 2 + e.globals.translateY + e.config.yaxis[t].title.offsetY, text: e.config.yaxis[t].title.text, textAnchor: 'end', foreColor: e.config.yaxis[t].title.style.color, fontSize: e.config.yaxis[t].title.style.fontSize, fontFamily: e.config.yaxis[t].title.style.fontFamily, cssClass: `apexcharts-yaxis-title-text ${e.config.yaxis[t].title.style.cssClass}`,
        }); v.add(w), r.add(v);
      } const k = e.config.yaxis[t].axisBorder; let C = 31 + k.offsetX; if (e.config.yaxis[t].opposite && (C = -31 - k.offsetX), k.show) { const A = i.drawLine(C, e.globals.translateY + k.offsetY - 2, C, e.globals.gridHeight + e.globals.translateY + k.offsetY + 2, k.color, 0, k.width); r.add(A); } return e.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(C, o, k, e.config.yaxis[t].axisTicks, t, l, r), r;
    },
  }, {
    key: 'drawYaxisInversed',
    value(t) {
      const e = this.w; const i = new Graphics(this.ctx); const a = i.group({ class: 'apexcharts-xaxis apexcharts-yaxis-inversed' }); const s = i.group({ class: 'apexcharts-xaxis-texts-g', transform: 'translate('.concat(e.globals.translateXAxisX, ', ').concat(e.globals.translateXAxisY, ')') }); a.add(s); let r = e.globals.yAxisScale[t].result.length - 1; const n = e.globals.gridWidth / r + 0.1; let o = n + e.config.xaxis.labels.offsetX; const l = e.globals.xLabelFormatter; let h = e.globals.yAxisScale[t].result.slice(); const c = e.globals.timescaleLabels; c.length > 0 && (this.xaxisLabels = c.slice(), r = (h = c.slice()).length), h = this.axesUtils.checkForReversedLabels(t, h); const d = c.length; if (e.config.xaxis.labels.show) {
        for (let g = d ? 0 : r; d ? g < d : g >= 0; d ? g++ : g--) {
          let u = h[g]; u = l(u, g); let p = e.globals.gridWidth + e.globals.padHorizontal - (o - n + e.config.xaxis.labels.offsetX); if (c.length) { const f = this.axesUtils.getLabel(h, c, p, g, this.drawnLabels, this.xaxisFontSize); p = f.x, u = f.text, this.drawnLabels.push(f.text), g === 0 && e.globals.skipFirstTimelinelabel && (u = ''), g === h.length - 1 && e.globals.skipLastTimelinelabel && (u = ''); } const x = i.drawText({
            x: p, y: this.xAxisoffX + e.config.xaxis.labels.offsetY + 30, text: u, textAnchor: 'middle', foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, isPlainText: !1, cssClass: `apexcharts-xaxis-label ${e.config.xaxis.labels.style.cssClass}`,
          }); s.add(x), x.tspan(u); const b = document.createElementNS(e.globals.SVGNS, 'title'); b.textContent = u, x.node.appendChild(b), o += n;
        }
      } return this.inversedYAxisTitleText(a), this.inversedYAxisBorder(a), a;
    },
  }, { key: 'inversedYAxisBorder', value(t) { const e = this.w; const i = new Graphics(this.ctx); const a = e.config.xaxis.axisBorder; if (a.show) { let s = 0; e.config.chart.type === 'bar' && e.globals.isXNumeric && (s -= 15); const r = i.drawLine(e.globals.padHorizontal + s + a.offsetX, this.xAxisoffX, e.globals.gridWidth, this.xAxisoffX, a.color, 0, a.height); t.add(r); } } }, {
    key: 'inversedYAxisTitleText',
    value(t) {
      const e = this.w; const i = new Graphics(this.ctx); if (void 0 !== e.config.xaxis.title.text) {
        const a = i.group({ class: 'apexcharts-xaxis-title apexcharts-yaxis-title-inversed' }); const s = i.drawText({
          x: e.globals.gridWidth / 2, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e.config.xaxis.title.style.fontSize) + 20, text: e.config.xaxis.title.text, textAnchor: 'middle', fontSize: e.config.xaxis.title.style.fontSize, fontFamily: e.config.xaxis.title.style.fontFamily, cssClass: `apexcharts-xaxis-title-text ${e.config.xaxis.title.style.cssClass}`,
        }); a.add(s), t.add(a);
      }
    },
  }, { key: 'yAxisTitleRotate', value(t, e) { const i = this.w; const a = new Graphics(this.ctx); let s = { width: 0, height: 0 }; let r = { width: 0, height: 0 }; const n = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g")); n !== null && (s = n.getBoundingClientRect()); const o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text")); if (o !== null && (r = o.getBoundingClientRect()), o !== null) { const l = this.xPaddingForYAxisTitle(t, s, r, e); o.setAttribute('x', l.xPos - (e ? 10 : 0)); } if (o !== null) { const h = a.rotateAroundCenter(o); o.setAttribute('transform', 'rotate('.concat(e ? '' : '-').concat(i.config.yaxis[t].title.rotate, ' ').concat(h.x, ' ').concat(h.y, ')')); } } }, { key: 'xPaddingForYAxisTitle', value(t, e, i, a) { const s = this.w; let r = 0; let n = 0; let o = 10; return void 0 === s.config.yaxis[t].title.text || t < 0 ? { xPos: n, padd: 0 } : (a ? (n = e.width + s.config.yaxis[t].title.offsetX + i.width / 2 + o / 2, (r += 1) === 0 && (n -= o / 2)) : (n = -1 * e.width + s.config.yaxis[t].title.offsetX + o / 2 + i.width / 2, s.globals.isBarHorizontal && (o = 25, n = -1 * e.width - s.config.yaxis[t].title.offsetX - o)), { xPos: n, padd: o }); } }, { key: 'setYAxisXPosition', value(t, e) { const i = this.w; let a = 0; let s = 0; let r = 21; let n = 1; i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map(((o, l) => { const h = i.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !o.show || o.floating || t[l].width === 0; const c = t[l].width + e[l].width; o.opposite ? i.globals.isBarHorizontal ? (s = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[l] = s - o.labels.offsetX) : (s = i.globals.gridWidth + i.globals.translateX + n, h || (n = n + c + 20), i.globals.translateYAxisX[l] = s - o.labels.offsetX + 20) : (a = i.globals.translateX - r, h || (r = r + c + 20), i.globals.translateYAxisX[l] = a + o.labels.offsetX); })); } }, { key: 'setYAxisTextAlignments', value() { const t = this.w; let e = t.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis'); (e = Utils.listToArray(e)).forEach(((e, i) => { const a = t.config.yaxis[i]; if (void 0 !== a.labels.align) { const s = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")); let r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label")); r = Utils.listToArray(r); const n = s.getBoundingClientRect(); a.labels.align === 'left' ? (r.forEach(((t, e) => { t.setAttribute('text-anchor', 'start'); })), a.opposite || s.setAttribute('transform', 'translate(-'.concat(n.width, ', 0)'))) : a.labels.align === 'center' ? (r.forEach(((t, e) => { t.setAttribute('text-anchor', 'middle'); })), s.setAttribute('transform', 'translate('.concat(n.width / 2 * (a.opposite ? 1 : -1), ', 0)'))) : a.labels.align === 'right' && (r.forEach(((t, e) => { t.setAttribute('text-anchor', 'end'); })), a.opposite && s.setAttribute('transform', 'translate('.concat(n.width, ', 0)'))); } })); } }]), t;
}()); const Events = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.documentEvent = Utils.bind(this.documentEvent, this); } return _createClass(t, [{ key: 'addEventListener', value(t, e) { const i = this.w; i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(e) : i.globals.events[t] = [e]; } }, { key: 'removeEventListener', value(t, e) { const i = this.w; if (i.globals.events.hasOwnProperty(t)) { const a = i.globals.events[t].indexOf(e); a !== -1 && i.globals.events[t].splice(a, 1); } } }, { key: 'fireEvent', value(t, e) { const i = this.w; if (i.globals.events.hasOwnProperty(t)) { e && e.length || (e = []); for (let a = i.globals.events[t], s = a.length, r = 0; r < s; r++)a[r].apply(null, e); } } }, { key: 'setupEventHandlers', value() { const t = this; const e = this.w; const i = this.ctx; const a = e.globals.dom.baseEl.querySelector(e.globals.chartClass); this.ctx.eventList.forEach(((t) => { a.addEventListener(t, ((t) => { const a = { ...e, seriesIndex: e.globals.capturedSeriesIndex, dataPointIndex: e.globals.capturedDataPointIndex }; t.type === 'mousemove' || t.type === 'touchmove' ? typeof e.config.chart.events.mouseMove === 'function' && e.config.chart.events.mouseMove(t, i, a) : (t.type === 'mouseup' && t.which === 1 || t.type === 'touchend') && (typeof e.config.chart.events.click === 'function' && e.config.chart.events.click(t, i, a), i.ctx.events.fireEvent('click', [t, i, a])); }), { capture: !1, passive: !0 }); })), this.ctx.eventList.forEach(((e) => { document.addEventListener(e, t.documentEvent); })), this.ctx.core.setupBrushHandler(); } }, { key: 'documentEvent', value(t) { const e = this.w; if (t.type === 'click') { const i = t.target.className; const a = e.globals.dom.baseEl.querySelector('.apexcharts-menu'); a && a.classList.contains('apexcharts-menu-open') && i !== 'apexcharts-menu-icon' && a.classList.remove('apexcharts-menu-open'); }e.globals.clientX = t.type === 'touchmove' ? t.touches[0].clientX : t.clientX, e.globals.clientY = t.type === 'touchmove' ? t.touches[0].clientY : t.clientY; } }]), t; }()); const Localization = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'setCurrentLocaleValues', value(t) { let e = this.w.config.chart.locales; window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e = this.w.config.chart.locales.concat(window.Apex.chart.locales)); const i = e.filter(((e) => e.name === t))[0]; if (!i) throw new Error('Wrong locale name provided. Please make sure you set the correct locale name in options'); const a = Utils.extend(en, i); this.w.globals.locale = a.options; } }]), t; }()); const Axes = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'drawAxis', value(t, e) { let i; let a; const s = this.w.globals; const r = this.w.config; const n = new XAxis(this.ctx); const o = new YAxis(this.ctx); s.axisCharts && t !== 'radar' && (s.isBarHorizontal ? (a = o.drawYaxisInversed(0), i = n.drawXaxisInversed(0), s.dom.elGraphical.add(i), s.dom.elGraphical.add(a)) : (i = n.drawXaxis(), s.dom.elGraphical.add(i), r.yaxis.map(((t, e) => { s.ignoreYAxisIndexes.indexOf(e) === -1 && (a = o.drawYaxis(e), s.dom.Paper.add(a)); })))); r.yaxis.map(((t, e) => { s.ignoreYAxisIndexes.indexOf(e) === -1 && o.yAxisTitleRotate(e, t.opposite); })); } }]), t; }()); const Crosshairs = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{
    key: 'drawXCrosshairs',
    value() {
      const t = this.w; const e = new Graphics(this.ctx); const i = new Filters(this.ctx); const a = t.config.xaxis.crosshairs.fill.gradient; const s = t.config.xaxis.crosshairs.dropShadow; const r = t.config.xaxis.crosshairs.fill.type; const n = a.colorFrom; const o = a.colorTo; const l = a.opacityFrom; const h = a.opacityTo; const c = a.stops; const d = s.enabled; const g = s.left; const u = s.top; const p = s.blur; const f = s.color; const x = s.opacity; let b = t.config.xaxis.crosshairs.fill.color; if (t.config.xaxis.crosshairs.show) {
        r === 'gradient' && (b = e.drawGradient('vertical', n, o, l, h, null, c, null)); let m = e.drawRect(); t.config.xaxis.crosshairs.width === 1 && (m = e.drawLine()), m.attr({
          class: 'apexcharts-xcrosshairs', x: 0, y: 0, y2: t.globals.gridHeight, width: Utils.isNumber(t.config.xaxis.crosshairs.width) ? t.config.xaxis.crosshairs.width : 0, height: t.globals.gridHeight, fill: b, filter: 'none', 'fill-opacity': t.config.xaxis.crosshairs.opacity, stroke: t.config.xaxis.crosshairs.stroke.color, 'stroke-width': t.config.xaxis.crosshairs.stroke.width, 'stroke-dasharray': t.config.xaxis.crosshairs.stroke.dashArray,
        }), d && (m = i.dropShadow(m, {
          left: g, top: u, blur: p, color: f, opacity: x,
        })), t.globals.dom.elGraphical.add(m);
      }
    },
  }, { key: 'drawYCrosshairs', value() { const t = this.w; const e = new Graphics(this.ctx); const i = t.config.yaxis[0].crosshairs; if (t.config.yaxis[0].crosshairs.show) { const a = e.drawLine(0, 0, t.globals.gridWidth, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width); a.attr({ class: 'apexcharts-ycrosshairs' }), t.globals.dom.elGraphical.add(a); } const s = e.drawLine(0, 0, t.globals.gridWidth, 0, i.stroke.color, 0, 0); s.attr({ class: 'apexcharts-ycrosshairs-hidden' }), t.globals.dom.elGraphical.add(s); } }]), t;
}()); const Responsive = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'checkResponsiveConfig', value(t) { const e = this; const i = this.w; const a = i.config; if (a.responsive.length !== 0) { const s = a.responsive.slice(); s.sort(((t, e) => (t.breakpoint > e.breakpoint ? 1 : e.breakpoint > t.breakpoint ? -1 : 0))).reverse(); const r = new Config({}); const n = function () { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const a = s[0].breakpoint; const n = window.innerWidth > 0 ? window.innerWidth : screen.width; if (n > a) { const o = CoreUtils.extendArrayProps(r, i.globals.initialConfig); t = Utils.extend(o, t), t = Utils.extend(i.config, t), e.overrideResponsiveOptions(t); } else for (let l = 0; l < s.length; l++)n < s[l].breakpoint && (t = CoreUtils.extendArrayProps(r, s[l].options), t = Utils.extend(i.config, t), e.overrideResponsiveOptions(t)); }; if (t) { let o = CoreUtils.extendArrayProps(r, t); o = Utils.extend(i.config, o), n(o = Utils.extend(o, t)); } else n({}); } } }, { key: 'overrideResponsiveOptions', value(t) { const e = new Config(t).init({ responsiveOverride: !0 }); this.w.config = e; } }]), t; }()); const Theme = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.colors = [], this.w = e.w; const i = this.w; this.isBarDistributed = i.config.plotOptions.bar.distributed && (i.config.chart.type === 'bar' || i.config.chart.type === 'rangeBar'); } return _createClass(t, [{ key: 'init', value() { this.setDefaultColors(); } }, { key: 'setDefaultColors', value() { const t = this.w; const e = new Utils(); if (t.globals.dom.elWrap.classList.add('apexcharts-theme-'.concat(t.config.theme.mode)), void 0 === t.config.colors ? t.globals.colors = this.predefined() : (t.globals.colors = t.config.colors, t.globals.axisCharts && t.config.chart.type !== 'bar' && Array.isArray(t.config.colors) && t.config.colors.length > 0 && t.config.colors.length === t.config.series.length && (t.globals.colors = t.config.colors.map(((e, i) => (typeof e === 'function' ? e({ value: t.globals.axisCharts ? t.globals.series[i][0] ? t.globals.series[i][0] : 0 : t.globals.series[i], seriesIndex: i, w: t }) : e))))), t.config.theme.monochrome.enabled) { const i = []; let a = t.globals.series.length; this.isBarDistributed && (a = t.globals.series[0].length * t.globals.series.length); for (let s = t.config.theme.monochrome.color, r = 1 / (a / t.config.theme.monochrome.shadeIntensity), n = t.config.theme.monochrome.shadeTo, o = 0, l = 0; l < a; l++) { let h = void 0; n === 'dark' ? (h = e.shadeColor(-1 * o, s), o += r) : (h = e.shadeColor(o, s), o += r), i.push(h); }t.globals.colors = i.slice(); } const c = t.globals.colors.slice(); this.pushExtraColors(t.globals.colors), void 0 === t.config.stroke.colors ? t.globals.stroke.colors = c : t.globals.stroke.colors = t.config.stroke.colors, this.pushExtraColors(t.globals.stroke.colors), void 0 === t.config.fill.colors ? t.globals.fill.colors = c : t.globals.fill.colors = t.config.fill.colors, this.pushExtraColors(t.globals.fill.colors), void 0 === t.config.dataLabels.style.colors ? t.globals.dataLabels.style.colors = c : t.globals.dataLabels.style.colors = t.config.dataLabels.style.colors, this.pushExtraColors(t.globals.dataLabels.style.colors, 50), void 0 === t.config.plotOptions.radar.polygons.fill.colors ? t.globals.radarPolygons.fill.colors = [t.config.theme.mode === 'dark' ? '#202D48' : '#fff'] : t.globals.radarPolygons.fill.colors = t.config.plotOptions.radar.polygons.fill.colors, this.pushExtraColors(t.globals.radarPolygons.fill.colors, 20), void 0 === t.config.markers.colors ? t.globals.markers.colors = c : t.globals.markers.colors = t.config.markers.colors, this.pushExtraColors(t.globals.markers.colors); } }, { key: 'pushExtraColors', value(t, e) { let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const a = this.w; let s = e || a.globals.series.length; if (i === null && (i = this.isBarDistributed || a.config.chart.type === 'heatmap' && a.config.plotOptions.heatmap.colorScale.inverse), i && (s = a.globals.series[0].length * a.globals.series.length), t.length < s) for (let r = s - t.length, n = 0; n < r; n++)t.push(t[n]); } }, { key: 'updateThemeOptions', value(t) { t.chart = t.chart || {}, t.tooltip = t.tooltip || {}; const e = t.theme.mode || 'light'; const i = t.theme.palette ? t.theme.palette : e === 'dark' ? 'palette4' : 'palette1'; const a = t.chart.foreColor ? t.chart.foreColor : e === 'dark' ? '#f6f7f8' : '#373d3f'; return t.tooltip.theme = e, t.chart.foreColor = a, t.theme.palette = i, t; } }, { key: 'predefined', value() { switch (this.w.config.theme.palette) { case 'palette1': this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0']; break; case 'palette2': this.colors = ['#3f51b5', '#03a9f4', '#4caf50', '#f9ce1d', '#FF9800']; break; case 'palette3': this.colors = ['#33b2df', '#546E7A', '#d4526e', '#13d8aa', '#A5978B']; break; case 'palette4': this.colors = ['#4ecdc4', '#c7f464', '#81D4FA', '#fd6a6a', '#546E7A']; break; case 'palette5': this.colors = ['#2b908f', '#f9a3a4', '#90ee7e', '#fa4443', '#69d2e7']; break; case 'palette6': this.colors = ['#449DD1', '#F86624', '#EA3546', '#662E9B', '#C5D86D']; break; case 'palette7': this.colors = ['#D7263D', '#1B998B', '#2E294E', '#F46036', '#E2C044']; break; case 'palette8': this.colors = ['#662E9B', '#F86624', '#F9C80E', '#EA3546', '#43BCCD']; break; case 'palette9': this.colors = ['#5C4742', '#A5978B', '#8D5B4C', '#5A2A27', '#C4BBAF']; break; case 'palette10': this.colors = ['#A300D6', '#7D02EB', '#5653FE', '#2983FF', '#00B1F2']; break; default: this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0']; } return this.colors; } }]), t; }()); const TitleSubtitle = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'draw', value() { this.drawTitleSubtitle('title'), this.drawTitleSubtitle('subtitle'); } }, {
    key: 'drawTitleSubtitle',
    value(t) {
      const e = this.w; const i = t === 'title' ? e.config.title : e.config.subtitle; let a = e.globals.svgWidth / 2; let s = i.offsetY; let r = 'middle'; if (i.align === 'left' ? (a = 10, r = 'start') : i.align === 'right' && (a = e.globals.svgWidth - 10, r = 'end'), a += i.offsetX, s = s + parseInt(i.style.fontSize, 10) + i.margin / 2, void 0 !== i.text) {
        const n = new Graphics(this.ctx).drawText({
          x: a, y: s, text: i.text, textAnchor: r, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, foreColor: i.style.color, opacity: 1,
        }); n.node.setAttribute('class', 'apexcharts-'.concat(t, '-text')), e.globals.dom.Paper.add(n);
      }
    },
  }]), t;
}()); const Helpers$1 = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.dCtx = e; } return _createClass(t, [{ key: 'getTitleSubtitleCoords', value(t) { const e = this.w; let i = 0; let a = 0; const s = t === 'title' ? e.config.title.floating : e.config.subtitle.floating; const r = e.globals.dom.baseEl.querySelector('.apexcharts-'.concat(t, '-text')); if (r !== null && !s) { const n = r.getBoundingClientRect(); i = n.width, a = e.globals.axisCharts ? n.height + 5 : n.height; } return { width: i, height: a }; } }, {
    key: 'getLegendsRect',
    value() {
      const t = this.w; const e = t.globals.dom.baseEl.querySelector('.apexcharts-legend'); const i = { ...Utils.getBoundingClientRect(e) }; return e !== null && !t.config.legend.floating && t.config.legend.show ? this.dCtx.lgRect = {
        x: i.x, y: i.y, height: i.height, width: i.height === 0 ? 0 : i.width,
      } : this.dCtx.lgRect = {
        x: 0, y: 0, height: 0, width: 0,
      }, t.config.legend.position !== 'left' && t.config.legend.position !== 'right' || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), i;
    },
  }]), t;
}()); const DimXAxis = (function () { function t(e) { _classCallCheck(this, t), this.w = e.w, this.dCtx = e; } return _createClass(t, [{ key: 'getxAxisLabelsCoords', value() { let t; const e = this.w; let i = e.globals.labels.slice(); if (e.config.xaxis.convertedCatToNumeric && i.length === 0 && (i = e.globals.categoryLabels), e.globals.timescaleLabels.length > 0) { const a = this.getxAxisTimeScaleLabelsCoords(); t = { width: a.width, height: a.height }, e.globals.rotateXLabels = !1; } else { this.dCtx.lgWidthForSideLegends = e.config.legend.position !== 'left' && e.config.legend.position !== 'right' || e.config.legend.floating ? 0 : this.dCtx.lgRect.width; const s = e.globals.xLabelFormatter; let r = Utils.getLargestStringFromArr(i); let n = r; if (e.globals.isMultiLineX) { const o = i.map(((t, e) => (Array.isArray(t) ? t.length : 1))); const l = Math.max.apply(Math, _toConsumableArray(o)); n = i[o.indexOf(l)]; }e.globals.isBarHorizontal && (n = r = e.globals.yAxisScale[0].result.reduce(((t, e) => (t.length > e.length ? t : e)), 0)); const h = new Formatters(this.dCtx.ctx); const c = r; r = h.xLabelFormat(s, r, c), n = h.xLabelFormat(s, n, c), e.config.xaxis.convertedCatToNumeric && void 0 === r && (n = r = '1'); const d = new Graphics(this.dCtx.ctx); let g = d.getTextRects(r, e.config.xaxis.labels.style.fontSize); let u = g; if (r !== n && (u = d.getTextRects(n, e.config.xaxis.labels.style.fontSize)), (t = { width: g.width >= u.width ? g.width : u.width, height: g.height >= u.height ? g.height : u.height }).width * i.length > e.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && e.config.xaxis.labels.rotate !== 0 || e.config.xaxis.labels.rotateAlways) { if (!e.globals.isBarHorizontal) { e.globals.rotateXLabels = !0; const p = function (t) { return d.getTextRects(t, e.config.xaxis.labels.style.fontSize, e.config.xaxis.labels.style.fontFamily, 'rotate('.concat(e.config.xaxis.labels.rotate, ' 0 0)'), !1); }; g = p(r), r !== n && (u = p(n)), t.height = (g.height > u.height ? g.height : u.height) / 1.5, t.width = g.width > u.width ? g.width : u.width; } } else e.globals.rotateXLabels = !1; } return e.config.xaxis.labels.show || (t = { width: 0, height: 0 }), { width: t.width, height: t.height }; } }, { key: 'getxAxisTitleCoords', value() { const t = this.w; let e = 0; let i = 0; if (void 0 !== t.config.xaxis.title.text) { const a = new Graphics(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize); e = a.width, i = a.height; } return { width: e, height: i }; } }, { key: 'getxAxisTimeScaleLabelsCoords', value() { let t; const e = this.w; this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice(); const i = this.dCtx.timescaleLabels.map(((t) => t.value)); const a = i.reduce(((t, e) => (void 0 === t ? (console.error('You have possibly supplied invalid Date format. Please supply a valid JavaScript Date'), 0) : t.length > e.length ? t : e)), 0); return 1.05 * (t = new Graphics(this.dCtx.ctx).getTextRects(a, e.config.xaxis.labels.style.fontSize)).width * i.length > e.globals.gridWidth && e.config.xaxis.labels.rotate !== 0 && (e.globals.overlappingXLabels = !0), t; } }, { key: 'additionalPaddingXLabels', value(t) { const e = this; const i = this.w; const a = i.globals; const s = i.config; const r = s.xaxis.type; const n = t.width; a.skipLastTimelinelabel = !1, a.skipFirstTimelinelabel = !1; const o = i.config.yaxis[0].opposite && i.globals.isBarHorizontal; const l = function (t, o) { (function (t) { return a.collapsedSeriesIndices.indexOf(t) !== -1; }(o)) || (r !== 'datetime' && e.dCtx.gridPad.left < n / 2 - e.dCtx.yAxisWidthLeft && !a.rotateXLabels && !s.xaxis.labels.trim && (e.dCtx.xPadLeft = n / 2 + 1), (function (t) { if (e.dCtx.timescaleLabels && e.dCtx.timescaleLabels.length) { const s = e.dCtx.timescaleLabels[0]; const o = e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length - 1].position + n / 1.75 + e.dCtx.yAxisWidthRight; const l = s.position - n / 1.75 + (t.opposite ? 0 : e.dCtx.yAxisWidthLeft); o > a.gridWidth && (a.skipLastTimelinelabel = !0), l < 0 && (a.skipFirstTimelinelabel = !0); } else r === 'datetime' ? e.dCtx.gridPad.right < n && !a.rotateXLabels && (a.skipLastTimelinelabel = !0) : r !== 'datetime' && e.dCtx.gridPad.right < n / 2 - e.dCtx.yAxisWidthRight && !a.rotateXLabels && (i.config.xaxis.tickPlacement !== 'between' || i.globals.isBarHorizontal) && (e.dCtx.xPadRight = n / 2 + 1); }(t))); }; s.yaxis.forEach(((t, i) => { o ? (e.dCtx.gridPad.left < n && (e.dCtx.xPadLeft = n / 2 + 1), e.dCtx.xPadRight = n / 2 + 1) : l(t, i); })); } }]), t; }()); const DimYAxis = (function () { function t(e) { _classCallCheck(this, t), this.w = e.w, this.dCtx = e; } return _createClass(t, [{ key: 'getyAxisLabelsCoords', value() { const t = this; const e = this.w; const i = []; let a = 10; return e.config.yaxis.map(((s, r) => { if (s.show && s.labels.show && e.globals.yAxisScale[r].result.length) { const n = e.globals.yLabelFormatters[r]; let o = n(e.globals.yAxisScale[r].niceMax, { seriesIndex: r, dataPointIndex: -1, w: e }); let l = o; if (void 0 !== o && o.length !== 0 || (o = e.globals.yAxisScale[r].niceMax), e.globals.isBarHorizontal) { a = 0; const h = e.globals.labels.slice(); if (l = o = n(o = Utils.getLargestStringFromArr(h), { seriesIndex: r, dataPointIndex: -1, w: e }), e.globals.isMultiLineX) { const c = h.map(((t, e) => (Array.isArray(t) ? t.length : 1))); const d = Math.max.apply(Math, _toConsumableArray(c)); l = h[c.indexOf(d)]; } } const g = new Graphics(t.dCtx.ctx); const u = g.getTextRects(o, s.labels.style.fontSize); let p = u; o !== l && (p = g.getTextRects(l, s.labels.style.fontSize)), i.push({ width: (p.width > u.width ? p.width : u.width) + a, height: p.height > u.height ? p.height : u.height }); } else i.push({ width: 0, height: 0 }); })), i; } }, { key: 'getyAxisTitleCoords', value() { const t = this; const e = this.w; const i = []; return e.config.yaxis.map(((e, a) => { if (e.show && void 0 !== e.title.text) { const s = new Graphics(t.dCtx.ctx).getTextRects(e.title.text, e.title.style.fontSize, e.title.style.fontFamily, 'rotate(-90 0 0)', !1); i.push({ width: s.width, height: s.height }); } else i.push({ width: 0, height: 0 }); })), i; } }, { key: 'getTotalYAxisWidth', value() { const t = this.w; let e = 0; let i = 0; let a = 0; const s = t.globals.yAxisScale.length > 1 ? 10 : 0; const r = function (r, n) { const o = t.config.yaxis[n].floating; let l = 0; r.width > 0 && !o ? (l = r.width + s, (function (e) { return t.globals.ignoreYAxisIndexes.indexOf(e) > -1; }(n)) && (l = l - r.width - s)) : l = o || !t.config.yaxis[n].show ? 0 : 5, t.config.yaxis[n].opposite ? a += l : i += l, e += l; }; return t.globals.yLabelsCoords.map(((t, e) => { r(t, e); })), t.globals.yTitleCoords.map(((t, e) => { r(t, e); })), t.globals.isBarHorizontal && (e = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = a, e; } }]), t; }()); const DimGrid = (function () { function t(e) { _classCallCheck(this, t), this.w = e.w, this.dCtx = e; } return _createClass(t, [{ key: 'gridPadForColumnsInNumericAxis', value(t) { const e = this.w; const i = e.config.chart.type; let a = 0; let s = i === 'bar' || i === 'rangeBar' ? e.config.series.length : 1; if (e.globals.comboBarCount > 0 && (s = e.globals.comboBarCount), e.globals.collapsedSeries.forEach(((t) => { t.type !== 'bar' && t.type !== 'rangeBar' || (s -= 1); })), e.config.chart.stacked && (s = 1), (i === 'bar' || i === 'rangeBar' || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && s > 0) { let r; let n; let o = Math.abs(e.globals.initialMaxX - e.globals.initialMinX); o <= 3 && (o = e.globals.dataPoints), r = o / t, e.globals.minXDiff && e.globals.minXDiff / r > 0 && (n = e.globals.minXDiff / r), (a = n / s * parseInt(e.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (a = 1), a = a / (s > 1 ? 1 : 1.5) + 5, e.globals.barPadForNumericAxis = a; } return a; } }, { key: 'gridPadFortitleSubtitle', value() { const t = this; const e = this.w; const i = e.globals; let a = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10; ['title', 'subtitle'].forEach(((i) => { void 0 !== e.config[i].text ? a += e.config[i].margin : a += t.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5; })); const s = e.config.series.length > 1 || !e.globals.axisCharts || e.config.legend.showForSingleSeries; e.config.legend.show && e.config.legend.position === 'bottom' && !e.config.legend.floating && s && (a += 10); const r = this.dCtx.dimHelpers.getTitleSubtitleCoords('title'); const n = this.dCtx.dimHelpers.getTitleSubtitleCoords('subtitle'); i.gridHeight = i.gridHeight - r.height - n.height - a, i.translateY = i.translateY + r.height + n.height + a; } }, { key: 'setGridXPosForDualYAxis', value(t, e) { const i = this.w; i.config.yaxis.map(((a, s) => { i.globals.ignoreYAxisIndexes.indexOf(s) === -1 && !i.config.yaxis[s].floating && i.config.yaxis[s].show && a.opposite && (i.globals.translateX = i.globals.translateX - (e[s].width + t[s].width) - parseInt(i.config.yaxis[s].labels.style.fontSize, 10) / 1.2 - 12); })); } }]), t; }()); const Dimensions = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new Helpers$1(this), this.dimYAxis = new DimYAxis(this), this.dimXAxis = new DimXAxis(this), this.dimGrid = new DimGrid(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0; } return _createClass(t, [{ key: 'plotCoords', value() { const t = this.w.globals; this.lgRect = this.dimHelpers.getLegendsRect(), t.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), t.gridHeight = t.gridHeight - this.gridPad.top - this.gridPad.bottom, t.gridWidth = t.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft; const e = this.dimGrid.gridPadForColumnsInNumericAxis(t.gridWidth); t.gridWidth -= 2 * e, t.translateX = t.translateX + this.gridPad.left + this.xPadLeft + (e > 0 ? e + 4 : 0), t.translateY += this.gridPad.top; } }, { key: 'setDimensionsForAxisCharts', value() { const t = this; const e = this.w; const i = e.globals; const a = this.dimYAxis.getyAxisLabelsCoords(); const s = this.dimYAxis.getyAxisTitleCoords(); e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map(((t, i) => { e.globals.yLabelsCoords.push({ width: a[i].width, index: i }), e.globals.yTitleCoords.push({ width: s[i].width, index: i }); })), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth(); const r = this.dimXAxis.getxAxisLabelsCoords(); const n = this.dimXAxis.getxAxisTitleCoords(); this.conditionalChecksForAxisCoords(r, n), i.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY += e.config.xaxis.labels.offsetY, i.translateXAxisX += e.config.xaxis.labels.offsetX; let o = this.yAxisWidth; let l = this.xAxisHeight; i.xAxisLabelsHeight = this.xAxisHeight, i.xAxisHeight = this.xAxisHeight; let h = 10; (e.config.chart.type === 'radar' || this.isSparkline) && (o = 0, l = i.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }, l = 0, o = 0, h = 0), this.dimXAxis.additionalPaddingXLabels(r); const c = function () { i.translateX = o, i.gridHeight = i.svgHeight - t.lgRect.height - l - (t.isSparkline ? 0 : e.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - o; }; switch (e.config.legend.position) { case 'bottom': i.translateY = h, c(); break; case 'top': i.translateY = this.lgRect.height + h, c(); break; case 'left': i.translateY = h, i.translateX = this.lgRect.width + o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o; break; case 'right': i.translateY = h, i.translateX = o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o - 5; break; default: throw new Error('Legend position not supported'); } this.dimGrid.setGridXPosForDualYAxis(s, a), new YAxis(this.ctx).setYAxisXPosition(a, s); } }, {
    key: 'setDimensionsForNonAxisCharts',
    value() {
      const t = this.w; const e = t.globals; const i = t.config; let a = 0; t.config.legend.show && !t.config.legend.floating && (a = 20); const s = i.chart.type === 'pie' || i.chart.type === 'donut' ? 'pie' : 'radialBar'; const r = 10 + i.plotOptions[s].offsetY; const
        n = i.plotOptions[s].offsetX; if (!i.legend.show || i.legend.floating) return e.gridHeight = e.svgHeight - e.goldenPadding, e.gridWidth = e.gridHeight, e.translateY = r - 10, void (e.translateX = n + (e.svgWidth - e.gridWidth) / 2); switch (i.legend.position) { case 'bottom': e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.gridHeight, e.translateY = r - 20, e.translateX = n + (e.svgWidth - e.gridWidth) / 2; break; case 'top': e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.gridHeight, e.translateY = this.lgRect.height + r + 10, e.translateX = n + (e.svgWidth - e.gridWidth) / 2; break; case 'left': e.gridWidth = e.svgWidth - this.lgRect.width - a, e.gridHeight = i.chart.height !== 'auto' ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = n + this.lgRect.width + a; break; case 'right': e.gridWidth = e.svgWidth - this.lgRect.width - a - 5, e.gridHeight = i.chart.height !== 'auto' ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = n + 10; break; default: throw new Error('Legend position not supported'); }
    },
  }, { key: 'conditionalChecksForAxisCoords', value(t, e) { const i = this.w; this.xAxisHeight = (t.height + e.height) * (i.globals.isMultiLineX ? 1.2 : i.globals.LINE_HEIGHT_RATIO) + (i.globals.rotateXLabels ? 22 : 10), this.xAxisWidth = t.width, this.xAxisHeight - e.height > i.config.xaxis.labels.maxHeight && (this.xAxisHeight = i.config.xaxis.labels.maxHeight), i.config.xaxis.labels.minHeight && this.xAxisHeight < i.config.xaxis.labels.minHeight && (this.xAxisHeight = i.config.xaxis.labels.minHeight), i.config.xaxis.floating && (this.xAxisHeight = 0); let a = 0; let s = 0; i.config.yaxis.forEach(((t) => { a += t.labels.minWidth, s += t.labels.maxWidth; })), this.yAxisWidth < a && (this.yAxisWidth = a), this.yAxisWidth > s && (this.yAxisWidth = s); } }]), t;
}()); const Pie = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels; const i = this.w; this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors, this.defaultSize = i.globals.svgHeight < i.globals.svgWidth ? i.globals.gridHeight : i.globals.gridWidth, this.centerY = this.defaultSize / 2, this.centerX = i.globals.gridWidth / 2, this.fullAngle = 360, i.globals.radialSize = this.defaultSize / 2.05 - i.config.stroke.width - i.config.chart.dropShadow.blur, void 0 !== i.config.plotOptions.pie.size && (i.globals.radialSize = i.config.plotOptions.pie.size), this.donutSize = i.globals.radialSize * parseInt(i.config.plotOptions.pie.donut.size, 10) / 100, this.sliceLabels = [], this.prevSectorAngleArr = []; } return _createClass(t, [{
    key: 'draw',
    value(t) {
      const e = this.w; const i = new Graphics(this.ctx); const a = i.group({ class: 'apexcharts-pie' }); if (e.globals.noData) return a; for (var s = 0, r = 0; r < t.length; r++)s += Utils.negToZero(t[r]); const n = []; const o = i.group(); s === 0 && (s = 1e-5); for (let l = 0; l < t.length; l++) { const h = this.fullAngle * Utils.negToZero(t[l]) / s; n.push(h); } if (e.globals.dataChanged) { for (var c, d = 0, g = 0; g < e.globals.previousPaths.length; g++)d += Utils.negToZero(e.globals.previousPaths[g]); for (let u = 0; u < e.globals.previousPaths.length; u++)c = this.fullAngle * Utils.negToZero(e.globals.previousPaths[u]) / d, this.prevSectorAngleArr.push(c); } this.donutSize < 0 && (this.donutSize = 0); const p = e.config.plotOptions.pie.customScale; const f = e.globals.gridWidth / 2; const x = e.globals.gridHeight / 2; const b = f - e.globals.gridWidth / 2 * p; const m = x - e.globals.gridHeight / 2 * p; if (e.config.chart.type === 'donut') { const v = i.drawCircle(this.donutSize); v.attr({ cx: this.centerX, cy: this.centerY, fill: e.config.plotOptions.pie.donut.background }), o.add(v); } const y = this.drawArcs(n, t); if (this.sliceLabels.forEach(((t) => { y.add(t); })), o.attr({ transform: 'translate('.concat(b, ', ').concat(m - 5, ') scale(').concat(p, ')') }), a.attr({ 'data:innerTranslateX': b, 'data:innerTranslateY': m - 25 }), o.add(y), a.add(o), this.donutDataLabels.show) {
        const w = this.renderInnerDataLabels(this.donutDataLabels, {
          hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: b, translateY: m,
        }); a.add(w);
      } return a;
    },
  }, {
    key: 'drawArcs',
    value(t, e) {
      const i = this.w; const a = new Filters(this.ctx); const s = new Graphics(this.ctx); const r = new Fill(this.ctx); const n = s.group({ class: 'apexcharts-slices' }); let o = 0; let l = 0; let h = 0; let c = 0; this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0; for (let d = 0; d < t.length; d++) {
        const g = s.group({
          class: 'apexcharts-series apexcharts-pie-series', seriesName: Utils.escapeString(i.globals.seriesNames[d]), rel: d + 1, 'data:realIndex': d,
        }); n.add(g), l = c, h = (o = h) + t[d], c = l + this.prevSectorAngleArr[d]; const u = h - o; const p = r.fillPath({ seriesNumber: d, size: i.globals.radialSize, value: e[d] }); const f = this.getChangedPath(l, c); const x = s.drawPath({
          d: f, stroke: this.lineColorArr instanceof Array ? this.lineColorArr[d] : this.lineColorArr, strokeWidth: this.strokeWidth, fill: p, fillOpacity: i.config.fill.opacity, classes: 'apexcharts-pie-area apexcharts-'.concat(i.config.chart.type, '-slice-').concat(d),
        }); if (x.attr({ index: 0, j: d }), i.config.chart.dropShadow.enabled) { const b = i.config.chart.dropShadow; a.dropShadow(x, b, d); } this.addListeners(x, this.donutDataLabels), Graphics.setAttrs(x.node, {
          'data:angle': u, 'data:startAngle': o, 'data:strokeWidth': this.strokeWidth, 'data:value': e[d],
        }); let m = { x: 0, y: 0 }; i.config.chart.type === 'pie' ? m = Utils.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, o + (h - o) / 2) : i.config.chart.type === 'donut' && (m = Utils.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, o + (h - o) / 2)), g.add(x); let v = 0; if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : ((v = (h - o) / this.fullAngle * i.config.chart.animations.speed) === 0 && (v = 1), this.animDur = v + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(x, {
          size: i.globals.radialSize, endAngle: h, startAngle: o, prevStartAngle: l, prevEndAngle: c, animateStartingPos: !0, i: d, animBeginArr: this.animBeginArr, dur: i.config.chart.animations.dynamicAnimation.speed,
        }) : this.animatePaths(x, {
          size: i.globals.radialSize, endAngle: h, startAngle: o, i: d, totalItems: t.length - 1, animBeginArr: this.animBeginArr, dur: v,
        }), i.config.plotOptions.pie.expandOnClick && x.click(this.pieClicked.bind(this, d)), i.config.dataLabels.enabled) {
          const y = m.x; const w = m.y; let k = `${100 * (h - o) / 360}%`; if (u !== 0 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[d]) {
            const C = i.config.dataLabels.formatter; void 0 !== C && (k = C(i.globals.seriesPercent[d][0], { seriesIndex: d, w: i })); const A = i.globals.dataLabels.style.colors[d]; const S = s.drawText({
              x: y, y: w, text: k, textAnchor: 'middle', fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, foreColor: A,
            }); if (i.config.dataLabels.dropShadow.enabled) { const L = i.config.dataLabels.dropShadow; a.dropShadow(S, L); }S.node.classList.add('apexcharts-pie-label'), i.config.chart.animations.animate && !1 === i.globals.resized && (S.node.classList.add('apexcharts-pie-label-delay'), S.node.style.animationDelay = `${i.config.chart.animations.speed / 940}s`), this.sliceLabels.push(S);
          }
        }
      } return n;
    },
  }, { key: 'addListeners', value(t, e) { const i = new Graphics(this.ctx); t.node.addEventListener('mouseenter', i.pathMouseEnter.bind(this, t)), t.node.addEventListener('mouseleave', i.pathMouseLeave.bind(this, t)), t.node.addEventListener('mouseleave', this.revertDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener('mousedown', i.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener('mouseenter', this.printDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener('mousedown', this.printDataLabelsInner.bind(this, t.node, e))); } }, { key: 'animatePaths', value(t, e) { const i = this.w; let a = e.endAngle - e.startAngle; let s = a; let r = e.startAngle; const n = e.startAngle; void 0 !== e.prevStartAngle && void 0 !== e.prevEndAngle && (r = e.prevEndAngle, s = e.prevEndAngle - e.prevStartAngle), e.i === i.config.series.length - 1 && (a + n > this.fullAngle ? e.endAngle -= (a + n) : a + n < this.fullAngle && (e.endAngle += (this.fullAngle - (a + n)))), a === this.fullAngle && (a = this.fullAngle - 0.01), this.animateArc(t, r, n, a, s, e); } }, {
    key: 'animateArc',
    value(t, e, i, a, s, r) {
      let n; const o = this; const l = this.w; const h = new Animations(this.ctx); const c = r.size; (isNaN(e) || isNaN(s)) && (e = i, s = a, r.dur = 0); let d = a; let g = i; const u = e - i; l.globals.dataChanged && r.shouldSetPrevPaths && (n = o.getPiePath({
        me: o, startAngle: g, angle: s, size: c,
      }), t.attr({ d: n })), r.dur !== 0 ? t.animate(r.dur, l.globals.easing, r.animBeginArr[r.i]).afterAll((function () { l.config.chart.type !== 'pie' && l.config.chart.type !== 'donut' || this.animate(300).attr({ 'stroke-width': l.config.stroke.width }), r.i === l.config.series.length - 1 && h.animationCompleted(t); })).during(((l) => {
        d = u + (a - u) * l, r.animateStartingPos && (d = s + (a - s) * l, g = e - s + (i - (e - s)) * l), n = o.getPiePath({
          me: o, startAngle: g, angle: d, size: c,
        }), t.node.setAttribute('data:pathOrig', n), t.attr({ d: n });
      })) : (n = o.getPiePath({
        me: o, startAngle: g, angle: a, size: c,
      }), r.isTrack || (l.globals.animationEnded = !0), t.node.setAttribute('data:pathOrig', n), t.attr({ d: n }));
    },
  }, {
    key: 'pieClicked',
    value(t) {
      let e; const i = this.w; const a = this.w.globals.radialSize + (i.config.plotOptions.pie.expandOnClick ? 4 : 0); const s = i.globals.dom.Paper.select('.apexcharts-'.concat(i.config.chart.type.toLowerCase(), '-slice-').concat(t)).members[0]; if (s.attr('data:pieClicked') !== 'true') {
        const r = i.globals.dom.baseEl.querySelectorAll('.apexcharts-pie-area'); Array.prototype.forEach.call(r, ((t) => { t.setAttribute('data:pieClicked', 'false'); const e = t.getAttribute('data:pathOrig'); t.setAttribute('d', e); })), s.attr('data:pieClicked', 'true'); const n = parseInt(s.attr('data:startAngle'), 10); const o = parseInt(s.attr('data:angle'), 10); e = this.getPiePath({
          me: this, startAngle: n, angle: o, size: a,
        }), o !== 360 && s.plot(e);
      } else { s.attr({ 'data:pieClicked': 'false' }), this.revertDataLabelsInner(s.node, this.donutDataLabels); const l = s.attr('data:pathOrig'); s.attr({ d: l }); }
    },
  }, {
    key: 'getChangedPath',
    value(t, e) {
      let i = ''; return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
        me: this, startAngle: t, angle: e - t, size: this.size,
      })), i;
    },
  }, { key: 'getPiePath', value(t) { const e = t.me; const i = t.startAngle; const a = t.angle; const s = t.size; const r = this.w; const n = i; const o = Math.PI * (n - 90) / 180; let l = a + i; Math.ceil(l) >= 360 && (l = 359.99); const h = Math.PI * (l - 90) / 180; const c = e.centerX + s * Math.cos(o); const d = e.centerY + s * Math.sin(o); const g = e.centerX + s * Math.cos(h); const u = e.centerY + s * Math.sin(h); const p = Utils.polarToCartesian(e.centerX, e.centerY, e.donutSize, l); const f = Utils.polarToCartesian(e.centerX, e.centerY, e.donutSize, n); const x = a > 180 ? 1 : 0; const b = ['M', c, d, 'A', s, s, 0, x, 1, g, u]; return r.config.chart.type === 'donut' ? [].concat(b, ['L', p.x, p.y, 'A', e.donutSize, e.donutSize, 0, x, 0, f.x, f.y, 'L', c, d, 'z']).join(' ') : r.config.chart.type === 'pie' ? [].concat(b, ['L', e.centerX, e.centerY, 'L', c, d]).join(' ') : [].concat(b).join(' '); } }, {
    key: 'renderInnerDataLabels',
    value(t, e) {
      const i = this.w; const a = new Graphics(this.ctx); const s = a.group({ class: 'apexcharts-datalabels-group', transform: 'translate('.concat(e.translateX ? e.translateX : 0, ', ').concat(e.translateY ? e.translateY : 0, ') scale(').concat(i.config.plotOptions.pie.customScale, ')') }); const r = t.total.show; s.node.style.opacity = e.opacity; let n; let o; const l = e.centerX; const h = e.centerY; n = void 0 === t.name.color ? i.globals.colors[0] : t.name.color, o = void 0 === t.value.color ? i.config.chart.foreColor : t.value.color; const c = t.value.formatter; let d = ''; let g = ''; if (r ? (n = t.total.color, g = t.total.label, d = t.total.formatter(i)) : i.globals.series.length === 1 && (d = c(i.globals.series[0], i), g = i.globals.seriesNames[0]), g && (g = t.name.formatter(g, t.total.show, i)), t.name.show) {
        const u = a.drawText({
          x: l, y: h + parseFloat(t.name.offsetY), text: g, textAnchor: 'middle', foreColor: n, fontSize: t.name.fontSize, fontFamily: t.name.fontFamily,
        }); u.node.classList.add('apexcharts-datalabel-label'), s.add(u);
      } if (t.value.show) {
        const p = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY; const f = a.drawText({
          x: l, y: h + p, text: d, textAnchor: 'middle', foreColor: o, fontSize: t.value.fontSize, fontFamily: t.value.fontFamily,
        }); f.node.classList.add('apexcharts-datalabel-value'), s.add(f);
      } return s;
    },
  }, { key: 'printInnerLabels', value(t, e, i, a) { let s; const r = this.w; a ? s = void 0 === t.name.color ? r.globals.colors[parseInt(a.parentNode.getAttribute('rel'), 10) - 1] : t.name.color : r.globals.series.length > 1 && t.total.show && (s = t.total.color); const n = r.globals.dom.baseEl.querySelector('.apexcharts-datalabel-label'); const o = r.globals.dom.baseEl.querySelector('.apexcharts-datalabel-value'); i = (0, t.value.formatter)(i, r), a || typeof t.total.formatter !== 'function' || (i = t.total.formatter(r)); const l = e === t.total.label; e = t.name.formatter(e, l, r), n !== null && (n.textContent = e), o !== null && (o.textContent = i), n !== null && (n.style.fill = s); } }, { key: 'printDataLabelsInner', value(t, e) { const i = this.w; const a = t.getAttribute('data:value'); const s = i.globals.seriesNames[parseInt(t.parentNode.getAttribute('rel'), 10) - 1]; i.globals.series.length > 1 && this.printInnerLabels(e, s, a, t); const r = i.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group'); r !== null && (r.style.opacity = 1); } }, { key: 'revertDataLabelsInner', value(t, e, i) { const a = this; const s = this.w; const r = s.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group'); if (e.total.show && s.globals.series.length > 1) this.printInnerLabels(e, e.total.label, e.total.formatter(s)); else { const n = document.querySelectorAll('.apexcharts-pie-area'); let o = !1; if (Array.prototype.forEach.call(n, ((t) => { t.getAttribute('data:pieClicked') === 'true' && (o = !0, a.printDataLabelsInner(t, e)); })), !o) if (s.globals.selectedDataPoints.length && s.globals.series.length > 1) if (s.globals.selectedDataPoints[0].length > 0) { const l = s.globals.selectedDataPoints[0]; const h = s.globals.dom.baseEl.querySelector('.apexcharts-'.concat(s.config.chart.type.toLowerCase(), '-slice-').concat(l)); this.printDataLabelsInner(h, e); } else r && s.globals.selectedDataPoints.length && s.globals.selectedDataPoints[0].length === 0 && (r.style.opacity = 0); else r && s.globals.series.length > 1 && (r.style.opacity = 0); } } }]), t;
}()); const Helpers$2 = (function () { function t(e) { _classCallCheck(this, t), this.w = e.w, this.lgCtx = e; } return _createClass(t, [{ key: 'getLegendStyles', value() { const t = document.createElement('style'); t.setAttribute('type', 'text/css'); const e = document.createTextNode('\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-left, .apexcharts-legend.position-top.apexcharts-align-left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-center, .apexcharts-legend.position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-right, .apexcharts-legend.position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }'); return t.appendChild(e), t; } }, { key: 'getLegendBBox', value() { const t = this.w.globals.dom.baseEl.querySelector('.apexcharts-legend').getBoundingClientRect(); const e = t.width; return { clwh: t.height, clww: e }; } }, { key: 'appendToForeignObject', value() { const t = this.w.globals; t.dom.elLegendForeign = document.createElementNS(t.SVGNS, 'foreignObject'); const e = t.dom.elLegendForeign; e.setAttribute('x', 0), e.setAttribute('y', 0), e.setAttribute('width', t.svgWidth), e.setAttribute('height', t.svgHeight), t.dom.elLegendWrap.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml'), e.appendChild(t.dom.elLegendWrap), e.appendChild(this.getLegendStyles()), t.dom.Paper.node.insertBefore(e, t.dom.elGraphical.node); } }, { key: 'toggleDataSeries', value(t, e) { const i = this; const a = this.w; if (a.globals.axisCharts || a.config.chart.type === 'radialBar') { a.globals.resized = !0; let s = null; let r = null; if (a.globals.risingSeries = [], a.globals.axisCharts ? (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), r = parseInt(s.getAttribute('data:realIndex'), 10)) : (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), r = parseInt(s.getAttribute('rel'), 10) - 1), e)[{ cs: a.globals.collapsedSeries, csi: a.globals.collapsedSeriesIndices }, { cs: a.globals.ancillaryCollapsedSeries, csi: a.globals.ancillaryCollapsedSeriesIndices }].forEach(((t) => { i.riseCollapsedSeries(t.cs, t.csi, r); })); else this.hideSeries({ seriesEl: s, realIndex: r }); } else { const n = a.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")); const o = a.config.chart.type; if (o === 'pie' || o === 'donut') { const l = a.config.plotOptions.pie.donut.labels; const h = new Graphics(this.lgCtx.ctx); const c = new Pie(this.lgCtx.ctx); h.pathMouseDown(n.members[0], null), c.printDataLabelsInner(n.members[0].node, l); }n.fire('click'); } } }, { key: 'hideSeries', value(t) { const e = t.seriesEl; const i = t.realIndex; const a = this.w; if (a.globals.axisCharts) { let s = !1; if (a.config.yaxis[i] && a.config.yaxis[i].show && a.config.yaxis[i].showAlways && (s = !0, a.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (a.globals.ancillaryCollapsedSeries.push({ index: i, data: a.config.series[i].data.slice(), type: e.parentNode.className.baseVal.split('-')[1] }), a.globals.ancillaryCollapsedSeriesIndices.push(i))), !s) { a.globals.collapsedSeries.push({ index: i, data: a.config.series[i].data.slice(), type: e.parentNode.className.baseVal.split('-')[1] }), a.globals.collapsedSeriesIndices.push(i); const r = a.globals.risingSeries.indexOf(i); a.globals.risingSeries.splice(r, 1); }a.config.series[i].data = []; } else a.globals.collapsedSeries.push({ index: i, data: a.config.series[i] }), a.globals.collapsedSeriesIndices.push(i), a.config.series[i] = 0; for (let n = e.childNodes, o = 0; o < n.length; o++)n[o].classList.contains('apexcharts-series-markers-wrap') && (n[o].classList.contains('apexcharts-hide') ? n[o].classList.remove('apexcharts-hide') : n[o].classList.add('apexcharts-hide')); a.globals.allSeriesCollapsed = a.globals.collapsedSeries.length === a.config.series.length, this.lgCtx.ctx.updateHelpers._updateSeries(a.config.series, a.config.chart.animations.dynamicAnimation.enabled); } }, { key: 'riseCollapsedSeries', value(t, e, i) { const a = this.w; if (t.length > 0) for (let s = 0; s < t.length; s++)t[s].index === i && (a.globals.axisCharts ? (a.config.series[i].data = t[s].data.slice(), t.splice(s, 1), e.splice(s, 1), a.globals.risingSeries.push(i)) : (a.config.series[i] = t[s].data, t.splice(s, 1), e.splice(s, 1), a.globals.risingSeries.push(i)), this.lgCtx.ctx.updateHelpers._updateSeries(a.config.series, a.config.chart.animations.dynamicAnimation.enabled)); } }]), t; }()); const Legend = (function () {
  function t(e, i) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new Helpers$2(this); } return _createClass(t, [{ key: 'init', value() { const t = this.w; const e = t.globals; const i = t.config; if ((i.legend.showForSingleSeries && e.series.length === 1 || this.isBarsDistributed || e.series.length > 1 || !e.axisCharts) && i.legend.show) { for (;e.dom.elLegendWrap.firstChild;)e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild); this.drawLegends(), Utils.isIE11() ? document.getElementsByTagName('head')[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), i.legend.position === 'bottom' || i.legend.position === 'top' ? this.legendAlignHorizontal() : i.legend.position !== 'right' && i.legend.position !== 'left' || this.legendAlignVertical(); } } }, {
    key: 'drawLegends',
    value() {
      const t = this.w; const e = t.config.legend.fontFamily; let i = t.globals.seriesNames; let a = t.globals.colors.slice(); if (t.config.chart.type === 'heatmap') { const s = t.config.plotOptions.heatmap.colorScale.ranges; i = s.map(((t) => (t.name ? t.name : `${t.from} - ${t.to}`))), a = s.map(((t) => t.color)); } else this.isBarsDistributed && (i = t.globals.labels.slice()); for (let r = t.globals.legendFormatter, n = t.config.legend.inverseOrder, o = n ? i.length - 1 : 0; n ? o >= 0 : o <= i.length - 1; n ? o-- : o++) {
        const l = r(i[o], { seriesIndex: o, w: t }); let h = !1; let c = !1; if (t.globals.collapsedSeries.length > 0) for (let d = 0; d < t.globals.collapsedSeries.length; d++)t.globals.collapsedSeries[d].index === o && (h = !0); if (t.globals.ancillaryCollapsedSeriesIndices.length > 0) for (let g = 0; g < t.globals.ancillaryCollapsedSeriesIndices.length; g++)t.globals.ancillaryCollapsedSeriesIndices[g] === o && (c = !0); const u = document.createElement('span'); u.classList.add('apexcharts-legend-marker'); const p = t.config.legend.markers.offsetX; const f = t.config.legend.markers.offsetY; const x = t.config.legend.markers.height; const b = t.config.legend.markers.width; const m = t.config.legend.markers.strokeWidth; const v = t.config.legend.markers.strokeColor; const y = t.config.legend.markers.radius; const w = u.style; w.background = a[o], w.color = a[o], t.config.legend.markers.fillColors && t.config.legend.markers.fillColors[o] && (w.background = t.config.legend.markers.fillColors[o]), w.height = Array.isArray(x) ? `${parseFloat(x[o])}px` : `${parseFloat(x)}px`, w.width = Array.isArray(b) ? `${parseFloat(b[o])}px` : `${parseFloat(b)}px`, w.left = Array.isArray(p) ? p[o] : p, w.top = Array.isArray(f) ? f[o] : f, w.borderWidth = Array.isArray(m) ? m[o] : m, w.borderColor = Array.isArray(v) ? v[o] : v, w.borderRadius = Array.isArray(y) ? `${parseFloat(y[o])}px` : `${parseFloat(y)}px`, t.config.legend.markers.customHTML && (Array.isArray(t.config.legend.markers.customHTML) ? u.innerHTML = t.config.legend.markers.customHTML[o]() : u.innerHTML = t.config.legend.markers.customHTML()), Graphics.setAttrs(u, { rel: o + 1, 'data:collapsed': h || c }), (h || c) && u.classList.add('apexcharts-inactive-legend'); const k = document.createElement('div'); const C = document.createElement('span'); C.classList.add('apexcharts-legend-text'), C.innerHTML = Array.isArray(l) ? l.join(' ') : l; let A = t.config.legend.labels.useSeriesColors ? t.globals.colors[o] : t.config.legend.labels.colors; A || (A = t.config.chart.foreColor), C.style.color = A, C.style.fontSize = `${parseFloat(t.config.legend.fontSize)}px`, C.style.fontFamily = e || t.config.chart.fontFamily, Graphics.setAttrs(C, {
          rel: o + 1, i: o, 'data:default-text': encodeURIComponent(l), 'data:collapsed': h || c,
        }), k.appendChild(u), k.appendChild(C); const S = new CoreUtils(this.ctx); if (!t.config.legend.showForZeroSeries)S.getSeriesTotalByIndex(o) === 0 && S.seriesHaveSameValues(o) && !S.isSeriesNull(o) && t.globals.collapsedSeriesIndices.indexOf(o) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(o) === -1 && k.classList.add('apexcharts-hidden-zero-series'); t.config.legend.showForNullSeries || S.isSeriesNull(o) && t.globals.collapsedSeriesIndices.indexOf(o) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(o) === -1 && k.classList.add('apexcharts-hidden-null-series'), t.globals.dom.elLegendWrap.appendChild(k), t.globals.dom.elLegendWrap.classList.add('apexcharts-align-'.concat(t.config.legend.horizontalAlign)), t.globals.dom.elLegendWrap.classList.add(`position-${t.config.legend.position}`), k.classList.add('apexcharts-legend-series'), k.style.margin = ''.concat(t.config.legend.itemMargin.vertical, 'px ').concat(t.config.legend.itemMargin.horizontal, 'px'), t.globals.dom.elLegendWrap.style.width = t.config.legend.width ? `${t.config.legend.width}px` : '', t.globals.dom.elLegendWrap.style.height = t.config.legend.height ? `${t.config.legend.height}px` : '', Graphics.setAttrs(k, { rel: o + 1, 'data:collapsed': h || c }), (h || c) && k.classList.add('apexcharts-inactive-legend'), t.config.legend.onItemClick.toggleDataSeries || k.classList.add('apexcharts-no-click');
      }t.config.chart.type !== 'heatmap' && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && t.globals.dom.elWrap.addEventListener('click', this.onLegendClick, !0), t.config.legend.onItemHover.highlightDataSeries && (t.globals.dom.elWrap.addEventListener('mousemove', this.onLegendHovered, !0), t.globals.dom.elWrap.addEventListener('mouseout', this.onLegendHovered, !0));
    },
  }, { key: 'setLegendWrapXY', value(t, e) { const i = this.w; const a = i.globals.dom.baseEl.querySelector('.apexcharts-legend'); const s = a.getBoundingClientRect(); let r = 0; let n = 0; if (i.config.legend.position === 'bottom')n += i.globals.svgHeight - s.height / 2; else if (i.config.legend.position === 'top') { const o = new Dimensions(this.ctx); const l = o.dimHelpers.getTitleSubtitleCoords('title').height; const h = o.dimHelpers.getTitleSubtitleCoords('subtitle').height; n = n + (l > 0 ? l - 10 : 0) + (h > 0 ? h - 10 : 0); }a.style.position = 'absolute', r = r + t + i.config.legend.offsetX, n = n + e + i.config.legend.offsetY, a.style.left = `${r}px`, a.style.top = `${n}px`, i.config.legend.position === 'bottom' ? (a.style.top = 'auto', a.style.bottom = `${5 + i.config.legend.offsetY}px`) : i.config.legend.position === 'right' && (a.style.left = 'auto', a.style.right = `${25 + i.config.legend.offsetX}px`); ['width', 'height'].forEach(((t) => { a.style[t] && (a.style[t] = `${parseInt(i.config.legend[t], 10)}px`); })); } }, { key: 'legendAlignHorizontal', value() { const t = this.w; t.globals.dom.baseEl.querySelector('.apexcharts-legend').style.right = 0; const e = this.legendHelpers.getLegendBBox(); const i = new Dimensions(this.ctx); const a = i.dimHelpers.getTitleSubtitleCoords('title'); const s = i.dimHelpers.getTitleSubtitleCoords('subtitle'); let r = 0; t.config.legend.position === 'bottom' ? r = -e.clwh / 1.8 : t.config.legend.position === 'top' && (r = a.height + s.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, r); } }, { key: 'legendAlignVertical', value() { const t = this.w; const e = this.legendHelpers.getLegendBBox(); let i = 0; t.config.legend.position === 'left' && (i = 20), t.config.legend.position === 'right' && (i = t.globals.svgWidth - e.clww - 10), this.setLegendWrapXY(i, 20); } }, { key: 'onLegendHovered', value(t) { const e = this.w; const i = t.target.classList.contains('apexcharts-legend-text') || t.target.classList.contains('apexcharts-legend-marker'); if (e.config.chart.type === 'heatmap' || this.isBarsDistributed) { if (i) { const a = parseInt(t.target.getAttribute('rel'), 10) - 1; this.ctx.events.fireEvent('legendHover', [this.ctx, a, this.w]), new Series(this.ctx).highlightRangeInSeries(t, t.target); } } else !t.target.classList.contains('apexcharts-inactive-legend') && i && new Series(this.ctx).toggleSeriesOnHover(t, t.target); } }, { key: 'onLegendClick', value(t) { if (t.target.classList.contains('apexcharts-legend-text') || t.target.classList.contains('apexcharts-legend-marker')) { const e = parseInt(t.target.getAttribute('rel'), 10) - 1; const i = t.target.getAttribute('data:collapsed') === 'true'; const a = this.w.config.chart.events.legendClick; typeof a === 'function' && a(this.ctx, e, this.w), this.ctx.events.fireEvent('legendClick', [this.ctx, e, this.w]); const s = this.w.config.legend.markers.onClick; typeof s === 'function' && t.target.classList.contains('apexcharts-legend-marker') && (s(this.ctx, e, this.w), this.ctx.events.fireEvent('legendMarkerClick', [this.ctx, e, this.w])), this.legendHelpers.toggleDataSeries(e, i); } } }]), t;
}()); const icoPan = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>'; const icoZoom = '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>'; const icoReset = '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'; const icoZoomIn = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'; const icoZoomOut = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'; const icoSelect = '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>'; const icoMenu = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>'; const Toolbar = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.ev = this.w.config.chart.events, this.localeValues = this.w.globals.locale.toolbar; } return _createClass(t, [{
    key: 'createToolbar',
    value() {
      const t = this.w; const e = document.createElement('div'); if (e.setAttribute('class', 'apexcharts-toolbar'), t.globals.dom.elWrap.appendChild(e), this.elZoom = document.createElement('div'), this.elZoomIn = document.createElement('div'), this.elZoomOut = document.createElement('div'), this.elPan = document.createElement('div'), this.elSelection = document.createElement('div'), this.elZoomReset = document.createElement('div'), this.elMenuIcon = document.createElement('div'), this.elMenu = document.createElement('div'), this.elCustomIcons = [], this.t = t.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (let i = 0; i < this.t.customIcons.length; i++) this.elCustomIcons.push(document.createElement('div')); this.elMenuItems = []; const a = []; this.t.zoomin && t.config.chart.zoom.enabled && a.push({
        el: this.elZoomIn, icon: typeof this.t.zoomin === 'string' ? this.t.zoomin : icoZoomIn, title: this.localeValues.zoomIn, class: 'apexcharts-zoom-in-icon',
      }), this.t.zoomout && t.config.chart.zoom.enabled && a.push({
        el: this.elZoomOut, icon: typeof this.t.zoomout === 'string' ? this.t.zoomout : icoZoomOut, title: this.localeValues.zoomOut, class: 'apexcharts-zoom-out-icon',
      }), this.t.zoom && t.config.chart.zoom.enabled && a.push({
        el: this.elZoom, icon: typeof this.t.zoom === 'string' ? this.t.zoom : icoZoom, title: this.localeValues.selectionZoom, class: t.globals.isTouchDevice ? 'apexcharts-element-hidden' : 'apexcharts-zoom-icon',
      }), this.t.selection && t.config.chart.selection.enabled && a.push({
        el: this.elSelection, icon: typeof this.t.selection === 'string' ? this.t.selection : icoSelect, title: this.localeValues.selection, class: t.globals.isTouchDevice ? 'apexcharts-element-hidden' : 'apexcharts-selection-icon',
      }), this.t.pan && t.config.chart.zoom.enabled && a.push({
        el: this.elPan, icon: typeof this.t.pan === 'string' ? this.t.pan : icoPan, title: this.localeValues.pan, class: t.globals.isTouchDevice ? 'apexcharts-element-hidden' : 'apexcharts-pan-icon',
      }), this.t.reset && t.config.chart.zoom.enabled && a.push({
        el: this.elZoomReset, icon: typeof this.t.reset === 'string' ? this.t.reset : icoReset, title: this.localeValues.reset, class: 'apexcharts-reset-zoom-icon',
      }), this.t.download && a.push({
        el: this.elMenuIcon, icon: typeof this.t.download === 'string' ? this.t.download : icoMenu, title: this.localeValues.menu, class: 'apexcharts-menu-icon',
      }); for (let s = 0; s < this.elCustomIcons.length; s++) {
        a.push({
          el: this.elCustomIcons[s], icon: this.t.customIcons[s].icon, title: this.t.customIcons[s].title, index: this.t.customIcons[s].index, class: `apexcharts-toolbar-custom-icon ${this.t.customIcons[s].class}`,
        });
      } a.forEach(((t, e) => { t.index && Utils.moveIndexInArray(a, e, t.index); })); for (let r = 0; r < a.length; r++)Graphics.setAttrs(a[r].el, { class: a[r].class, title: a[r].title }), a[r].el.innerHTML = a[r].icon, e.appendChild(a[r].el); e.appendChild(this.elMenu), Graphics.setAttrs(this.elMenu, { class: 'apexcharts-menu' }); for (let n = [{ name: 'exportSVG', title: this.localeValues.exportToSVG }, { name: 'exportPNG', title: this.localeValues.exportToPNG }, { name: 'exportCSV', title: this.localeValues.exportToCSV }], o = 0; o < n.length; o++) this.elMenuItems.push(document.createElement('div')), this.elMenuItems[o].innerHTML = n[o].title, Graphics.setAttrs(this.elMenuItems[o], { class: 'apexcharts-menu-item '.concat(n[o].name), title: n[o].title }), this.elMenu.appendChild(this.elMenuItems[o]); t.globals.zoomEnabled ? this.elZoom.classList.add('apexcharts-selected') : t.globals.panEnabled ? this.elPan.classList.add('apexcharts-selected') : t.globals.selectionEnabled && this.elSelection.classList.add('apexcharts-selected'), this.addToolbarEventListeners();
    },
  }, { key: 'addToolbarEventListeners', value() { const t = this; this.elZoomReset.addEventListener('click', this.handleZoomReset.bind(this)), this.elSelection.addEventListener('click', this.toggleSelection.bind(this)), this.elZoom.addEventListener('click', this.toggleZooming.bind(this)), this.elZoomIn.addEventListener('click', this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener('click', this.handleZoomOut.bind(this)), this.elPan.addEventListener('click', this.togglePanning.bind(this)), this.elMenuIcon.addEventListener('click', this.toggleMenu.bind(this)), this.elMenuItems.forEach(((e) => { e.classList.contains('exportSVG') ? e.addEventListener('click', t.downloadSVG.bind(t)) : e.classList.contains('exportPNG') ? e.addEventListener('click', t.downloadPNG.bind(t)) : e.classList.contains('exportCSV') && e.addEventListener('click', t.downloadCSV.bind(t)); })); for (let e = 0; e < this.t.customIcons.length; e++) this.elCustomIcons[e].addEventListener('click', this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w)); } }, { key: 'toggleSelection', value() { this.toggleOtherControls(), this.w.globals.selectionEnabled = !this.w.globals.selectionEnabled, this.elSelection.classList.contains('apexcharts-selected') ? this.elSelection.classList.remove('apexcharts-selected') : this.elSelection.classList.add('apexcharts-selected'); } }, { key: 'toggleZooming', value() { this.toggleOtherControls(), this.w.globals.zoomEnabled = !this.w.globals.zoomEnabled, this.elZoom.classList.contains('apexcharts-selected') ? this.elZoom.classList.remove('apexcharts-selected') : this.elZoom.classList.add('apexcharts-selected'); } }, { key: 'getToolbarIconsReference', value() { const t = this.w; this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector('.apexcharts-zoom-icon')), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector('.apexcharts-pan-icon')), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector('.apexcharts-selection-icon')); } }, { key: 'enableZooming', value() { this.toggleOtherControls(), this.w.globals.zoomEnabled = !0, this.elZoom && this.elZoom.classList.add('apexcharts-selected'), this.elPan && this.elPan.classList.remove('apexcharts-selected'); } }, { key: 'enablePanning', value() { this.toggleOtherControls(), this.w.globals.panEnabled = !0, this.elPan && this.elPan.classList.add('apexcharts-selected'), this.elZoom && this.elZoom.classList.remove('apexcharts-selected'); } }, { key: 'togglePanning', value() { this.toggleOtherControls(), this.w.globals.panEnabled = !this.w.globals.panEnabled, this.elPan.classList.contains('apexcharts-selected') ? this.elPan.classList.remove('apexcharts-selected') : this.elPan.classList.add('apexcharts-selected'); } }, { key: 'toggleOtherControls', value() { const t = this.w; t.globals.panEnabled = !1, t.globals.zoomEnabled = !1, t.globals.selectionEnabled = !1, this.getToolbarIconsReference(), this.elPan && this.elPan.classList.remove('apexcharts-selected'), this.elSelection && this.elSelection.classList.remove('apexcharts-selected'), this.elZoom && this.elZoom.classList.remove('apexcharts-selected'); } }, { key: 'handleZoomIn', value() { const t = this.w; const e = (t.globals.minX + t.globals.maxX) / 2; let i = (t.globals.minX + e) / 2; let a = (t.globals.maxX + e) / 2; t.config.xaxis.convertedCatToNumeric && (i = Math.floor(i), a = Math.floor(a)), t.globals.disableZoomIn || this.zoomUpdateOptions(i, a); } }, { key: 'handleZoomOut', value() { const t = this.w; if (!(t.config.xaxis.type === 'datetime' && new Date(t.globals.minX).getUTCFullYear() < 1e3)) { const e = (t.globals.minX + t.globals.maxX) / 2; let i = t.globals.minX - (e - t.globals.minX); let a = t.globals.maxX - (e - t.globals.maxX); t.config.xaxis.convertedCatToNumeric && (i = Math.floor(i), a = Math.floor(a)), t.globals.disableZoomOut || this.zoomUpdateOptions(i, a); } } }, { key: 'zoomUpdateOptions', value(t, e) { const i = this.w; if (!(i.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, e = i.globals.dataPoints), e - t < 2))) { let a = { min: t, max: e }; const s = this.getBeforeZoomRange(a); s && (a = s.xaxis); const r = { xaxis: a }; let n = Utils.clone(i.globals.initialConfig.yaxis); if (i.config.chart.zoom.autoScaleYaxis)n = new Range(this.ctx).autoScaleY(this.ctx, n, { xaxis: a }); i.config.chart.group || (r.yaxis = n), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(r, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a, n); } } }, { key: 'zoomCallback', value(t, e) { typeof this.ev.zoomed === 'function' && this.ev.zoomed(this.ctx, { xaxis: t, yaxis: e }); } }, { key: 'getBeforeZoomRange', value(t, e) { let i = null; return typeof this.ev.beforeZoom === 'function' && (i = this.ev.beforeZoom(this, { xaxis: t, yaxis: e })), i; } }, { key: 'toggleMenu', value() { const t = this; window.setTimeout((() => { t.elMenu.classList.contains('apexcharts-menu-open') ? t.elMenu.classList.remove('apexcharts-menu-open') : t.elMenu.classList.add('apexcharts-menu-open'); }), 0); } }, { key: 'downloadPNG', value() { new Exports(this.ctx).exportToPng(this.ctx); } }, { key: 'downloadSVG', value() { new Exports(this.ctx).exportToSVG(); } }, { key: 'downloadCSV', value() { const t = this.w; new Exports(this.ctx).exportToCSV({ series: t.config.series }); } }, { key: 'handleZoomReset', value(t) { const e = this; this.ctx.getSyncedCharts().forEach(((t) => { const i = t.w; i.globals.minX === i.globals.initialMinX && i.globals.maxX === i.globals.initialMaxX || (t.updateHelpers.revertDefaultAxisMinMax(), typeof i.config.chart.events.zoomed === 'function' && e.zoomCallback({ min: i.config.xaxis.min, max: i.config.xaxis.max }), i.globals.zoomed = !1, t.updateHelpers._updateSeries(i.globals.initialSeries, i.config.chart.animations.dynamicAnimation.enabled)); })); } }, { key: 'destroy', value() { this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null; } }]), t;
}()); const ZoomPanSelection = (function (t) {
  function e(t) { let i; return _classCallCheck(this, e), (i = _possibleConstructorReturn(this, _getPrototypeOf(e).call(this, t))).ctx = t, i.w = t.w, i.dragged = !1, i.graphics = new Graphics(i.ctx), i.eventList = ['mousedown', 'mouseleave', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'], i.clientX = 0, i.clientY = 0, i.startX = 0, i.endX = 0, i.dragX = 0, i.startY = 0, i.endY = 0, i.dragY = 0, i.moveDirection = 'none', i; } return _inherits(e, Toolbar), _createClass(e, [{
    key: 'init',
    value(t) {
      const e = this; const i = t.xyRatios; const a = this.w; const s = this; this.xyRatios = i, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a.globals.dom.baseEl.querySelector('.apexcharts-grid'), this.zoomRect.node.classList.add('apexcharts-zoom-rect'), this.selectionRect.node.classList.add('apexcharts-selection-rect'), a.globals.dom.elGraphical.add(this.zoomRect), a.globals.dom.elGraphical.add(this.selectionRect), a.config.chart.selection.type === 'x' ? this.slDraggableRect = this.selectionRect.draggable({
        minX: 0, minY: 0, maxX: a.globals.gridWidth, maxY: a.globals.gridHeight,
      }).on('dragmove', this.selectionDragging.bind(this, 'dragging')) : a.config.chart.selection.type === 'y' ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a.globals.gridWidth }).on('dragmove', this.selectionDragging.bind(this, 'dragging')) : this.slDraggableRect = this.selectionRect.draggable().on('dragmove', this.selectionDragging.bind(this, 'dragging')), this.preselectedSelection(), this.hoverArea = a.globals.dom.baseEl.querySelector(a.globals.chartClass), this.hoverArea.classList.add('apexcharts-zoomable'), this.eventList.forEach(((t) => { e.hoverArea.addEventListener(t, s.svgMouseEvents.bind(s, i), { capture: !1, passive: !0 }); }));
    },
  }, { key: 'destroy', value() { this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null; } }, { key: 'svgMouseEvents', value(t, e) { const i = this.w; const a = this; const s = this.ctx.toolbar; const r = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type; if (e.shiftKey ? (this.shiftWasPressed = !0, s.enablePanning()) : this.shiftWasPressed && (s.enableZooming(), this.shiftWasPressed = !1), !(e.target.classList.contains('apexcharts-selection-rect') || e.target.parentNode.classList.contains('apexcharts-toolbar'))) { if (a.clientX = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientX : e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX, a.clientY = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientY : e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY, e.type === 'mousedown' && e.which === 1) { const n = a.gridRect.getBoundingClientRect(); a.startX = a.clientX - n.left, a.startY = a.clientY - n.top, a.dragged = !1, a.w.globals.mousedown = !0; } if ((e.type === 'mousemove' && e.which === 1 || e.type === 'touchmove') && (a.dragged = !0, i.globals.panEnabled ? (i.globals.selection = null, a.w.globals.mousedown && a.panDragging({ context: a, zoomtype: r, xyRatios: t })) : (a.w.globals.mousedown && i.globals.zoomEnabled || a.w.globals.mousedown && i.globals.selectionEnabled) && (a.selection = a.selectionDrawing({ context: a, zoomtype: r }))), e.type === 'mouseup' || e.type === 'touchend' || e.type === 'mouseleave') { const o = a.gridRect.getBoundingClientRect(); a.w.globals.mousedown && (a.endX = a.clientX - o.left, a.endY = a.clientY - o.top, a.dragX = Math.abs(a.endX - a.startX), a.dragY = Math.abs(a.endY - a.startY), (i.globals.zoomEnabled || i.globals.selectionEnabled) && a.selectionDrawn({ context: a, zoomtype: r })), i.globals.panEnabled && a.delayedPanScrolled(), i.globals.zoomEnabled && a.hideSelectionRect(this.selectionRect), a.dragged = !1, a.w.globals.mousedown = !1; } this.makeSelectionRectDraggable(); } } }, {
    key: 'makeSelectionRectDraggable',
    value() {
      const t = this.w; if (this.selectionRect) {
        const e = this.selectionRect.node.getBoundingClientRect(); e.width > 0 && e.height > 0 && this.slDraggableRect.selectize().resize({
          constraint: {
            minX: 0, minY: 0, maxX: t.globals.gridWidth, maxY: t.globals.gridHeight,
          },
        }).on('resizing', this.selectionDragging.bind(this, 'resizing'));
      }
    },
  }, {
    key: 'preselectedSelection',
    value() {
      const t = this.w; const e = this.xyRatios; if (!t.globals.zoomEnabled) {
        if (void 0 !== t.globals.selection && t.globals.selection !== null) this.drawSelectionRect(t.globals.selection); else if (void 0 !== t.config.chart.selection.xaxis.min && void 0 !== t.config.chart.selection.xaxis.max) {
          const i = (t.config.chart.selection.xaxis.min - t.globals.minX) / e.xRatio; const a = {
            x: i, y: 0, width: t.globals.gridWidth - (t.globals.maxX - t.config.chart.selection.xaxis.max) / e.xRatio - i, height: t.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: !0,
          }; this.drawSelectionRect(a), this.makeSelectionRectDraggable(), typeof t.config.chart.events.selection === 'function' && t.config.chart.events.selection(this.ctx, { xaxis: { min: t.config.chart.selection.xaxis.min, max: t.config.chart.selection.xaxis.max }, yaxis: {} });
        }
      }
    },
  }, {
    key: 'drawSelectionRect',
    value(t) {
      const e = t.x; const i = t.y; let a = t.width; const s = t.height; const r = t.translateX; const n = t.translateY; const o = this.w; const l = this.zoomRect; const h = this.selectionRect; if (this.dragged || o.globals.selection !== null) {
        const c = { transform: `translate(${r}, ${n})` }; o.globals.zoomEnabled && this.dragged && (a < 0 && (a = 1), l.attr({
          x: e, y: i, width: a, height: s, fill: o.config.chart.zoom.zoomedArea.fill.color, 'fill-opacity': o.config.chart.zoom.zoomedArea.fill.opacity, stroke: o.config.chart.zoom.zoomedArea.stroke.color, 'stroke-width': o.config.chart.zoom.zoomedArea.stroke.width, 'stroke-opacity': o.config.chart.zoom.zoomedArea.stroke.opacity,
        }), Graphics.setAttrs(l.node, c)), o.globals.selectionEnabled && (h.attr({
          x: e, y: i, width: a > 0 ? a : 0, height: s > 0 ? s : 0, fill: o.config.chart.selection.fill.color, 'fill-opacity': o.config.chart.selection.fill.opacity, stroke: o.config.chart.selection.stroke.color, 'stroke-width': o.config.chart.selection.stroke.width, 'stroke-dasharray': o.config.chart.selection.stroke.dashArray, 'stroke-opacity': o.config.chart.selection.stroke.opacity,
        }), Graphics.setAttrs(h.node, c));
      }
    },
  }, {
    key: 'hideSelectionRect',
    value(t) {
      t && t.attr({
        x: 0, y: 0, width: 0, height: 0,
      });
    },
  }, {
    key: 'selectionDrawing',
    value(t) {
      const e = t.context; const i = t.zoomtype; const a = this.w; const s = e; const r = this.gridRect.getBoundingClientRect(); const n = s.startX - 1; const o = s.startY; let l = s.clientX - r.left - n; let h = s.clientY - r.top - o; let c = 0; let d = 0; let g = {}; return Math.abs(l + n) > a.globals.gridWidth ? l = a.globals.gridWidth - n : s.clientX - r.left < 0 && (l = n), n > s.clientX - r.left && (c = -(l = Math.abs(l))), o > s.clientY - r.top && (d = -(h = Math.abs(h))), g = i === 'x' ? {
        x: n, y: 0, width: l, height: a.globals.gridHeight, translateX: c, translateY: 0,
      } : i === 'y' ? {
        x: 0, y: o, width: a.globals.gridWidth, height: h, translateX: 0, translateY: d,
      } : {
        x: n, y: o, width: l, height: h, translateX: c, translateY: d,
      }, s.drawSelectionRect(g), s.selectionDragging('resizing'), g;
    },
  }, { key: 'selectionDragging', value(t, e) { const i = this; const a = this.w; const s = this.xyRatios; const r = this.selectionRect; let n = 0; t === 'resizing' && (n = 30), typeof a.config.chart.events.selection === 'function' && a.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout((() => { const t = i.gridRect.getBoundingClientRect(); const e = r.node.getBoundingClientRect(); const n = a.globals.xAxisScale.niceMin + (e.left - t.left) * s.xRatio; const o = a.globals.xAxisScale.niceMin + (e.right - t.left) * s.xRatio; const l = a.globals.yAxisScale[0].niceMin + (t.bottom - e.bottom) * s.yRatio[0]; const h = a.globals.yAxisScale[0].niceMax - (e.top - t.top) * s.yRatio[0]; a.config.chart.events.selection(i.ctx, { xaxis: { min: n, max: o }, yaxis: { min: l, max: h } }); }), n)); } }, { key: 'selectionDrawn', value(t) { const e = t.context; const i = t.zoomtype; const a = this.w; const s = e; const r = this.xyRatios; const n = this.ctx.toolbar; if (s.startX > s.endX) { const o = s.startX; s.startX = s.endX, s.endX = o; } if (s.startY > s.endY) { const l = s.startY; s.startY = s.endY, s.endY = l; } let h = a.globals.xAxisScale.niceMin + s.startX * r.xRatio; let c = a.globals.xAxisScale.niceMin + s.endX * r.xRatio; const d = []; const g = []; if (a.config.yaxis.forEach(((t, e) => { d.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * s.startY), g.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * s.endY); })), s.dragged && (s.dragX > 10 || s.dragY > 10) && h !== c) if (a.globals.zoomEnabled) { let u = Utils.clone(a.globals.initialConfig.yaxis); a.globals.zoomed || (a.globals.lastXAxis = Utils.clone(a.config.xaxis), a.globals.lastYAxis = Utils.clone(a.config.yaxis)), a.config.xaxis.convertedCatToNumeric && (h = Math.floor(h), c = Math.floor(c), h < 1 && (h = 1, c = a.globals.dataPoints), c - h < 2 && (c = h + 1)); let p = { min: h, max: c }; if (i !== 'xy' && i !== 'y' || u.forEach(((t, e) => { u[e].min = g[e], u[e].max = d[e]; })), a.config.chart.zoom.autoScaleYaxis) { const f = new Range(s.ctx); u = f.autoScaleY(s.ctx, u, { xaxis: p }); } if (n) { const x = n.getBeforeZoomRange(p, u); x && (p = x.xaxis ? x.xaxis : p, u = x.yaxis ? x.yaxe : u); } const b = { xaxis: p }; a.config.chart.group || (b.yaxis = u), s.ctx.updateHelpers._updateOptions(b, !1, s.w.config.chart.animations.dynamicAnimation.enabled), typeof a.config.chart.events.zoomed === 'function' && n.zoomCallback(p, u), a.globals.zoomed = !0; } else if (a.globals.selectionEnabled) { let m; let v = null; m = { min: h, max: c }, i !== 'xy' && i !== 'y' || (v = Utils.clone(a.config.yaxis)).forEach(((t, e) => { v[e].min = g[e], v[e].max = d[e]; })), a.globals.selection = s.selection, typeof a.config.chart.events.selection === 'function' && a.config.chart.events.selection(s.ctx, { xaxis: m, yaxis: v }); } } }, { key: 'panDragging', value(t) { const e = t.context; const i = this.w; const a = e; if (void 0 !== i.globals.lastClientPosition.x) { const s = i.globals.lastClientPosition.x - a.clientX; const r = i.globals.lastClientPosition.y - a.clientY; Math.abs(s) > Math.abs(r) && s > 0 ? this.moveDirection = 'left' : Math.abs(s) > Math.abs(r) && s < 0 ? this.moveDirection = 'right' : Math.abs(r) > Math.abs(s) && r > 0 ? this.moveDirection = 'up' : Math.abs(r) > Math.abs(s) && r < 0 && (this.moveDirection = 'down'); }i.globals.lastClientPosition = { x: a.clientX, y: a.clientY }; const n = i.globals.minX; const o = i.globals.maxX; i.config.xaxis.convertedCatToNumeric && a.panScrolled(n, o); } }, { key: 'delayedPanScrolled', value() { const t = this.w; let e = t.globals.minX; let i = t.globals.maxX; const a = (t.globals.minX + t.globals.maxX) / 2; this.moveDirection === 'left' ? (e = t.globals.minX - a, i = t.globals.maxX - a) : this.moveDirection === 'right' && (e = t.globals.minX + a, i = t.globals.maxX + a), e = Math.floor(e), i = Math.floor(i), this.updateScrolledChart({ xaxis: { min: e, max: i } }, e, i); } }, { key: 'panScrolled', value(t, e) { const i = this.w; const a = this.xyRatios; let s = Utils.clone(i.globals.initialConfig.yaxis); this.moveDirection === 'left' ? (t = i.globals.minX + i.globals.gridWidth / 15 * a.xRatio, e = i.globals.maxX + i.globals.gridWidth / 15 * a.xRatio) : this.moveDirection === 'right' && (t = i.globals.minX - i.globals.gridWidth / 15 * a.xRatio, e = i.globals.maxX - i.globals.gridWidth / 15 * a.xRatio), (t < i.globals.initialMinX || e > i.globals.initialMaxX) && (t = i.globals.minX, e = i.globals.maxX); const r = { min: t, max: e }; i.config.chart.zoom.autoScaleYaxis && (s = new Range(this.ctx).autoScaleY(this.ctx, s, { xaxis: r })); const n = { xaxis: { min: t, max: e } }; i.config.chart.group || (n.yaxis = s), this.updateScrolledChart(n, t, e); } }, { key: 'updateScrolledChart', value(t, e, i) { const a = this.w; this.ctx.updateHelpers._updateOptions(t, !1, !1), typeof a.config.chart.events.scrolled === 'function' && a.config.chart.events.scrolled(this.ctx, { xaxis: { min: e, max: i } }); } }]), e;
}()); const Utils$1 = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx; } return _createClass(t, [{
    key: 'getNearestValues',
    value(t) {
      const e = t.hoverArea; const i = t.elGrid; const a = t.clientX; const s = t.clientY; const r = t.hasBars; const n = this.w; const o = n.globals.gridWidth; let l = o / (n.globals.dataPoints - 1); const h = i.getBoundingClientRect(); (r && n.globals.comboCharts || r) && (l = o / n.globals.dataPoints); const c = a - h.left; const d = s - h.top; c < 0 || d < 0 || c > n.globals.gridWidth || d > n.globals.gridHeight ? (e.classList.remove('hovering-zoom'), e.classList.remove('hovering-pan')) : n.globals.zoomEnabled ? (e.classList.remove('hovering-pan'), e.classList.add('hovering-zoom')) : n.globals.panEnabled && (e.classList.remove('hovering-zoom'), e.classList.add('hovering-pan')); let g = Math.round(c / l); r && (g = Math.ceil(c / l), g -= 1); for (var u, p = null, f = null, x = [], b = 0; b < n.globals.seriesXvalues.length; b++)x.push([n.globals.seriesXvalues[b][0] - 1e-6].concat(n.globals.seriesXvalues[b])); return x = x.map(((t) => t.filter(((t) => t)))), u = n.globals.seriesYvalues.map(((t) => t.filter(((t) => Utils.isNumber(t))))), n.globals.isXNumeric && (p = (f = this.closestInMultiArray(c, d, x, u)).index, g = f.j, p !== null && (x = n.globals.seriesXvalues[p], g = (f = this.closestInArray(c, x)).index)), n.globals.capturedSeriesIndex = p === null ? -1 : p, n.globals.capturedDataPointIndex = g === null ? -1 : g, (!g || g < 1) && (g = 0), {
        capturedSeries: p, j: g, hoverX: c, hoverY: d,
      };
    },
  }, { key: 'closestInMultiArray', value(t, e, i, a) { const s = this.w; let r = 0; let n = null; let o = -1; s.globals.series.length > 1 ? r = this.getFirstActiveXArray(i) : n = 0; const l = a[r][0]; const h = i[r][0]; let c = Math.abs(t - h); let d = Math.abs(e - l); let g = d + c; return a.map(((s, r) => { s.map(((s, l) => { const h = Math.abs(e - a[r][l]); const u = Math.abs(t - i[r][l]); const p = u + h; p < g && (g = p, c = u, d = h, n = r, o = l); })); })), { index: n, j: o }; } }, { key: 'getFirstActiveXArray', value(t) { for (var e = 0, i = new CoreUtils(this.ctx), a = t.map(((t, e) => (t.length > 0 ? e : -1))), s = 0; s < a.length; s++) { const r = i.getSeriesTotalByIndex(s); if (a[s] !== -1 && r !== 0 && !i.seriesHaveSameValues(s)) { e = a[s]; break; } } return e; } }, { key: 'closestInArray', value(t, e) { for (var i = e[0], a = null, s = Math.abs(t - i), r = 0; r < e.length; r++) { const n = Math.abs(t - e[r]); n < s && (s = n, a = r); } return { index: a }; } }, { key: 'isXoverlap', value(t) { const e = []; const i = this.w.globals.seriesX.filter(((t) => void 0 !== t[0])); if (i.length > 0) for (let a = 0; a < i.length - 1; a++) void 0 !== i[a][t] && void 0 !== i[a + 1][t] && i[a][t] !== i[a + 1][t] && e.push('unEqual'); return e.length === 0; } }, { key: 'isInitialSeriesSameLen', value() { for (var t = !0, e = this.w.globals.initialSeries, i = 0; i < e.length - 1; i++) if (e[i].data.length !== e[i + 1].data.length) { t = !1; break; } return t; } }, { key: 'getBarsHeight', value(t) { return _toConsumableArray(t).reduce(((t, e) => t + e.getBBox().height), 0); } }, { key: 'toggleAllTooltipSeriesGroups', value(t) { const e = this.w; const i = this.ttCtx; i.allTooltipSeriesGroups.length === 0 && (i.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll('.apexcharts-tooltip-series-group')); for (let a = i.allTooltipSeriesGroups, s = 0; s < a.length; s++)t === 'enable' ? (a[s].classList.add('apexcharts-active'), a[s].style.display = e.config.tooltip.items.display) : (a[s].classList.remove('apexcharts-active'), a[s].style.display = 'none'); } }]), t;
}()); const Labels = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new Utils$1(e); } return _createClass(t, [{
    key: 'drawSeriesTexts',
    value(t) {
      const e = t.shared; const i = void 0 === e || e; const a = t.ttItems; const s = t.i; const r = void 0 === s ? 0 : s; const n = t.j; const o = void 0 === n ? null : n; const l = t.y1; const h = t.y2; void 0 !== this.w.config.tooltip.custom ? this.handleCustomTooltip({
        i: r, j: o, y1: l, y2: h,
      }) : this.toggleActiveInactiveSeries(i); const c = this.getValuesToPrint({ i: r, j: o }); this.printLabels({
        i: r, j: o, values: c, ttItems: a, shared: i,
      }); const d = this.ttCtx.getElTooltip(); this.ttCtx.tooltipRect.ttWidth = d.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = d.getBoundingClientRect().height;
    },
  }, {
    key: 'printLabels',
    value(t) {
      let e; const i = this; const a = t.i; const s = t.j; const r = t.values; const n = t.ttItems; const o = t.shared; const l = this.w; const h = r.xVal; const c = r.zVal; const d = r.xAxisTTVal; let g = ''; let u = l.globals.colors[a]; s !== null && l.config.plotOptions.bar.distributed && (u = l.globals.colors[s]); for (let p = function (t, r) {
          let p = i.getFormatters(a); g = i.getSeriesName({
            fn: p.yLbTitleFormatter, index: a, seriesIndex: a, j: s,
          }); const f = l.config.tooltip.inverseOrder ? r : t; if (l.globals.axisCharts) {
            const x = function (t) {
              return p.yLbFormatter(l.globals.series[t][s], {
                series: l.globals.series, seriesIndex: t, dataPointIndex: s, w: l,
              });
            }; o ? (p = i.getFormatters(f), g = i.getSeriesName({
              fn: p.yLbTitleFormatter, index: f, seriesIndex: a, j: s,
            }), u = l.globals.colors[f], e = x(f), (i.ttCtx.hasBars() && l.config.chart.stacked && l.globals.series[f][s] === 0 || void 0 === l.globals.series[f][s]) && (e = void 0)) : e = x(a);
          }s === null && (e = p.yLbFormatter(l.globals.series[a], l)), i.DOMHandling({
            i: a,
            t: f,
            ttItems: n,
            values: {
              val: e, xVal: h, xAxisTTVal: d, zVal: c,
            },
            seriesName: g,
            shared: o,
            pColor: u,
          });
        }, f = 0, x = l.globals.series.length - 1; f < l.globals.series.length; f++, x--)p(f, x);
    },
  }, { key: 'getFormatters', value(t) { let e; const i = this.w; let a = i.globals.yLabelFormatters[t]; return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (a = i.globals.ttVal[t] && i.globals.ttVal[t].formatter, e = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter) : (a = i.globals.ttVal.formatter, typeof i.globals.ttVal.title.formatter === 'function' && (e = i.globals.ttVal.title.formatter)) : e = i.config.tooltip.y.title.formatter, typeof a !== 'function' && (a = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function (t) { return t; }), typeof e !== 'function' && (e = function (t) { return t; }), { yLbFormatter: a, yLbTitleFormatter: e }; } }, {
    key: 'getSeriesName',
    value(t) {
      const e = t.fn; const i = t.index; const a = t.seriesIndex; const s = t.j; const r = this.w; return e(String(r.globals.seriesNames[i]), {
        series: r.globals.series, seriesIndex: a, dataPointIndex: s, w: r,
      });
    },
  }, { key: 'DOMHandling', value(t) { const e = t.i; const i = t.t; const a = t.ttItems; const s = t.values; const r = t.seriesName; const n = t.shared; let o = t.pColor; const l = this.w; const h = this.ttCtx; const c = s.val; const d = s.xVal; const g = s.xAxisTTVal; const u = s.zVal; let p = null; p = a[i].children, l.config.tooltip.fillSeriesColor && (a[i].style.backgroundColor = o, p[0].style.display = 'none'), h.showTooltipTitle && (h.tooltipTitle === null && (h.tooltipTitle = l.globals.dom.baseEl.querySelector('.apexcharts-tooltip-title')), h.tooltipTitle.innerHTML = d), h.blxaxisTooltip && (h.xaxisTooltipText.innerHTML = g !== '' ? g : d); const f = a[i].querySelector('.apexcharts-tooltip-text-label'); f && (f.innerHTML = r ? `${r}: ` : ''); const x = a[i].querySelector('.apexcharts-tooltip-text-value'); (x && (x.innerHTML = c), p[0] && p[0].classList.contains('apexcharts-tooltip-marker') && (l.config.tooltip.marker.fillColors && Array.isArray(l.config.tooltip.marker.fillColors) && (o = l.config.tooltip.marker.fillColors[e]), p[0].style.backgroundColor = o), l.config.tooltip.marker.show || (p[0].style.display = 'none'), u !== null) && (a[i].querySelector('.apexcharts-tooltip-text-z-label').innerHTML = l.config.tooltip.z.title, a[i].querySelector('.apexcharts-tooltip-text-z-value').innerHTML = void 0 !== u ? u : ''); n && p[0] && (c == null || l.globals.collapsedSeriesIndices.indexOf(i) > -1 ? p[0].parentNode.style.display = 'none' : p[0].parentNode.style.display = l.config.tooltip.items.display); } }, { key: 'toggleActiveInactiveSeries', value(t) { const e = this.w; if (t) this.tooltipUtil.toggleAllTooltipSeriesGroups('enable'); else { this.tooltipUtil.toggleAllTooltipSeriesGroups('disable'); const i = e.globals.dom.baseEl.querySelector('.apexcharts-tooltip-series-group'); i && (i.classList.add('apexcharts-active'), i.style.display = e.config.tooltip.items.display); } } }, {
    key: 'getValuesToPrint',
    value(t) {
      const e = t.i; const i = t.j; const a = this.w; const s = this.ctx.series.filteredSeriesX(); let r = ''; let n = ''; let o = null; let l = null; const h = {
        series: a.globals.series, seriesIndex: e, dataPointIndex: i, w: a,
      }; const c = a.globals.ttZFormatter; i === null ? l = a.globals.series[e] : a.globals.isXNumeric ? (r = s[e][i], s[e].length === 0 && (r = s[this.tooltipUtil.getFirstActiveXArray(s)][i])) : r = void 0 !== a.globals.labels[i] ? a.globals.labels[i] : ''; const d = r; a.globals.isXNumeric && a.config.xaxis.type === 'datetime' ? r = new Formatters(this.ctx).xLabelFormat(a.globals.ttKeyFormatter, d, d) : a.globals.isBarHorizontal || (r = a.globals.xLabelFormatter(d, h)); return void 0 !== a.config.tooltip.x.formatter && (r = a.globals.ttKeyFormatter(d, h)), a.globals.seriesZ.length > 0 && a.globals.seriesZ[0].length > 0 && (o = c(a.globals.seriesZ[e][i], a)), n = typeof a.config.xaxis.tooltip.formatter === 'function' ? a.globals.xaxisTooltipFormatter(d, h) : r, {
        val: Array.isArray(l) ? l.join(' ') : l, xVal: Array.isArray(r) ? r.join(' ') : r, xAxisTTVal: Array.isArray(n) ? n.join(' ') : n, zVal: o,
      };
    },
  }, {
    key: 'handleCustomTooltip',
    value(t) {
      const e = t.i; const i = t.j; const a = t.y1; const s = t.y2; const r = this.w; const n = this.ttCtx.getElTooltip(); let o = r.config.tooltip.custom; Array.isArray(o) && o[e] && (o = o[e]), n.innerHTML = o({
        ctx: this.ctx, series: r.globals.series, seriesIndex: e, dataPointIndex: i, y1: a, y2: s, w: r,
      });
    },
  }]), t;
}()); const Position = (function () {
  function t(e) { _classCallCheck(this, t), this.ttCtx = e, this.ctx = e.ctx, this.w = e.w; } return _createClass(t, [{ key: 'moveXCrosshairs', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const i = this.ttCtx; const a = this.w; const s = i.getElXCrosshairs(); let r = t - i.xcrosshairsWidth / 2; const n = a.globals.labels.slice().length; if (e !== null && (r = a.globals.gridWidth / n * e), s !== null && (s.setAttribute('x', r), s.setAttribute('x1', r), s.setAttribute('x2', r), s.setAttribute('y2', a.globals.gridHeight), s.classList.add('apexcharts-active')), r < 0 && (r = 0), r > a.globals.gridWidth && (r = a.globals.gridWidth), i.blxaxisTooltip) { let o = r; a.config.xaxis.crosshairs.width !== 'tickWidth' && a.config.xaxis.crosshairs.width !== 'barWidth' || (o = r + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(o); } } }, { key: 'moveYCrosshairs', value(t) { const e = this.ttCtx; e.ycrosshairs !== null && (Graphics.setAttrs(e.ycrosshairs, { y1: t, y2: t }), Graphics.setAttrs(e.ycrosshairsHidden, { y1: t, y2: t })); } }, { key: 'moveXAxisTooltip', value(t) { const e = this.w; const i = this.ttCtx; if (i.xaxisTooltip !== null) { i.xaxisTooltip.classList.add('apexcharts-active'); const a = i.xaxisOffY + e.config.xaxis.tooltip.offsetY + e.globals.translateY + 1 + e.config.xaxis.offsetY; if (t -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t)) { t += e.globals.translateX; let s; s = new Graphics(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = `${s.width}px`, i.xaxisTooltip.style.left = `${t}px`, i.xaxisTooltip.style.top = `${a}px`; } } } }, { key: 'moveYAxisTooltip', value(t) { const e = this.w; const i = this.ttCtx; i.yaxisTTEls === null && (i.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip')); const a = parseInt(i.ycrosshairsHidden.getAttribute('y1'), 10); let s = e.globals.translateY + a; const r = i.yaxisTTEls[t].getBoundingClientRect().height; let n = e.globals.translateYAxisX[t] - 2; e.config.yaxis[t].opposite && (n -= 26), s -= r / 2, e.globals.ignoreYAxisIndexes.indexOf(t) === -1 ? (i.yaxisTTEls[t].classList.add('apexcharts-active'), i.yaxisTTEls[t].style.top = `${s}px`, i.yaxisTTEls[t].style.left = `${n + e.config.yaxis[t].tooltip.offsetX}px`) : i.yaxisTTEls[t].classList.remove('apexcharts-active'); } }, { key: 'moveTooltip', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const a = this.w; const s = this.ttCtx; const r = s.getElTooltip(); const n = s.tooltipRect; const o = i !== null ? parseFloat(i) : 1; let l = parseFloat(t) + o + 5; let h = parseFloat(e) + o / 2; if (l > a.globals.gridWidth / 2 && (l = l - n.ttWidth - o - 15), l > a.globals.gridWidth - n.ttWidth - 10 && (l = a.globals.gridWidth - n.ttWidth), l < -20 && (l = -20), a.config.tooltip.followCursor) { const c = s.getElGrid(); const d = c.getBoundingClientRect(); h = s.e.clientY + a.globals.translateY - d.top - n.ttHeight / 2; } const g = this.positionChecks(n, l, h); l = g.x, h = g.y, isNaN(l) || (l += a.globals.translateX, r.style.left = `${l}px`, r.style.top = `${h}px`); } }, { key: 'positionChecks', value(t, e, i) { const a = this.w; return t.ttHeight + i > a.globals.gridHeight && (i = a.globals.gridHeight - t.ttHeight + a.globals.translateY), i < 0 && (i = 0), { x: e, y: i }; } }, { key: 'moveMarkers', value(t, e) { const i = this.w; const a = this.ttCtx; if (i.globals.markers.size[t] > 0) for (let s = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), r = 0; r < s.length; r++)parseInt(s[r].getAttribute('rel'), 10) === e && (a.marker.resetPointsSize(), a.marker.enlargeCurrentPoint(e, s[r])); else a.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t); } }, { key: 'moveDynamicPointOnHover', value(t, e) { let i; let a; const s = this.w; const r = this.ttCtx; const n = s.globals.pointsArray; let o = s.config.markers.hover.size; if (void 0 === o && (o = s.globals.markers.size[e] + s.config.markers.hover.sizeOffset), !s.config.series[e].type || s.config.series[e].type !== 'column' && s.config.series[e].type !== 'candlestick') { i = n[e][t][0], a = n[e][t][1] ? n[e][t][1] : 0; const l = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle")); l && (l.setAttribute('r', o), l.setAttribute('cx', i), l.setAttribute('cy', a)), this.moveXCrosshairs(i), r.fixedTooltip || this.moveTooltip(i, a, o); } } }, { key: 'moveDynamicPointsOnHover', value(t) { let e; const i = this.ttCtx; const a = i.w; let s = 0; let r = 0; const n = a.globals.pointsArray; e = new Series(this.ctx).getActiveSeriesIndex(); let o = a.config.markers.hover.size; void 0 === o && (o = a.globals.markers.size[e] + a.config.markers.hover.sizeOffset), n[e] && (s = n[e][t][0], r = n[e][t][1]); let l = null; const h = i.getAllMarkers(); if ((l = h !== null ? h : a.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers circle')) !== null) for (let c = 0; c < a.globals.series.length; c++) { const d = n[c]; if (a.globals.comboCharts && void 0 === d && (l = _toConsumableArray(l)).splice(c, 0, null), d && d.length) { const g = n[c][t][1]; l[c].setAttribute('cx', s); const u = parseInt(l[c].parentNode.parentNode.parentNode.getAttribute('data:realIndex'), 10); g === null || isNaN(g) ? l[u] && l[u].setAttribute('r', 0) : (l[u] && l[u].setAttribute('r', o), l[u] && l[u].setAttribute('cy', g)); } } if (this.moveXCrosshairs(s), !i.fixedTooltip) { const p = r || a.globals.gridHeight; this.moveTooltip(s, p, o); } } }, {
    key: 'moveStickyTooltipOverBars',
    value(t) {
      let e; const i = this.w; const a = this.ttCtx; const s = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length; const r = s >= 2 && s % 2 == 0 ? Math.floor(s / 2) : Math.floor(s / 2) + 1; const n = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='")
        .concat(r, "'] path[j='")
        .concat(t, "']")); let o = n ? parseFloat(n.getAttribute('cx')) : 0; const l = n ? parseFloat(n.getAttribute('barWidth')) : 0; i.globals.isXNumeric ? o -= s % 2 != 0 ? l / 2 : 0 : (o = a.xAxisTicksPositions[t - 1] + a.dataPointsDividedWidth / 2, isNaN(o) && (o = a.xAxisTicksPositions[t] - a.dataPointsDividedWidth / 2)); const h = a.getElGrid().getBoundingClientRect(); if (e = a.e.clientY - h.top - a.tooltipRect.ttHeight / 2, this.moveXCrosshairs(o), !a.fixedTooltip) { const c = e || i.globals.gridHeight; this.moveTooltip(o, c); }
    },
  }]), t;
}()); const Marker = (function () { function t(e) { _classCallCheck(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new Position(e); } return _createClass(t, [{ key: 'drawDynamicPoints', value() { for (let t = this.w, e = new Graphics(this.ctx), i = new Markers(this.ctx), a = t.globals.dom.baseEl.querySelectorAll('.apexcharts-series'), s = 0; s < a.length; s++) { const r = parseInt(a[s].getAttribute('data:realIndex'), 10); const n = t.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(r, "'] .apexcharts-series-markers-wrap")); if (n !== null) { let o = void 0; let l = 'apexcharts-marker w'.concat((Math.random() + 1).toString(36).substring(4)); t.config.chart.type !== 'line' && t.config.chart.type !== 'area' || t.globals.comboCharts || t.config.tooltip.intersect || (l += ' no-pointer-events'); const h = i.getMarkerConfig(l, r); (o = e.drawMarker(0, 0, h)).node.setAttribute('default-marker-size', 0); const c = document.createElementNS(t.globals.SVGNS, 'g'); c.classList.add('apexcharts-series-markers'), c.appendChild(o.node), n.appendChild(c); } } } }, { key: 'enlargeCurrentPoint', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; const s = this.w; s.config.chart.type !== 'bubble' && this.newPointSize(t, e); let r = e.getAttribute('cx'); let n = e.getAttribute('cy'); if (i !== null && a !== null && (r = i, n = a), this.tooltipPosition.moveXCrosshairs(r), !this.fixedTooltip) { if (s.config.chart.type === 'radar') { const o = this.ttCtx.getElGrid(); const l = o.getBoundingClientRect(); r = this.ttCtx.e.clientX - l.left; } this.tooltipPosition.moveTooltip(r, n, s.config.markers.hover.size); } } }, { key: 'enlargePoints', value(t) { for (let e = this.w, i = this.ttCtx, a = t, s = e.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker'), r = e.config.markers.hover.size, n = 0; n < s.length; n++) { const o = s[n].getAttribute('rel'); const l = s[n].getAttribute('index'); if (void 0 === r && (r = e.globals.markers.size[l] + e.config.markers.hover.sizeOffset), a === parseInt(o, 10)) { this.newPointSize(a, s[n]); const h = s[n].getAttribute('cx'); const c = s[n].getAttribute('cy'); this.tooltipPosition.moveXCrosshairs(h), i.fixedTooltip || this.tooltipPosition.moveTooltip(h, c, r); } else this.oldPointSize(s[n]); } } }, { key: 'newPointSize', value(t, e) { const i = this.w; let a = i.config.markers.hover.size; const s = t === 0 ? e.parentNode.firstChild : e.parentNode.lastChild; if (s.getAttribute('default-marker-size') !== '0') { const r = parseInt(s.getAttribute('index'), 10); void 0 === a && (a = i.globals.markers.size[r] + i.config.markers.hover.sizeOffset), s.setAttribute('r', a); } } }, { key: 'oldPointSize', value(t) { const e = parseFloat(t.getAttribute('default-marker-size')); t.setAttribute('r', e); } }, { key: 'resetPointsSize', value() { for (let t = this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker'), e = 0; e < t.length; e++) { const i = parseFloat(t[e].getAttribute('default-marker-size')); Utils.isNumber(i) ? t[e].setAttribute('r', i) : t[e].setAttribute('r', 0); } } }]), t; }()); const Intersect = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.ttCtx = e; } return _createClass(t, [{ key: 'getAttr', value(t, e) { return parseFloat(t.target.getAttribute(e)); } }, {
    key: 'handleHeatTooltip',
    value(t) {
      const { e } = t; const i = t.opt; let a = t.x; let s = t.y; const r = this.ttCtx; const
        n = this.w; if (e.target.classList.contains('apexcharts-heatmap-rect')) {
        const o = this.getAttr(e, 'i'); const l = this.getAttr(e, 'j'); const h = this.getAttr(e, 'cx'); const c = this.getAttr(e, 'cy'); const d = this.getAttr(e, 'width'); const g = this.getAttr(e, 'height'); if (r.tooltipLabels.drawSeriesTexts({
          ttItems: i.ttItems, i: o, j: l, shared: !1,
        }), n.globals.capturedSeriesIndex = o, n.globals.capturedDataPointIndex = l, a = h + r.tooltipRect.ttWidth / 2 + d, s = c + r.tooltipRect.ttHeight / 2 - g / 2, r.tooltipPosition.moveXCrosshairs(h + d / 2), a > n.globals.gridWidth / 2 && (a = h - r.tooltipRect.ttWidth / 2 + d), r.w.config.tooltip.followCursor) { const u = r.getElGrid().getBoundingClientRect(); s = r.e.clientY - u.top + n.globals.translateY / 2 - 10; }
      } return { x: a, y: s };
    },
  }, {
    key: 'handleMarkerTooltip',
    value(t) {
      let e; let i; const a = t.e; const s = t.opt; let r = t.x; let n = t.y; const o = this.w; const l = this.ttCtx; if (a.target.classList.contains('apexcharts-marker')) {
        const h = parseInt(s.paths.getAttribute('cx'), 10); const c = parseInt(s.paths.getAttribute('cy'), 10); const d = parseFloat(s.paths.getAttribute('val')); if (i = parseInt(s.paths.getAttribute('rel'), 10), e = parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute('rel'), 10) - 1, l.intersect) { const g = Utils.findAncestor(s.paths, 'apexcharts-series'); g && (e = parseInt(g.getAttribute('data:realIndex'), 10)); } if (l.tooltipLabels.drawSeriesTexts({
          ttItems: s.ttItems, i: e, j: i, shared: !l.showOnIntersect && o.config.tooltip.shared,
        }), a.type === 'mouseup' && l.markerClick(a, e, i), o.globals.capturedSeriesIndex = e, o.globals.capturedDataPointIndex = i, r = h, n = c + o.globals.translateY - 1.4 * l.tooltipRect.ttHeight, l.w.config.tooltip.followCursor) { const u = l.getElGrid().getBoundingClientRect(); n = l.e.clientY + o.globals.translateY - u.top; }d < 0 && (n = c), l.marker.enlargeCurrentPoint(i, s.paths, r, n);
      } return { x: r, y: n };
    },
  }, { key: 'handleBarTooltip', value(t) { let e; let i; const a = t.e; const s = t.opt; const r = this.w; const n = this.ttCtx; const o = n.getElTooltip(); let l = 0; let h = 0; let c = 0; const d = this.getBarTooltipXY({ e: a, opt: s }); e = d.i; const g = d.barHeight; const u = d.j; if (r.globals.capturedSeriesIndex = e, r.globals.capturedDataPointIndex = u, r.globals.isBarHorizontal && n.hasBars() || !r.config.tooltip.shared ? (h = d.x, c = d.y, i = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[e] : r.config.stroke.width, l = h) : r.globals.comboCharts || r.config.tooltip.shared || (l /= 2), isNaN(c) && (c = r.globals.svgHeight - n.tooltipRect.ttHeight), h + n.tooltipRect.ttWidth > r.globals.gridWidth ? h -= n.tooltipRect.ttWidth : h < 0 && (h += n.tooltipRect.ttWidth), n.w.config.tooltip.followCursor) { const p = n.getElGrid().getBoundingClientRect(); c = n.e.clientY - p.top; } if (n.tooltip === null && (n.tooltip = r.globals.dom.baseEl.querySelector('.apexcharts-tooltip')), r.config.tooltip.shared || (r.globals.comboBarCount > 0 ? n.tooltipPosition.moveXCrosshairs(l + i / 2) : n.tooltipPosition.moveXCrosshairs(l)), !n.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && n.hasBars())) { const f = r.globals.isMultipleYAxis ? r.config.yaxis[x] && r.config.yaxis[x].reversed : r.config.yaxis[0].reversed; f && (h = r.globals.gridWidth - h), o.style.left = `${h + r.globals.translateX}px`; var x = parseInt(s.paths.parentNode.getAttribute('data:realIndex'), 10); !f || r.globals.isBarHorizontal && n.hasBars() || (c = c + g - 2 * (r.globals.series[e][u] < 0 ? g : 0)), n.tooltipRect.ttHeight + c > r.globals.gridHeight ? (c = r.globals.gridHeight - n.tooltipRect.ttHeight + r.globals.translateY, o.style.top = `${c}px`) : o.style.top = `${c + r.globals.translateY - n.tooltipRect.ttHeight / 2}px`; } } }, {
    key: 'getBarTooltipXY',
    value(t) {
      const { e } = t; const i = t.opt; const a = this.w; let s = null; const r = this.ttCtx; let n = 0; let o = 0; let l = 0; let h = 0; let c = 0; const
        d = e.target.classList; if (d.contains('apexcharts-bar-area') || d.contains('apexcharts-candlestick-area') || d.contains('apexcharts-rangebar-area')) {
        const g = e.target; const u = g.getBoundingClientRect(); const p = i.elGrid.getBoundingClientRect(); const f = u.height; c = u.height; const x = u.width; const b = parseInt(g.getAttribute('cx'), 10); const m = parseInt(g.getAttribute('cy'), 10); h = parseFloat(g.getAttribute('barWidth')); const v = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX; s = parseInt(g.getAttribute('j'), 10), n = parseInt(g.parentNode.getAttribute('rel'), 10) - 1; const y = g.getAttribute('data-range-y1'); const w = g.getAttribute('data-range-y2'); a.globals.comboCharts && (n = parseInt(g.parentNode.getAttribute('data:realIndex'), 10)), r.tooltipLabels.drawSeriesTexts({
          ttItems: i.ttItems, i: n, j: s, y1: y ? parseInt(y, 10) : null, y2: w ? parseInt(w, 10) : null, shared: !r.showOnIntersect && a.config.tooltip.shared,
        }), a.config.tooltip.followCursor ? a.globals.isBarHorizontal ? (o = v - p.left + 15, l = m - r.dataPointsDividedHeight + f / 2 - r.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? b - x / 2 : b - r.dataPointsDividedWidth + x / 2, l = e.clientY - p.top - r.tooltipRect.ttHeight / 2 - 15) : a.globals.isBarHorizontal ? ((o = b) < r.xyRatios.baseLineInvertedY && (o = b - r.tooltipRect.ttWidth), l = m - r.dataPointsDividedHeight + f / 2 - r.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? b - x / 2 : b - r.dataPointsDividedWidth + x / 2, l = m);
      } return {
        x: o, y: l, barHeight: c, barWidth: h, i: n, j: s,
      };
    },
  }]), t;
}()); const AxesTooltip = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.ttCtx = e; } return _createClass(t, [{
    key: 'drawXaxisTooltip',
    value() {
      const t = this.w; const e = this.ttCtx; const i = t.config.xaxis.position === 'bottom'; e.xaxisOffY = i ? t.globals.gridHeight + 1 : 1; const a = i ? 'apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom' : 'apexcharts-xaxistooltip apexcharts-xaxistooltip-top'; const
        s = t.globals.dom.elWrap; e.blxaxisTooltip && (t.globals.dom.baseEl.querySelector('.apexcharts-xaxistooltip') === null && (e.xaxisTooltip = document.createElement('div'), e.xaxisTooltip.setAttribute('class', `${a} apexcharts-theme-${t.config.tooltip.theme}`), s.appendChild(e.xaxisTooltip), e.xaxisTooltipText = document.createElement('div'), e.xaxisTooltipText.classList.add('apexcharts-xaxistooltip-text'), e.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, e.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, e.xaxisTooltip.appendChild(e.xaxisTooltipText)));
    },
  }, { key: 'drawYaxisTooltip', value() { for (var t = this.w, e = this.ttCtx, i = function (i) { const a = t.config.yaxis[i].opposite || t.config.yaxis[i].crosshairs.opposite; e.yaxisOffX = a ? t.globals.gridWidth + 1 : 1; let s = 'apexcharts-yaxistooltip apexcharts-yaxistooltip-'.concat(i, a ? ' apexcharts-yaxistooltip-right' : ' apexcharts-yaxistooltip-left'); t.globals.yAxisSameScaleIndices.map(((e, a) => { e.map(((e, a) => { a === i && (s += t.config.yaxis[a].show ? ' ' : ' apexcharts-yaxistooltip-hidden'); })); })); const r = t.globals.dom.elWrap; e.blyaxisTooltip && (t.globals.dom.baseEl.querySelector('.apexcharts-yaxistooltip apexcharts-yaxistooltip-'.concat(i)) === null && (e.yaxisTooltip = document.createElement('div'), e.yaxisTooltip.setAttribute('class', `${s} apexcharts-theme-${t.config.tooltip.theme}`), r.appendChild(e.yaxisTooltip), i === 0 && (e.yaxisTooltipText = []), e.yaxisTooltipText.push(document.createElement('div')), e.yaxisTooltipText[i].classList.add('apexcharts-yaxistooltip-text'), e.yaxisTooltip.appendChild(e.yaxisTooltipText[i]))); }, a = 0; a < t.config.yaxis.length; a++)i(a); } }, { key: 'setXCrosshairWidth', value() { const t = this.w; const e = this.ttCtx; const i = e.getElXCrosshairs(); if (e.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) { const a = t.globals.dom.baseEl.querySelector('.apexcharts-bar-area'); if (a !== null && t.config.xaxis.crosshairs.width === 'barWidth') { const s = parseFloat(a.getAttribute('barWidth')); e.xcrosshairsWidth = s; } else if (t.config.xaxis.crosshairs.width === 'tickWidth') { const r = t.globals.labels.length; e.xcrosshairsWidth = t.globals.gridWidth / r; } } else if (t.config.xaxis.crosshairs.width === 'tickWidth') { const n = t.globals.labels.length; e.xcrosshairsWidth = t.globals.gridWidth / n; } else if (t.config.xaxis.crosshairs.width === 'barWidth') { const o = t.globals.dom.baseEl.querySelector('.apexcharts-bar-area'); if (o !== null) { const l = parseFloat(o.getAttribute('barWidth')); e.xcrosshairsWidth = l; } else e.xcrosshairsWidth = 1; }t.globals.isBarHorizontal && (e.xcrosshairsWidth = 0), i !== null && e.xcrosshairsWidth > 0 && i.setAttribute('width', e.xcrosshairsWidth); } }, { key: 'handleYCrosshair', value() { const t = this.w; const e = this.ttCtx; e.ycrosshairs = t.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs'), e.ycrosshairsHidden = t.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs-hidden'); } }, { key: 'drawYaxisTooltipText', value(t, e, i) { const a = this.ttCtx; const s = this.w; const r = s.globals.yLabelFormatters[t]; if (a.blyaxisTooltip) { const n = a.getElGrid().getBoundingClientRect(); const o = (e - n.top) * i.yRatio[t]; const l = s.globals.maxYArr[t] - s.globals.minYArr[t]; const h = s.globals.minYArr[t] + (l - o); a.tooltipPosition.moveYCrosshairs(e - n.top), a.yaxisTooltipText[t].innerHTML = r(h), a.tooltipPosition.moveYAxisTooltip(t); } } }]), t;
}()); const Tooltip = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; const i = this.w; this.tConfig = i.config.tooltip, this.tooltipUtil = new Utils$1(this), this.tooltipLabels = new Labels(this), this.tooltipPosition = new Position(this), this.marker = new Marker(this), this.intersect = new Intersect(this), this.axesTooltip = new AxesTooltip(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i.globals.isBarHorizontal && this.tConfig.shared; } return _createClass(t, [{ key: 'getElTooltip', value(t) { return t || (t = this), t.w.globals.dom.baseEl.querySelector('.apexcharts-tooltip'); } }, { key: 'getElXCrosshairs', value() { return this.w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs'); } }, { key: 'getElGrid', value() { return this.w.globals.dom.baseEl.querySelector('.apexcharts-grid'); } }, { key: 'drawTooltip', value(t) { const e = this.w; this.xyRatios = t, this.blxaxisTooltip = e.config.xaxis.tooltip.enabled && e.globals.axisCharts, this.blyaxisTooltip = e.config.yaxis[0].tooltip.enabled && e.globals.axisCharts, this.allTooltipSeriesGroups = [], e.globals.axisCharts || (this.showTooltipTitle = !1); const i = document.createElement('div'); if (i.classList.add('apexcharts-tooltip'), i.classList.add('apexcharts-theme-'.concat(this.tConfig.theme)), e.globals.dom.elWrap.appendChild(i), e.globals.axisCharts) { this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair(); const a = new XAxis(this.ctx); this.xAxisTicksPositions = a.getXAxisTicksPositions(); } if ((e.globals.comboCharts && !this.tConfig.shared || this.tConfig.intersect && !this.tConfig.shared || (e.config.chart.type === 'bar' || e.config.chart.type === 'rangeBar') && !this.tConfig.shared) && (this.showOnIntersect = !0), e.config.markers.size !== 0 && e.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), e.globals.collapsedSeries.length !== e.globals.series.length) { this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints, this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement('div'), this.tooltipTitle.classList.add('apexcharts-tooltip-title'), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle)); let s = e.globals.series.length; (e.globals.xyCharts || e.globals.comboCharts) && this.tConfig.shared && (s = this.showOnIntersect ? 1 : e.globals.series.length), this.legendLabels = e.globals.dom.baseEl.querySelectorAll('.apexcharts-legend-text'), this.ttItems = this.createTTElements(s), this.addSVGEvents(); } } }, { key: 'createTTElements', value(t) { for (var e = this.w, i = [], a = this.getElTooltip(), s = 0; s < t; s++) { const r = document.createElement('div'); r.classList.add('apexcharts-tooltip-series-group'), this.tConfig.shared && this.tConfig.enabledOnSeries && Array.isArray(this.tConfig.enabledOnSeries) && this.tConfig.enabledOnSeries.indexOf(s) < 0 && r.classList.add('apexcharts-tooltip-series-group-hidden'); const n = document.createElement('span'); n.classList.add('apexcharts-tooltip-marker'), n.style.backgroundColor = e.globals.colors[s], r.appendChild(n); const o = document.createElement('div'); o.classList.add('apexcharts-tooltip-text'), o.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, o.style.fontSize = this.tConfig.style.fontSize; const l = document.createElement('div'); l.classList.add('apexcharts-tooltip-y-group'); const h = document.createElement('span'); h.classList.add('apexcharts-tooltip-text-label'), l.appendChild(h); const c = document.createElement('span'); c.classList.add('apexcharts-tooltip-text-value'), l.appendChild(c); const d = document.createElement('div'); d.classList.add('apexcharts-tooltip-z-group'); const g = document.createElement('span'); g.classList.add('apexcharts-tooltip-text-z-label'), d.appendChild(g); const u = document.createElement('span'); u.classList.add('apexcharts-tooltip-text-z-value'), d.appendChild(u), o.appendChild(l), o.appendChild(d), r.appendChild(o), a.appendChild(r), i.push(r); } return i; } }, {
    key: 'addSVGEvents',
    value() {
      const t = this.w; const e = t.config.chart.type; const i = this.getElTooltip(); const a = !(e !== 'bar' && e !== 'candlestick' && e !== 'rangeBar'); const s = t.globals.dom.Paper.node; const r = this.getElGrid(); r && (this.seriesBound = r.getBoundingClientRect()); let n; const o = []; const l = []; const h = {
        hoverArea: s, elGrid: r, tooltipEl: i, tooltipY: o, tooltipX: l, ttItems: this.ttItems,
      }; if (t.globals.axisCharts && (e === 'area' || e === 'line' || e === 'scatter' || e === 'bubble' ? n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a ? n = t.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-rangebar-area') : e === 'heatmap' ? n = t.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-heatmap') : e === 'radar' && (n = t.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-marker')), n && n.length)) for (let c = 0; c < n.length; c++)o.push(n[c].getAttribute('cy')), l.push(n[c].getAttribute('cx')); if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || a && this.hasBars() && this.tConfig.shared) this.addPathsEventListeners([s], h); else if (a && !t.globals.comboCharts) this.addBarsEventListeners(h); else if (e === 'bubble' || e === 'scatter' || e === 'radar' || this.showOnIntersect && (e === 'area' || e === 'line')) this.addPointsEventsListeners(h); else if (!t.globals.axisCharts || e === 'heatmap') { const d = t.globals.dom.baseEl.querySelectorAll('.apexcharts-series'); this.addPathsEventListeners(d, h); } if (this.showOnIntersect) { const g = t.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-marker'); g.length > 0 && this.addPathsEventListeners(g, h); const u = t.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-marker'); u.length > 0 && this.addPathsEventListeners(u, h), this.hasBars() && !this.tConfig.shared && this.addBarsEventListeners(h); }
    },
  }, {
    key: 'drawFixedTooltipRect',
    value() {
      const t = this.w; const e = this.getElTooltip(); const i = e.getBoundingClientRect(); const a = i.width + 10; const s = i.height + 10; let r = this.tConfig.fixed.offsetX; let n = this.tConfig.fixed.offsetY; return this.tConfig.fixed.position.toLowerCase().indexOf('right') > -1 && (r = r + t.globals.svgWidth - a + 10), this.tConfig.fixed.position.toLowerCase().indexOf('bottom') > -1 && (n = n + t.globals.svgHeight - s - 10), e.style.left = `${r}px`, e.style.top = `${n}px`, {
        x: r, y: n, ttWidth: a, ttHeight: s,
      };
    },
  }, { key: 'addPointsEventsListeners', value(t) { const e = this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker'); this.addPathsEventListeners(e, t); } }, { key: 'addBarsEventListeners', value(t) { const e = this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-rangebar-area'); this.addPathsEventListeners(e, t); } }, {
    key: 'addPathsEventListeners',
    value(t, e) {
      for (var i = this, a = function (a) {
          const s = {
            paths: t[a], tooltipEl: e.tooltipEl, tooltipY: e.tooltipY, tooltipX: e.tooltipX, elGrid: e.elGrid, hoverArea: e.hoverArea, ttItems: e.ttItems,
          }; ['mousemove', 'mouseup', 'touchmove', 'mouseout', 'touchend'].map(((e) => t[a].addEventListener(e, i.seriesHover.bind(i, s), { capture: !1, passive: !0 })));
        }, s = 0; s < t.length; s++)a(s);
    },
  }, {
    key: 'seriesHover',
    value(t, e) {
      const i = this; let a = []; const s = this.w; s.config.chart.group && (a = this.ctx.getGroupedCharts()), s.globals.axisCharts && (s.globals.minX === -1 / 0 && s.globals.maxX === 1 / 0 || s.globals.dataPoints === 0) || (a.length ? a.forEach(((a) => {
        const s = i.getElTooltip(a); const r = {
          paths: t.paths, tooltipEl: s, tooltipY: t.tooltipY, tooltipX: t.tooltipX, elGrid: t.elGrid, hoverArea: t.hoverArea, ttItems: a.w.globals.tooltip.ttItems,
        }; a.w.globals.minX === i.w.globals.minX && a.w.globals.maxX === i.w.globals.maxX && a.w.globals.tooltip.seriesHoverByContext({
          chartCtx: a, ttCtx: a.w.globals.tooltip, opt: r, e,
        });
      })) : this.seriesHoverByContext({
        chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t, e,
      }));
    },
  }, {
    key: 'seriesHoverByContext',
    value(t) {
      const e = t.chartCtx; const i = t.ttCtx; const a = t.opt; const s = t.e; const r = e.w; const n = this.getElTooltip(); (i.tooltipRect = {
        x: 0, y: 0, ttWidth: n.getBoundingClientRect().width, ttHeight: n.getBoundingClientRect().height,
      }, i.e = s, !i.hasBars() || r.globals.comboCharts || i.isBarShared) || this.tConfig.onDatasetHover.highlightDataSeries && new Series(e).toggleSeriesOnHover(s, s.target.parentNode); i.fixedTooltip && i.drawFixedTooltipRect(), r.globals.axisCharts ? i.axisChartsTooltips({ e: s, opt: a, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: s, opt: a, tooltipRect: i.tooltipRect });
    },
  }, {
    key: 'axisChartsTooltips',
    value(t) {
      let e; let i; let a; const s = t.e; const r = t.opt; const n = this.w; let o = null; const l = r.elGrid.getBoundingClientRect(); const h = s.type === 'touchmove' ? s.touches[0].clientX : s.clientX; const c = s.type === 'touchmove' ? s.touches[0].clientY : s.clientY; if (this.clientY = c, this.clientX = h, n.globals.capturedSeriesIndex = -1, n.globals.capturedDataPointIndex = -1, c < l.top || c > l.top + l.height) this.handleMouseOut(r); else {
        if (Array.isArray(this.tConfig.enabledOnSeries) && !n.config.tooltip.shared) { const d = parseInt(r.paths.getAttribute('index'), 10); if (this.tConfig.enabledOnSeries.indexOf(d) < 0) return void this.handleMouseOut(r); } const g = this.getElTooltip(); const u = this.getElXCrosshairs(); let p = n.globals.xyCharts || n.config.chart.type === 'bar' && !n.globals.isBarHorizontal && this.hasBars() && this.tConfig.shared || n.globals.comboCharts && this.hasBars; if (n.globals.isBarHorizontal && this.hasBars() && (p = !1), s.type === 'mousemove' || s.type === 'touchmove' || s.type === 'mouseup') {
          if (u !== null && u.classList.add('apexcharts-active'), this.ycrosshairs !== null && this.blyaxisTooltip && this.ycrosshairs.classList.add('apexcharts-active'), p && !this.showOnIntersect) {
            e = (o = this.tooltipUtil.getNearestValues({
              context: this, hoverArea: r.hoverArea, elGrid: r.elGrid, clientX: h, clientY: c, hasBars: this.hasBars,
            })).j; const f = o.capturedSeries; if (o.hoverX < 0 || o.hoverX > n.globals.gridWidth) return void this.handleMouseOut(r); if (f !== null) { if (n.globals.series[f][e] === null) return void this.handleMouseOut(r); void 0 !== n.globals.series[f][e] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(e) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(s, this, f, e, r.ttItems) : this.create(s, this, f, e, r.ttItems, !1) : this.tooltipUtil.isXoverlap(e) && this.create(s, this, 0, e, r.ttItems); } else this.tooltipUtil.isXoverlap(e) && this.create(s, this, 0, e, r.ttItems);
          } else if (n.config.chart.type === 'heatmap') {
            const x = this.intersect.handleHeatTooltip({
              e: s, opt: r, x: i, y: a,
            }); i = x.x, a = x.y, g.style.left = `${i}px`, g.style.top = `${a}px`;
          } else {
            this.hasBars && this.intersect.handleBarTooltip({ e: s, opt: r }), this.hasMarkers && this.intersect.handleMarkerTooltip({
              e: s, opt: r, x: i, y: a,
            });
          } if (this.blyaxisTooltip) for (let b = 0; b < n.config.yaxis.length; b++) this.axesTooltip.drawYaxisTooltipText(b, c, this.xyRatios); r.tooltipEl.classList.add('apexcharts-active');
        } else s.type !== 'mouseout' && s.type !== 'touchend' || this.handleMouseOut(r);
      }
    },
  }, {
    key: 'nonAxisChartsTooltips',
    value(t) {
      const { e } = t; const i = t.opt; const a = t.tooltipRect; const s = this.w; const r = i.paths.getAttribute('rel'); const n = this.getElTooltip(); const
        o = s.globals.dom.elWrap.getBoundingClientRect(); if (e.type === 'mousemove' || e.type === 'touchmove') { n.classList.add('apexcharts-active'), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(r, 10) - 1, shared: !1 }); const l = s.globals.clientX - o.left - a.ttWidth / 2; const h = s.globals.clientY - o.top - a.ttHeight - 10; n.style.left = `${l}px`, n.style.top = `${h}px`; } else e.type !== 'mouseout' && e.type !== 'touchend' || n.classList.remove('apexcharts-active');
    },
  }, { key: 'deactivateHoverFilter', value() { for (let t = this.w, e = new Graphics(this.ctx), i = t.globals.dom.Paper.select('.apexcharts-bar-area'), a = 0; a < i.length; a++)e.pathMouseLeave(i[a]); } }, { key: 'handleMouseOut', value(t) { const e = this.w; const i = this.getElXCrosshairs(); if (t.tooltipEl.classList.remove('apexcharts-active'), this.deactivateHoverFilter(), e.config.chart.type !== 'bubble' && this.marker.resetPointsSize(), i !== null && i.classList.remove('apexcharts-active'), this.ycrosshairs !== null && this.ycrosshairs.classList.remove('apexcharts-active'), this.blxaxisTooltip && this.xaxisTooltip.classList.remove('apexcharts-active'), this.blyaxisTooltip) { this.yaxisTTEls === null && (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip')); for (let a = 0; a < this.yaxisTTEls.length; a++) this.yaxisTTEls[a].classList.remove('apexcharts-active'); }e.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(((t) => { const e = t.getAttribute('data:default-text'); t.innerHTML = decodeURIComponent(e); })); } }, { key: 'getElMarkers', value() { return this.w.globals.dom.baseEl.querySelectorAll(' .apexcharts-series-markers'); } }, { key: 'getAllMarkers', value() { return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker'); } }, { key: 'hasMarkers', value() { return this.getElMarkers().length > 0; } }, { key: 'getElBars', value() { return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-rangebar-series'); } }, { key: 'hasBars', value() { return this.getElBars().length > 0; } }, { key: 'markerClick', value(t, e, i) { const a = this.w; typeof a.config.chart.events.markerClick === 'function' && a.config.chart.events.markerClick(t, this.ctx, { seriesIndex: e, dataPointIndex: i, w: a }), this.ctx.events.fireEvent('markerClick', [t, this.ctx, { seriesIndex: e, dataPointIndex: i, w: a }]); } }, {
    key: 'create',
    value(t, e, i, a, s) {
      let r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null; const n = this.w; const o = e; t.type === 'mouseup' && this.markerClick(t, i, a), r === null && (r = this.tConfig.shared); const l = this.hasMarkers(); const h = this.getElBars(); if (n.config.legend.tooltipHoverFormatter) { const c = n.config.legend.tooltipHoverFormatter; const d = Array.from(this.legendLabels); d.forEach(((t) => { const e = t.getAttribute('data:default-text'); t.innerHTML = decodeURIComponent(e); })); for (let g = 0; g < d.length; g++) { const u = d[g]; const p = parseInt(u.getAttribute('i'), 10); const f = decodeURIComponent(u.getAttribute('data:default-text')); const x = c(f, { seriesIndex: r ? p : i, dataPointIndex: a, w: n }); if (r)u.innerHTML = n.globals.collapsedSeriesIndices.indexOf(p) < 0 ? x : f; else if (u.innerHTML = p === i ? x : f, i === p) break; } } if (r) {
        if (o.tooltipLabels.drawSeriesTexts({
          ttItems: s, i, j: a, shared: !this.showOnIntersect && this.tConfig.shared,
        }), l && (n.globals.markers.largestSize > 0 ? o.marker.enlargePoints(a) : o.tooltipPosition.moveDynamicPointsOnHover(a)), this.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(h), this.barSeriesHeight > 0)) { const b = new Graphics(this.ctx); const m = n.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a, "']")); this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a); for (let v = 0; v < m.length; v++)b.pathMouseEnter(m[v]); }
      } else {
        o.tooltipLabels.drawSeriesTexts({
          shared: !1, ttItems: s, i, j: a,
        }), this.hasBars() && o.tooltipPosition.moveStickyTooltipOverBars(a), l && o.tooltipPosition.moveMarkers(i, a);
      }
    },
  }]), t;
}()); const BarDataLabels = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.barCtx = e; } return _createClass(t, [{
    key: 'handleBarDataLabels',
    value(t) {
      const e = t.x; const i = t.y; const a = t.y1; const s = t.y2; const r = t.i; const n = t.j; const o = t.realIndex; const l = t.series; const h = t.barHeight; const c = t.barWidth; const d = t.barYPosition; const g = t.visibleSeries; const u = t.renderedPath; const p = this.w; const f = new Graphics(this.barCtx.ctx); const x = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o] : this.barCtx.strokeWidth; let b = e + parseFloat(c * g); let m = i + parseFloat(h * g); p.globals.isXNumeric && !p.globals.isBarHorizontal && (b = e + parseFloat(c * (g + 1)), m = i + parseFloat(h * (g + 1)) - x); const v = e; let y = i; let w = {}; const k = p.config.dataLabels; const C = this.barCtx.barOptions.dataLabels; void 0 !== d && this.barCtx.isTimelineBar && (m = d, y = d); const A = k.offsetX; const S = k.offsetY; let L = { width: 0, height: 0 }; p.config.dataLabels.enabled && (L = f.getTextRects(p.globals.yLabelFormatters[0](p.globals.maxY), parseFloat(k.style.fontSize))); const P = {
        x: e, y: i, i: r, j: n, renderedPath: u, bcx: b, bcy: m, barHeight: h, barWidth: c, textRects: L, strokeWidth: x, dataLabelsX: v, dataLabelsY: y, barDataLabelsConfig: C, offX: A, offY: S,
      }; return w = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(P) : this.calculateColumnsDataLabelsPosition(P), u.attr({
        cy: w.bcy, cx: w.bcx, j: n, val: l[r][n], barHeight: h, barWidth: c,
      }), this.drawCalculatedDataLabels({
        x: w.dataLabelsX, y: w.dataLabelsY, val: this.barCtx.isTimelineBar ? [a, s] : l[r][n], i: o, j: n, barWidth: c, barHeight: h, textRects: L, dataLabelsConfig: k,
      });
    },
  }, {
    key: 'calculateColumnsDataLabelsPosition',
    value(t) {
      let e; const i = this.w; const a = t.i; const s = t.j; let r = t.y; let n = t.bcx; const o = t.barWidth; const l = t.barHeight; const h = t.textRects; let c = t.dataLabelsY; const d = t.barDataLabelsConfig; const g = t.strokeWidth; const u = t.offX; const p = t.offY; const f = i.config.plotOptions.bar.dataLabels.orientation === 'vertical'; n -= g / 2; const x = i.globals.gridWidth / i.globals.dataPoints; if (e = i.globals.isXNumeric ? n - o / 2 + u : n - x + o / 2 + u, f) { e = e + h.height / 2 - g / 2 - 2; } const b = this.barCtx.series[a][s] <= 0; switch (this.barCtx.isReversed && (r -= l), d.position) { case 'center': c = f ? b ? r + l / 2 + p : r + l / 2 - p : b ? r + l / 2 + h.height / 2 + p : r + l / 2 + h.height / 2 - p; break; case 'bottom': c = f ? b ? r + l + p : r + l - p : b ? r + l + h.height + g + p : r + l - h.height / 2 + g - p; break; case 'top': c = f ? b ? r + p : r - p : b ? r - h.height / 2 - p : r + h.height + p; } return i.config.chart.stacked || (c < 0 ? c = 0 + g : c + h.height / 3 > i.globals.gridHeight && (c = i.globals.gridHeight - g)), {
        bcx: n, bcy: r, dataLabelsX: e, dataLabelsY: c,
      };
    },
  }, {
    key: 'calculateBarsDataLabelsPosition',
    value(t) {
      const e = this.w; let i = t.x; const a = t.i; const s = t.j; const r = t.bcy; const n = t.barHeight; const o = t.barWidth; const l = t.textRects; let h = t.dataLabelsX; const c = t.strokeWidth; const d = t.barDataLabelsConfig; const g = t.offX; const u = t.offY; const p = e.globals.gridHeight / e.globals.dataPoints; const f = r - (this.barCtx.isTimelineBar ? 0 : p) + n / 2 + l.height / 2 + u - 3; const x = this.barCtx.series[a][s] <= 0; switch (this.barCtx.isReversed && (i += o), d.position) { case 'center': h = x ? i - o / 2 - g : i - o / 2 + g; break; case 'bottom': h = x ? i - o - c - Math.round(l.width / 2) - g : i - o + c + Math.round(l.width / 2) + g; break; case 'top': h = x ? i - c + Math.round(l.width / 2) - g : i - c - Math.round(l.width / 2) + g; } return e.config.chart.stacked || (h < 0 ? h = h + l.width + c : h + l.width / 2 > e.globals.gridWidth && (h = e.globals.gridWidth - l.width - c)), {
        bcx: i, bcy: r, dataLabelsX: h, dataLabelsY: f,
      };
    },
  }, {
    key: 'drawCalculatedDataLabels',
    value(t) {
      const e = t.x; const i = t.y; const a = t.val; const s = t.i; const r = t.j; const n = t.textRects; let o = t.barHeight; let l = t.barWidth; const h = t.dataLabelsConfig; const c = this.w; let d = 'rotate(0)'; c.config.plotOptions.bar.dataLabels.orientation === 'vertical' && (d = 'rotate(-90, '.concat(e, ', ').concat(i, ')')); const g = new DataLabels(this.barCtx.ctx); const u = new Graphics(this.barCtx.ctx); const p = h.formatter; let f = null; const x = c.globals.collapsedSeriesIndices.indexOf(s) > -1; if (h.enabled && !x) {
        f = u.group({ class: 'apexcharts-data-labels', transform: d }); let b = ''; void 0 !== a && (b = p(a, { seriesIndex: s, dataPointIndex: r, w: c })), a === 0 && c.config.chart.stacked && (b = ''); const m = c.globals.series[s][r] <= 0; const v = c.config.plotOptions.bar.dataLabels.position; if (c.config.plotOptions.bar.dataLabels.orientation === 'vertical' && (v === 'top' && (h.textAnchor = m ? 'end' : 'start'), v === 'center' && (h.textAnchor = 'middle'), v === 'bottom' && (h.textAnchor = m ? 'end' : 'start')), this.barCtx.isTimelineBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels)l < u.getTextRects(b, parseFloat(h.style.fontSize)).width && (b = ''); c.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? ((l = Math.abs(c.globals.series[s][r]) / this.barCtx.invertedYRatio[this.barCtx.yaxisIndex]) > 0 && n.width / 1.6 > l || l < 0 && n.width / 1.6 < l) && (b = '') : (o = Math.abs(c.globals.series[s][r]) / this.barCtx.yRatio[this.barCtx.yaxisIndex], n.height / 1.6 > o && (b = ''))); const y = _objectSpread2({}, h); this.barCtx.isHorizontal && a < 0 && (h.textAnchor === 'start' ? y.textAnchor = 'end' : h.textAnchor === 'end' && (y.textAnchor = 'start')), g.plotDataLabelsText({
          x: e, y: i, text: b, i: s, j: r, parent: f, dataLabelsConfig: y, alwaysDrawDataLabel: !0, offsetCorrection: !0,
        });
      } return f;
    },
  }]), t;
}()); const Helpers$3 = (function () {
  function t(e) { _classCallCheck(this, t), this.w = e.w, this.barCtx = e; } return _createClass(t, [{ key: 'initVariables', value(t) { const e = this.w; this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1; for (let i = 0; i < t.length; i++) if (t[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[i].length), e.globals.isXNumeric) for (let a = 0; a < t[i].length; a++)e.globals.seriesX[i][a] > e.globals.minX && e.globals.seriesX[i][a] < e.globals.maxX && this.barCtx.visibleItems++; else this.barCtx.visibleItems = e.globals.dataPoints; this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1); } }, {
    key: 'initialPositions',
    value() {
      let t; let e; let i; let a; let s; let r; let n; let o; const l = this.w; let h = l.globals.dataPoints; if (this.barCtx.isTimelineBar && (h = l.globals.labels.length), this.barCtx.isHorizontal)s = (i = l.globals.gridHeight / h) / this.barCtx.seriesLen, l.globals.isXNumeric && (s = (i = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s = s * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, o = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), e = (i - s * this.barCtx.seriesLen) / 2; else { if (a = l.globals.gridWidth / this.barCtx.visibleItems, l.config.xaxis.convertedCatToNumeric && (a = l.globals.gridWidth / l.globals.dataPoints), r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l.globals.isXNumeric) { let c = this.barCtx.xRatio; l.config.xaxis.convertedCatToNumeric && (c = this.barCtx.initialXRatio), l.globals.minXDiff && l.globals.minXDiff / c > 0 && (a = l.globals.minXDiff / c), (r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1); }n = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = l.globals.padHorizontal + (a - r * this.barCtx.seriesLen) / 2; } return {
        x: t, y: e, yDivision: i, xDivision: a, barHeight: s, barWidth: r, zeroH: n, zeroW: o,
      };
    },
  }, { key: 'getPathFillColor', value(t, e, i, a) { const s = this.w; const r = new Fill(this.barCtx.ctx); let n = null; const o = this.barCtx.barOptions.distributed ? i : e; this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(((a) => { t[e][i] >= a.from && t[e][i] <= a.to && (n = a.color); })); return s.config.series[e].data[i] && s.config.series[e].data[i].fillColor && (n = s.config.series[e].data[i].fillColor), r.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? o : a, color: n, value: t[e][i] }); } }, { key: 'getStrokeWidth', value(t, e, i) { let a = 0; const s = this.w; return void 0 === this.barCtx.series[t][e] || this.barCtx.series[t][e] === null ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, s.config.stroke.show && (this.barCtx.isNullValue || (a = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), a; } }, { key: 'getBarEndingShape', value(t, e, i, a, s) { const r = new Graphics(this.barCtx.ctx); if (this.barCtx.isHorizontal) { let n = null; let o = e.x; if (void 0 !== i[a][s] || i[a][s] !== null) { const l = i[a][s] < 0; let h = e.barHeight / 2 - e.strokeWidth; switch (l && (h = -e.barHeight / 2 - e.strokeWidth), t.config.chart.stacked || this.barCtx.barOptions.endingShape === 'rounded' && (o = e.x - h / 2), this.barCtx.barOptions.endingShape) { case 'flat': n = r.line(o, e.barYPosition + e.barHeight - e.strokeWidth); break; case 'rounded': n = r.quadraticCurve(o + h, e.barYPosition + (e.barHeight - e.strokeWidth) / 2, o, e.barYPosition + e.barHeight - e.strokeWidth); } } return { path: n, ending_p_from: '', newX: o }; } let c = null; let d = e.y; if (void 0 !== i[a][s] || i[a][s] !== null) { const g = i[a][s] < 0; let u = e.barWidth / 2 - e.strokeWidth; switch (g && (u = -e.barWidth / 2 - e.strokeWidth), t.config.chart.stacked || this.barCtx.barOptions.endingShape === 'rounded' && (d += u / 2), this.barCtx.barOptions.endingShape) { case 'flat': c = r.line(e.barXPosition + e.barWidth - e.strokeWidth, d); break; case 'rounded': c = r.quadraticCurve(e.barXPosition + (e.barWidth - e.strokeWidth) / 2, d - u, e.barXPosition + e.barWidth - e.strokeWidth, d); } } return { path: c, ending_p_from: '', newY: d }; } }]), t;
}()); const Bar = (function () {
  function t(e, i) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; const a = this.w; this.barOptions = a.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = a.config.stroke.width, this.isNullValue = !1, this.isTimelineBar = a.config.xaxis.type === 'datetime' && a.globals.seriesRangeBarTimeline.length, this.xyRatios = i, this.xyRatios !== null && (this.xRatio = i.xRatio, this.initialXRatio = i.initialXRatio, this.yRatio = i.yRatio, this.invertedXRatio = i.invertedXRatio, this.invertedYRatio = i.invertedYRatio, this.baseLineY = i.baseLineY, this.baseLineInvertedY = i.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.barHelpers = new Helpers$3(this); } return _createClass(t, [{
    key: 'draw',
    value(t, e) {
      const i = this.w; const a = new Graphics(this.ctx); const s = new CoreUtils(this.ctx, i); t = s.getLogSeries(t), this.series = t, this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t); const r = a.group({ class: 'apexcharts-bar-series apexcharts-plot-series' }); i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn('WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.'); for (let n = 0, o = 0; n < t.length; n++, o++) {
        var l; var h; var c; var d; let g = void 0; let u = void 0; const p = []; const f = []; const x = i.globals.comboCharts ? e[n] : n; const b = a.group({
          class: 'apexcharts-series', rel: n + 1, seriesName: Utils.escapeString(i.globals.seriesNames[x]), 'data:realIndex': x,
        }); this.ctx.series.addCollapsedClassToSeries(b, x), t[n].length > 0 && (this.visibleI += 1); let m = 0; let v = 0; this.yRatio.length > 1 && (this.yaxisIndex = x), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed; const y = this.barHelpers.initialPositions(); u = y.y, m = y.barHeight, h = y.yDivision, d = y.zeroW, g = y.x, v = y.barWidth, l = y.xDivision, c = y.zeroH, this.horizontal || f.push(g + v / 2); for (let w = a.group({ class: 'apexcharts-datalabels' }), k = 0; k < i.globals.dataPoints; k++) {
          const C = this.barHelpers.getStrokeWidth(n, k, x); let A = null; const S = {
            indexes: {
              i: n, j: k, realIndex: x, bc: o,
            },
            x: g,
            y: u,
            strokeWidth: C,
            elSeries: b,
          }; this.isHorizontal ? (A = this.drawBarPaths(_objectSpread2({}, S, { barHeight: m, zeroW: d, yDivision: h })), v = this.series[n][k] / this.invertedYRatio) : (A = this.drawColumnPaths(_objectSpread2({}, S, { xDivision: l, barWidth: v, zeroH: c })), m = this.series[n][k] / this.yRatio[this.yaxisIndex]), u = A.y, g = A.x, k > 0 && f.push(g + v / 2), p.push(u); const L = this.barHelpers.getPathFillColor(t, n, k, x); this.renderSeries({
            realIndex: x, pathFill: L, j: k, i: n, pathFrom: A.pathFrom, pathTo: A.pathTo, strokeWidth: C, elSeries: b, x: g, y: u, series: t, barHeight: m, barWidth: v, elDataLabelsWrap: w, visibleSeries: this.visibleI, type: 'bar',
          });
        }i.globals.seriesXvalues[x] = f, i.globals.seriesYvalues[x] = p, r.add(b);
      } return r;
    },
  }, {
    key: 'renderSeries',
    value(t) {
      const e = t.realIndex; let i = t.pathFill; let a = t.lineFill; const s = t.j; const r = t.i; const n = t.pathFrom; const o = t.pathTo; const l = t.strokeWidth; const h = t.elSeries; const c = t.x; const d = t.y; const g = t.y1; const u = t.y2; const p = t.series; const f = t.barHeight; const x = t.barWidth; const b = t.barYPosition; const m = t.elDataLabelsWrap; const v = t.visibleSeries; const y = t.type; const { w } = this; const k = new Graphics(this.ctx); a || (a = this.barOptions.distributed ? w.globals.stroke.colors[s] : w.globals.stroke.colors[e]), w.config.series[r].data[s] && w.config.series[r].data[s].strokeColor && (a = w.config.series[r].data[s].strokeColor), this.isNullValue && (i = 'none'); const C = s / w.config.chart.animations.animateGradually.delay * (w.config.chart.animations.speed / w.globals.dataPoints) / 2.4; const A = k.renderPaths({
        i: r, j: s, realIndex: e, pathFrom: n, pathTo: o, stroke: a, strokeWidth: l, strokeLineCap: w.config.stroke.lineCap, fill: i, animationDelay: C, initialSpeed: w.config.chart.animations.speed, dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed, className: 'apexcharts-'.concat(y, '-area'),
      }); A.attr('clip-path', 'url(#gridRectMask'.concat(w.globals.cuid, ')')), void 0 !== g && void 0 !== u && (A.attr('data-range-y1', g), A.attr('data-range-y2', u)), new Filters(this.ctx).setSelectionFilter(A, e, s), h.add(A); const S = new BarDataLabels(this).handleBarDataLabels({
        x: c, y: d, y1: g, y2: u, i: r, j: s, series: p, realIndex: e, barHeight: f, barWidth: x, barYPosition: b, renderedPath: A, visibleSeries: v,
      }); return S !== null && m.add(S), h.add(m), h;
    },
  }, {
    key: 'drawBarPaths',
    value(t) {
      const e = t.indexes; const i = t.barHeight; const a = t.strokeWidth; const s = t.zeroW; let r = t.x; let n = t.y; const o = t.yDivision; const l = t.elSeries; const h = this.w; const c = new Graphics(this.ctx); const d = e.i; const g = e.j; const u = e.realIndex; let p = e.bc; h.globals.isXNumeric && (n = (h.globals.seriesX[d][g] - h.globals.minX) / this.invertedXRatio - i); const f = n + i * this.visibleI; let x = c.move(s, f); let b = c.move(s, f); h.globals.previousPaths.length > 0 && (b = this.getPreviousPath(u, g)); const m = {
        barHeight: i, strokeWidth: a, barYPosition: f, x: r = void 0 === this.series[d][g] || this.series[d][g] === null ? s : s + this.series[d][g] / this.invertedYRatio - 2 * (this.isReversed ? this.series[d][g] / this.invertedYRatio : 0), zeroW: s,
      }; const v = this.barHelpers.getBarEndingShape(h, m, this.series, d, g); if (x = x + c.line(v.newX, f) + v.path + c.line(s, f + i - a) + c.line(s, f), b = b + c.line(s, f) + v.ending_p_from + c.line(s, f + i - a) + c.line(s, f + i - a) + c.line(s, f), h.globals.isXNumeric || (n += o), this.barOptions.colors.backgroundBarColors.length > 0 && d === 0) { p >= this.barOptions.colors.backgroundBarColors.length && (p = 0); const y = this.barOptions.colors.backgroundBarColors[p]; const w = c.drawRect(0, f - i * this.visibleI, h.globals.gridWidth, i * this.seriesLen, 0, y, this.barOptions.colors.backgroundBarOpacity); l.add(w), w.node.classList.add('apexcharts-backgroundBar'); } return {
        pathTo: x, pathFrom: b, x: r, y: n, barYPosition: f,
      };
    },
  }, {
    key: 'drawColumnPaths',
    value(t) {
      const e = t.indexes; let i = t.x; let a = t.y; const s = t.xDivision; const r = t.barWidth; const n = t.zeroH; const o = t.strokeWidth; const l = t.elSeries; const h = this.w; const c = new Graphics(this.ctx); const d = e.i; const g = e.j; const u = e.realIndex; let p = e.bc; if (h.globals.isXNumeric) { let f = d; h.globals.seriesX[d].length || (f = h.globals.maxValsInArrayIndex), i = (h.globals.seriesX[f][g] - h.globals.minX) / this.xRatio - r * this.seriesLen / 2; } const x = i + r * this.visibleI; let b = c.move(x, n); let m = c.move(x, n); h.globals.previousPaths.length > 0 && (m = this.getPreviousPath(u, g)); const v = {
        barWidth: r, strokeWidth: o, barXPosition: x, y: a = void 0 === this.series[d][g] || this.series[d][g] === null ? n : n - this.series[d][g] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[d][g] / this.yRatio[this.yaxisIndex] : 0), zeroH: n,
      }; const y = this.barHelpers.getBarEndingShape(h, v, this.series, d, g); if (b = b + c.line(x, y.newY) + y.path + c.line(x + r - o, n) + c.line(x - o / 2, n), m = m + c.line(x, n) + y.ending_p_from + c.line(x + r - o, n) + c.line(x + r - o, n) + c.line(x - o / 2, n), h.globals.isXNumeric || (i += s), this.barOptions.colors.backgroundBarColors.length > 0 && d === 0) { p >= this.barOptions.colors.backgroundBarColors.length && (p = 0); const w = this.barOptions.colors.backgroundBarColors[p]; const k = c.drawRect(x - r * this.visibleI, 0, r * this.seriesLen, h.globals.gridHeight, 0, w, this.barOptions.colors.backgroundBarOpacity); l.add(k), k.node.classList.add('apexcharts-backgroundBar'); } return {
        pathTo: b, pathFrom: m, x: i, y: a, barXPosition: x,
      };
    },
  }, { key: 'getPreviousPath', value(t, e) { for (var i, a = this.w, s = 0; s < a.globals.previousPaths.length; s++) { const r = a.globals.previousPaths[s]; r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(t, 10) && void 0 !== a.globals.previousPaths[s].paths[e] && (i = a.globals.previousPaths[s].paths[e].d); } return i; } }]), t;
}()); const BarStacked = (function (t) {
  function e() { return _classCallCheck(this, e), _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments)); } return _inherits(e, Bar), _createClass(e, [{
    key: 'draw',
    value(t, e) {
      const i = this.w; this.graphics = new Graphics(this.ctx), this.bar = new Bar(this.ctx, this.xyRatios); const a = new CoreUtils(this.ctx, i); t = a.getLogSeries(t), this.yRatio = a.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t), i.config.chart.stackType === '100%' && (t = i.globals.seriesPercent.slice()), this.series = t, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = []; for (let s = 0; s < t.length; s++)t[s].length > 0 && (this.totalItems += t[s].length); for (var r = this.graphics.group({ class: 'apexcharts-bar-series apexcharts-plot-series' }), n = 0, o = 0, l = 0, h = 0; l < t.length; l++, h++) {
        let c = void 0; let d = void 0; let g = void 0; let u = void 0; const p = []; const f = []; const x = i.globals.comboCharts ? e[l] : l; this.yRatio.length > 1 && (this.yaxisIndex = x), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed; let b = this.graphics.group({
          class: 'apexcharts-series', seriesName: Utils.escapeString(i.globals.seriesNames[x]), rel: l + 1, 'data:realIndex': x,
        }); const m = this.graphics.group({ class: 'apexcharts-datalabels' }); let v = 0; let y = 0; const w = this.initialPositions(n, o, c, d, g, u); o = w.y, v = w.barHeight, d = w.yDivision, u = w.zeroW, n = w.x, y = w.barWidth, c = w.xDivision, g = w.zeroH, this.yArrj = [], this.yArrjF = [], this.yArrjVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = []; for (let k = 0; k < i.globals.dataPoints; k++) {
          const C = this.barHelpers.getStrokeWidth(l, k, x); const A = {
            indexes: {
              i: l, j: k, realIndex: x, bc: h,
            },
            strokeWidth: C,
            x: n,
            y: o,
            elSeries: b,
          }; let S = null; this.isHorizontal ? (S = this.drawBarPaths(_objectSpread2({}, A, { zeroW: u, barHeight: v, yDivision: d })), y = this.series[l][k] / this.invertedYRatio) : (S = this.drawColumnPaths(_objectSpread2({}, A, { xDivision: c, barWidth: y, zeroH: g })), v = this.series[l][k] / this.yRatio[this.yaxisIndex]), o = S.y, n = S.x, p.push(n), f.push(o); const L = this.barHelpers.getPathFillColor(t, l, k, x); b = this.renderSeries({
            realIndex: x, pathFill: L, j: k, i: l, pathFrom: S.pathFrom, pathTo: S.pathTo, strokeWidth: C, elSeries: b, x: n, y: o, series: t, barHeight: v, barWidth: y, elDataLabelsWrap: m, type: 'bar', visibleSeries: 0,
          });
        }i.globals.seriesXvalues[x] = p, i.globals.seriesYvalues[x] = f, this.prevY.push(this.yArrj), this.prevYF.push(this.yArrjF), this.prevYVal.push(this.yArrjVal), this.prevX.push(this.xArrj), this.prevXF.push(this.xArrjF), this.prevXVal.push(this.xArrjVal), r.add(b);
      } return r;
    },
  }, {
    key: 'initialPositions',
    value(t, e, i, a, s, r) {
      let n; let o; const l = this.w; return this.isHorizontal ? (n = (n = a = l.globals.gridHeight / l.globals.dataPoints) * parseInt(l.config.plotOptions.bar.barHeight, 10) / 100, r = this.baseLineInvertedY + l.globals.padHorizontal + (this.isReversed ? l.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e = (a - n) / 2) : (o = i = l.globals.gridWidth / l.globals.dataPoints, o = l.globals.isXNumeric ? (i = l.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : o * parseInt(l.config.plotOptions.bar.columnWidth, 10) / 100, s = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t = l.globals.padHorizontal + (i - o) / 2), {
        x: t, y: e, yDivision: a, xDivision: i, barHeight: n, barWidth: o, zeroH: s, zeroW: r,
      };
    },
  }, {
    key: 'drawBarPaths',
    value(t) {
      for (var e, i = t.indexes, a = t.barHeight, s = t.strokeWidth, r = t.zeroW, n = t.x, o = t.y, l = t.yDivision, h = t.elSeries, c = this.w, d = o, g = i.i, u = i.j, p = i.realIndex, f = i.bc, x = 0, b = 0; b < this.prevXF.length; b++)x += this.prevXF[b][u]; if (g > 0) { let m = r; this.prevXVal[g - 1][u] < 0 ? m = this.series[g][u] >= 0 ? this.prevX[g - 1][u] + x - 2 * (this.isReversed ? x : 0) : this.prevX[g - 1][u] : this.prevXVal[g - 1][u] >= 0 && (m = this.series[g][u] >= 0 ? this.prevX[g - 1][u] : this.prevX[g - 1][u] - x + 2 * (this.isReversed ? x : 0)), e = m; } else e = r; n = this.series[g][u] === null ? e : e + this.series[g][u] / this.invertedYRatio - 2 * (this.isReversed ? this.series[g][u] / this.invertedYRatio : 0); const v = {
        barHeight: a, strokeWidth: s, invertedYRatio: this.invertedYRatio, barYPosition: d, x: n,
      }; const y = this.barHelpers.getBarEndingShape(c, v, this.series, g, u); this.series.length > 1 && g !== this.endingShapeOnSeriesNumber && (y.path = this.graphics.line(y.newX, d + a - s)), this.xArrj.push(y.newX), this.xArrjF.push(Math.abs(e - y.newX)), this.xArrjVal.push(this.series[g][u]); let w = this.graphics.move(e, d); let k = this.graphics.move(e, d); if (c.globals.previousPaths.length > 0 && (k = this.bar.getPreviousPath(p, u, !1)), w = w + this.graphics.line(y.newX, d) + y.path + this.graphics.line(e, d + a - s) + this.graphics.line(e, d), k = k + this.graphics.line(e, d) + this.graphics.line(e, d + a - s) + this.graphics.line(e, d + a - s) + this.graphics.line(e, d + a - s) + this.graphics.line(e, d), c.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && g === 0) { f >= c.config.plotOptions.bar.colors.backgroundBarColors.length && (f = 0); const C = c.config.plotOptions.bar.colors.backgroundBarColors[f]; const A = this.graphics.drawRect(0, d, c.globals.gridWidth, a, 0, C, c.config.plotOptions.bar.colors.backgroundBarOpacity); h.add(A), A.node.classList.add('apexcharts-backgroundBar'); } return {
        pathTo: w, pathFrom: k, x: n, y: o += l,
      };
    },
  }, {
    key: 'drawColumnPaths',
    value(t) {
      const e = t.indexes; let i = t.x; let a = t.y; const s = t.xDivision; const r = t.barWidth; const n = t.zeroH; const o = t.strokeWidth; const l = t.elSeries; const h = this.w; const c = e.i; const d = e.j; const g = e.realIndex; let u = e.bc; if (h.globals.isXNumeric) { let p = h.globals.seriesX[c][d]; p || (p = 0), i = (p - h.globals.minX) / this.xRatio - r / 2; } for (var f, x = i, b = 0, m = 0; m < this.prevYF.length; m++)b += this.prevYF[m][d]; if (c > 0 && !h.globals.isXNumeric || c > 0 && h.globals.isXNumeric && h.globals.seriesX[c - 1][d] === h.globals.seriesX[c][d]) { const v = this.prevY[c - 1][d]; f = this.prevYVal[c - 1][d] < 0 ? this.series[c][d] >= 0 ? v - b + 2 * (this.isReversed ? b : 0) : v : this.series[c][d] >= 0 ? v : v + b - 2 * (this.isReversed ? b : 0); } else f = h.globals.gridHeight - n; a = f - this.series[c][d] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[c][d] / this.yRatio[this.yaxisIndex] : 0); const y = {
        barWidth: r, strokeWidth: o, yRatio: this.yRatio[this.yaxisIndex], barXPosition: x, y: a,
      }; const w = this.barHelpers.getBarEndingShape(h, y, this.series, c, d); this.yArrj.push(w.newY), this.yArrjF.push(Math.abs(f - w.newY)), this.yArrjVal.push(this.series[c][d]); let k = this.graphics.move(x, f); let C = this.graphics.move(x, f); if (h.globals.previousPaths.length > 0 && (C = this.bar.getPreviousPath(g, d, !1)), k = k + this.graphics.line(x, w.newY) + w.path + this.graphics.line(x + r - o, f) + this.graphics.line(x - o / 2, f), C = C + this.graphics.line(x, f) + this.graphics.line(x + r - o, f) + this.graphics.line(x + r - o, f) + this.graphics.line(x + r - o, f) + this.graphics.line(x - o / 2, f), h.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && c === 0) { u >= h.config.plotOptions.bar.colors.backgroundBarColors.length && (u = 0); const A = h.config.plotOptions.bar.colors.backgroundBarColors[u]; const S = this.graphics.drawRect(x, 0, r, h.globals.gridHeight, 0, A, h.config.plotOptions.bar.colors.backgroundBarOpacity); l.add(S), S.node.classList.add('apexcharts-backgroundBar'); } return i += s, {
        pathTo: k, pathFrom: C, x: h.globals.isXNumeric ? i - s : i, y: a,
      };
    },
  }]), e;
}()); const CandleStick = (function (t) {
  function e() { return _classCallCheck(this, e), _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments)); } return _inherits(e, Bar), _createClass(e, [{
    key: 'draw',
    value(t, e) {
      const i = this.w; const a = new Graphics(this.ctx); const s = new Fill(this.ctx); this.candlestickOptions = this.w.config.plotOptions.candlestick; const r = new CoreUtils(this.ctx, i); t = r.getLogSeries(t), this.series = t, this.yRatio = r.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t); for (var n = a.group({ class: 'apexcharts-candlestick-series apexcharts-plot-series' }), o = 0; o < t.length; o++) {
        var l; var h; let c = void 0; let d = void 0; const g = []; const u = []; const p = i.globals.comboCharts ? e[o] : o; const f = a.group({
          class: 'apexcharts-series', seriesName: Utils.escapeString(i.globals.seriesNames[p]), rel: o + 1, 'data:realIndex': p,
        }); t[o].length > 0 && (this.visibleI += 1); var x; var b; this.yRatio.length > 1 && (this.yaxisIndex = p); const m = this.barHelpers.initialPositions(); d = m.y, x = m.barHeight, c = m.x, b = m.barWidth, l = m.xDivision, h = m.zeroH, u.push(c + b / 2); for (let v = a.group({ class: 'apexcharts-datalabels' }), y = 0; y < i.globals.dataPoints; y++) {
          var w; const k = this.barHelpers.getStrokeWidth(o, y, p); const C = this.drawCandleStickPaths({
            indexes: { i: o, j: y, realIndex: p }, x: c, y: d, xDivision: l, barWidth: b, zeroH: h, strokeWidth: k, elSeries: f,
          }); d = C.y, c = C.x, w = C.color, y > 0 && u.push(c + b / 2), g.push(d); const A = s.fillPath({ seriesNumber: p, color: w, value: t[o][y] }); const S = this.candlestickOptions.wick.useFillColor ? w : void 0; this.renderSeries({
            realIndex: p, pathFill: A, lineFill: S, j: y, i: o, pathFrom: C.pathFrom, pathTo: C.pathTo, strokeWidth: k, elSeries: f, x: c, y: d, series: t, barHeight: x, barWidth: b, elDataLabelsWrap: v, visibleSeries: this.visibleI, type: 'candlestick',
          });
        }i.globals.seriesXvalues[p] = u, i.globals.seriesYvalues[p] = g, n.add(f);
      } return n;
    },
  }, {
    key: 'drawCandleStickPaths',
    value(t) {
      const e = t.indexes; let i = t.x; const a = (t.y, t.xDivision); const s = t.barWidth; const r = t.zeroH; const n = t.strokeWidth; const o = this.w; const l = new Graphics(this.ctx); const h = e.i; const c = e.j; let d = !0; const g = o.config.plotOptions.candlestick.colors.upward; const u = o.config.plotOptions.candlestick.colors.downward; const p = this.yRatio[this.yaxisIndex]; const f = e.realIndex; const x = this.getOHLCValue(f, c); let b = r; let m = r; x.o > x.c && (d = !1); let v = Math.min(x.o, x.c); let y = Math.max(x.o, x.c); o.globals.isXNumeric && (i = (o.globals.seriesX[f][c] - o.globals.minX) / this.xRatio - s / 2); const w = i + s * this.visibleI; void 0 === this.series[h][c] || this.series[h][c] === null ? v = r : (v = r - v / p, y = r - y / p, b = r - x.h / p, m = r - x.l / p); let k = l.move(w, r); let C = l.move(w, v); return o.globals.previousPaths.length > 0 && (C = this.getPreviousPath(f, c, !0)), k = l.move(w, y) + l.line(w + s / 2, y) + l.line(w + s / 2, b) + l.line(w + s / 2, y) + l.line(w + s, y) + l.line(w + s, v) + l.line(w + s / 2, v) + l.line(w + s / 2, m) + l.line(w + s / 2, v) + l.line(w, v) + l.line(w, y - n / 2), C += l.move(w, v), o.globals.isXNumeric || (i += a), {
        pathTo: k, pathFrom: C, x: i, y, barXPosition: w, color: d ? g : u,
      };
    },
  }, {
    key: 'getOHLCValue',
    value(t, e) {
      const i = this.w; return {
        o: i.globals.seriesCandleO[t][e], h: i.globals.seriesCandleH[t][e], l: i.globals.seriesCandleL[t][e], c: i.globals.seriesCandleC[t][e],
      };
    },
  }]), e;
}()); const HeatMap = (function () {
  function t(e, i) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.xRatio = i.xRatio, this.yRatio = i.yRatio, this.negRange = !1, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.width; } return _createClass(t, [{
    key: 'draw',
    value(t) {
      const e = this.w; const i = new Graphics(this.ctx); const a = i.group({ class: 'apexcharts-heatmap' }); a.attr('clip-path', 'url(#gridRectMask'.concat(e.globals.cuid, ')')); const s = e.globals.gridWidth / e.globals.dataPoints; const r = e.globals.gridHeight / e.globals.series.length; let n = 0; let o = !1; this.checkColorRange(); const l = t.slice(); e.config.yaxis[0].reversed && (o = !0, l.reverse()); for (let h = o ? 0 : l.length - 1; o ? h < l.length : h >= 0; o ? h++ : h--) {
        const c = i.group({
          class: 'apexcharts-series apexcharts-heatmap-series', seriesName: Utils.escapeString(e.globals.seriesNames[h]), rel: h + 1, 'data:realIndex': h,
        }); if (e.config.chart.dropShadow.enabled) { const d = e.config.chart.dropShadow; new Filters(this.ctx).dropShadow(c, d, h); } for (let g = 0, u = 0; u < l[h].length; u++) {
          let p = 1; const f = e.config.plotOptions.heatmap.shadeIntensity; const x = this.determineHeatColor(h, u); p = e.globals.hasNegs || this.negRange ? e.config.plotOptions.heatmap.reverseNegativeShade ? x.percent < 0 ? x.percent / 100 * (1.25 * f) : (1 - x.percent / 100) * (1.25 * f) : x.percent < 0 ? 1 - (1 + x.percent / 100) * f : (1 - x.percent / 100) * f : 1 - x.percent / 100; let b = x.color; const m = new Utils(); if (e.config.plotOptions.heatmap.enableShades && (b = Utils.hexToRgba(m.shadeColor(p, x.color), e.config.fill.opacity)), e.config.fill.type === 'image') {
            b = new Fill(this.ctx).fillPath({
              seriesNumber: h, opacity: e.globals.hasNegs ? x.percent < 0 ? 1 - (1 + x.percent / 100) : f + x.percent / 100 : x.percent / 100, patternID: Utils.randomId(), width: e.config.fill.image.width ? e.config.fill.image.width : s, height: e.config.fill.image.height ? e.config.fill.image.height : r,
            });
          } const v = this.rectRadius; const y = i.drawRect(g, n, s, r, v); if (y.attr({ cx: g, cy: n }), y.node.classList.add('apexcharts-heatmap-rect'), c.add(y), y.attr({
            fill: b, i: h, index: h, j: u, val: l[h][u], 'stroke-width': this.strokeWidth, stroke: e.globals.stroke.colors[0], color: b,
          }), y.node.addEventListener('mouseenter', i.pathMouseEnter.bind(this, y)), y.node.addEventListener('mouseleave', i.pathMouseLeave.bind(this, y)), y.node.addEventListener('mousedown', i.pathMouseDown.bind(this, y)), e.config.chart.animations.enabled && !e.globals.dataChanged) { let w = 1; e.globals.resized || (w = e.config.chart.animations.speed), this.animateHeatMap(y, g, n, s, r, w); } if (e.globals.dataChanged) { let k = 1; if (this.dynamicAnim.enabled && e.globals.shouldAnimate) { k = this.dynamicAnim.speed; let C = e.globals.previousPaths[h] && e.globals.previousPaths[h][u] && e.globals.previousPaths[h][u].color; C || (C = 'rgba(255, 255, 255, 0)'), this.animateHeatColor(y, Utils.isColorHex(C) ? C : Utils.rgb2hex(C), Utils.isColorHex(b) ? b : Utils.rgb2hex(b), k); } } const A = this.calculateHeatmapDataLabels({
            x: g, y: n, i: h, j: u, series: l, rectHeight: r, rectWidth: s,
          }); A !== null && c.add(A), g += s;
        }n += r, a.add(c);
      } const S = e.globals.yAxisScale[0].result.slice(); e.config.yaxis[0].reversed ? S.unshift('') : S.push(''), e.globals.yAxisScale[0].result = S; const L = e.globals.gridHeight / e.globals.series.length; return e.config.yaxis[0].labels.offsetY = -L / 2, a;
    },
  }, { key: 'checkColorRange', value() { const t = this; const e = this.w.config.plotOptions.heatmap; e.colorScale.ranges.length > 0 && e.colorScale.ranges.map(((e, i) => { e.from < 0 && (t.negRange = !0); })); } }, { key: 'determineHeatColor', value(t, e) { const i = this.w; let a = i.globals.series[t][e]; const s = i.config.plotOptions.heatmap; const r = s.colorScale.inverse ? e : t; let n = i.globals.colors[r]; let o = Math.min.apply(Math, _toConsumableArray(i.globals.series[t])); let l = Math.max.apply(Math, _toConsumableArray(i.globals.series[t])); s.distributed || (o = i.globals.minY, l = i.globals.maxY), void 0 !== s.colorScale.min && (o = s.colorScale.min < i.globals.minY ? s.colorScale.min : i.globals.minY, l = s.colorScale.max > i.globals.maxY ? s.colorScale.max : i.globals.maxY); const h = Math.abs(l) + Math.abs(o); a === 0 && (a = 1e-6); let c = 100 * a / (h === 0 ? h - 1e-6 : h); s.colorScale.ranges.length > 0 && s.colorScale.ranges.map(((t, e) => { if (a >= t.from && a <= t.to) { n = t.color, o = t.from, l = t.to; const i = Math.abs(l) + Math.abs(o); c = 100 * a / (i === 0 ? i - 1e-6 : i); } })); return { color: n, percent: c }; } }, {
    key: 'calculateHeatmapDataLabels',
    value(t) {
      const e = t.x; const i = t.y; const a = t.i; const s = t.j; const r = (t.series, t.rectHeight); const n = t.rectWidth; const o = this.w; const l = o.config.dataLabels; const h = new Graphics(this.ctx); const c = new DataLabels(this.ctx); const d = l.formatter; let g = null; if (l.enabled) {
        g = h.group({ class: 'apexcharts-data-labels' }); const u = l.offsetX; const p = l.offsetY; const f = e + n / 2 + u; const x = i + r / 2 + parseFloat(l.style.fontSize) / 3 + p; const b = d(o.globals.series[a][s], { seriesIndex: a, dataPointIndex: s, w: o }); c.plotDataLabelsText({
          x: f, y: x, text: b, i: a, j: s, parent: g, dataLabelsConfig: l,
        });
      } return g;
    },
  }, {
    key: 'animateHeatMap',
    value(t, e, i, a, s, r) {
      const n = new Animations(this.ctx); n.animateRect(t, {
        x: e + a / 2, y: i + s / 2, width: 0, height: 0,
      }, {
        x: e, y: i, width: a, height: s,
      }, r, (() => { n.animationCompleted(t); }));
    },
  }, { key: 'animateHeatColor', value(t, e, i, a) { t.attr({ fill: e }).animate(a).attr({ fill: i }); } }]), t;
}()); const Radar = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0; const i = this.w; this.graphics = new Graphics(this.ctx), this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors, this.defaultSize = i.globals.svgHeight < i.globals.svgWidth ? i.globals.gridHeight + 1.5 * i.globals.goldenPadding : i.globals.gridWidth, this.maxValue = this.w.globals.maxY, this.minValue = this.w.globals.minY, this.polygons = i.config.plotOptions.radar.polygons; const a = i.globals.labels.slice().sort(((t, e) => e.length - t.length))[0]; const s = this.graphics.getTextRects(a, i.config.xaxis.labels.style.fontSize); this.size = this.defaultSize / 2.1 - i.config.stroke.width - i.config.chart.dropShadow.blur, i.config.xaxis.labels.show && (this.size -= s.width / 1.75), void 0 !== i.config.plotOptions.radar.size && (this.size = i.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = []; } return _createClass(t, [{
    key: 'draw',
    value(t) {
      const e = this; const i = this.w; const a = new Fill(this.ctx); const s = []; const r = new DataLabels(this.ctx); t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen; const n = i.globals.gridWidth / 2; const o = i.globals.gridHeight / 2; const l = this.graphics.group({
        class: 'apexcharts-radar-series apexcharts-plot-series', 'data:innerTranslateX': n, 'data:innerTranslateY': o - 25, transform: 'translate('.concat(n || 0, ', ').concat(o || 0, ')'),
      }); let h = []; let c = null; let d = null; if (this.yaxisLabels = this.graphics.group({ class: 'apexcharts-yaxis' }), t.forEach(((t, n) => {
        const o = e.graphics.group().attr({
          class: 'apexcharts-series', seriesName: Utils.escapeString(i.globals.seriesNames[n]), rel: n + 1, 'data:realIndex': n,
        }); e.dataRadiusOfPercent[n] = [], e.dataRadius[n] = [], e.angleArr[n] = [], t.forEach(((t, i) => { const a = Math.abs(e.maxValue - e.minValue); t += Math.abs(e.minValue), e.dataRadiusOfPercent[n][i] = t / a, e.dataRadius[n][i] = e.dataRadiusOfPercent[n][i] * e.size, e.angleArr[n][i] = i * e.disAngle; })), h = e.getDataPointsPos(e.dataRadius[n], e.angleArr[n]); const l = e.createPaths(h, { x: 0, y: 0 }); c = e.graphics.group({ class: 'apexcharts-series-markers-wrap apexcharts-element-hidden' }), d = e.graphics.group({ class: 'apexcharts-datalabels' }), i.globals.delayedElements.push({ el: c.node, index: n }); const g = {
          i: n, realIndex: n, animationDelay: n, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: 'apexcharts-radar', shouldClipToGrid: !1, bindEventsOnPaths: !1, stroke: i.globals.stroke.colors[n], strokeLineCap: i.config.stroke.lineCap,
        }; let u = null; i.globals.previousPaths.length > 0 && (u = e.getPreviousPath(n)); for (let p = 0; p < l.linePathsTo.length; p++) {
          const f = e.graphics.renderPaths(_objectSpread2({}, g, {
            pathFrom: u === null ? l.linePathsFrom[p] : u, pathTo: l.linePathsTo[p], strokeWidth: Array.isArray(i.config.stroke.width) ? i.config.stroke.width[n] : i.config.stroke.width, fill: 'none', drawShadow: !1,
          })); o.add(f); const x = a.fillPath({ seriesNumber: n }); const b = e.graphics.renderPaths(_objectSpread2({}, g, {
            pathFrom: u === null ? l.areaPathsFrom[p] : u, pathTo: l.areaPathsTo[p], strokeWidth: 0, fill: x, drawShadow: !1,
          })); if (i.config.chart.dropShadow.enabled) { const m = new Filters(e.ctx); const v = i.config.chart.dropShadow; m.dropShadow(b, { ...v, noUserSpaceOnUse: !0 }, n); }o.add(b);
        }t.forEach(((t, a) => {
          const s = new Markers(e.ctx).getMarkerConfig('apexcharts-marker', n, a); const l = e.graphics.drawMarker(h[a].x, h[a].y, s); l.attr('rel', a), l.attr('j', a), l.attr('index', n), l.node.setAttribute('default-marker-size', s.pSize); const g = e.graphics.group({ class: 'apexcharts-series-markers' }); if (g && g.add(l), c.add(g), o.add(c), i.config.dataLabels.enabled) {
            const u = i.config.dataLabels; r.plotDataLabelsText({
              x: h[a].x, y: h[a].y, text: i.globals.series[n][a], textAnchor: 'middle', i: n, j: n, parent: d, offsetCorrection: !1, dataLabelsConfig: _objectSpread2({}, u),
            });
          }o.add(d);
        })), s.push(o);
      })), this.drawPolygons({ parent: l }), i.config.xaxis.labels.show) { const g = this.drawXAxisTexts(); l.add(g); } return l.add(this.yaxisLabels), s.forEach(((t) => { l.add(t); })), l;
    },
  }, { key: 'drawPolygons', value(t) { for (var e = this, i = this.w, a = t.parent, s = i.globals.yAxisScale[0].result.reverse(), r = s.length, n = [], o = this.size / (r - 1), l = 0; l < r; l++)n[l] = o * l; n.reverse(); const h = []; const c = []; n.forEach(((t, i) => { const a = e.getPolygonPos(t); let s = ''; a.forEach(((t, a) => { if (i === 0) { const r = e.graphics.drawLine(t.x, t.y, 0, 0, Array.isArray(e.polygons.connectorColors) ? e.polygons.connectorColors[a] : e.polygons.connectorColors); c.push(r); }a === 0 && e.yaxisLabelsTextsPos.push({ x: t.x, y: t.y }), s += `${t.x},${t.y} `; })), h.push(s); })), h.forEach(((t, s) => { const r = e.polygons.strokeColors; const n = e.graphics.drawPolygon(t, Array.isArray(r) ? r[s] : r, i.globals.radarPolygons.fill.colors[s]); a.add(n); })), c.forEach(((t) => { a.add(t); })), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(((t, i) => { const a = e.drawYAxisTexts(t.x, t.y, i, s[i]); e.yaxisLabels.add(a); })); } }, {
    key: 'drawYAxisTexts',
    value(t, e, i, a) {
      const s = this.w; const r = s.config.yaxis[0]; const n = s.globals.yLabelFormatters[0]; return this.graphics.drawText({
        x: t + r.labels.offsetX, y: e + r.labels.offsetY, text: n(a, i), textAnchor: 'middle', fontSize: r.labels.style.fontSize, fontFamily: r.labels.style.fontFamily, foreColor: r.labels.style.color,
      });
    },
  }, {
    key: 'drawXAxisTexts',
    value() {
      const t = this; const e = this.w; const i = e.config.xaxis.labels; const a = this.graphics.group({ class: 'apexcharts-xaxis' }); const s = this.getPolygonPos(this.size); return e.globals.labels.forEach(((r, n) => {
        const o = e.config.xaxis.labels.formatter; const l = new DataLabels(t.ctx); if (s[n]) {
          const h = t.getTextPos(s[n], t.size); const c = o(r, { seriesIndex: -1, dataPointIndex: n, w: e }); l.plotDataLabelsText({
            x: h.newX, y: h.newY, text: c, textAnchor: h.textAnchor, i: n, j: n, parent: a, color: i.style.colors[n] ? i.style.colors[n] : '#a8a8a8', dataLabelsConfig: _objectSpread2({ textAnchor: h.textAnchor, dropShadow: { enabled: !1 } }, i), offsetCorrection: !1,
          });
        }
      })), a;
    },
  }, {
    key: 'createPaths',
    value(t, e) {
      const i = this; const a = []; let s = []; const r = []; let n = []; if (t.length) { s = [this.graphics.move(e.x, e.y)], n = [this.graphics.move(e.x, e.y)]; let o = this.graphics.move(t[0].x, t[0].y); let l = this.graphics.move(t[0].x, t[0].y); t.forEach(((e, a) => { o += i.graphics.line(e.x, e.y), l += i.graphics.line(e.x, e.y), a === t.length - 1 && (o += 'Z', l += 'Z'); })), a.push(o), r.push(l); } return {
        linePathsFrom: s, linePathsTo: a, areaPathsFrom: n, areaPathsTo: r,
      };
    },
  }, { key: 'getTextPos', value(t, e) { let i = 'middle'; let a = t.x; let s = t.y; return Math.abs(t.x) >= 10 ? t.x > 0 ? (i = 'start', a += 10) : t.x < 0 && (i = 'end', a -= 10) : i = 'middle', Math.abs(t.y) >= e - 10 && (t.y < 0 ? s -= 10 : t.y > 0 && (s += 10)), { textAnchor: i, newX: a, newY: s }; } }, { key: 'getPreviousPath', value(t) { for (var e = this.w, i = null, a = 0; a < e.globals.previousPaths.length; a++) { const s = e.globals.previousPaths[a]; s.paths.length > 0 && parseInt(s.realIndex, 10) === parseInt(t, 10) && void 0 !== e.globals.previousPaths[a].paths[0] && (i = e.globals.previousPaths[a].paths[0].d); } return i; } }, { key: 'getDataPointsPos', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen; t = t || [], e = e || []; for (var a = [], s = 0; s < i; s++) { const r = {}; r.x = t[s] * Math.sin(e[s]), r.y = -t[s] * Math.cos(e[s]), a.push(r); } return a; } }, { key: 'getPolygonPos', value(t) { for (var e = [], i = 2 * Math.PI / this.dataPointsLen, a = 0; a < this.dataPointsLen; a++) { const s = {}; s.x = t * Math.sin(a * i), s.y = -t * Math.cos(a * i), e.push(s); } return e; } }]), t;
}()); const Radial = (function (t) {
  function e(t) { let i; _classCallCheck(this, e), (i = _possibleConstructorReturn(this, _getPrototypeOf(e).call(this, t))).ctx = t, i.w = t.w, i.animBeginArr = [0], i.animDur = 0; const a = i.w; return i.startAngle = a.config.plotOptions.radialBar.startAngle, i.endAngle = a.config.plotOptions.radialBar.endAngle, i.totalAngle = Math.abs(a.config.plotOptions.radialBar.endAngle - a.config.plotOptions.radialBar.startAngle), i.trackStartAngle = a.config.plotOptions.radialBar.track.startAngle, i.trackEndAngle = a.config.plotOptions.radialBar.track.endAngle, i.radialDataLabels = a.config.plotOptions.radialBar.dataLabels, i.trackStartAngle || (i.trackStartAngle = i.startAngle), i.trackEndAngle || (i.trackEndAngle = i.endAngle), i.endAngle === 360 && (i.endAngle = 359.99), i.fullAngle = 360 - a.config.plotOptions.radialBar.endAngle - a.config.plotOptions.radialBar.startAngle, i.margin = parseInt(a.config.plotOptions.radialBar.track.margin, 10), i; } return _inherits(e, Pie), _createClass(e, [{
    key: 'draw',
    value(t) {
      const e = this.w; const i = new Graphics(this.ctx); const a = i.group({ class: 'apexcharts-radialbar' }); if (e.globals.noData) return a; const s = i.group(); const r = this.defaultSize / 2; const n = e.globals.gridWidth / 2; let o = this.defaultSize / 2.05 - e.config.stroke.width - e.config.chart.dropShadow.blur; void 0 !== e.config.plotOptions.radialBar.size && (o = e.config.plotOptions.radialBar.size); const l = e.globals.fill.colors; if (e.config.plotOptions.radialBar.track.show) {
        const h = this.drawTracks({
          size: o, centerX: n, centerY: r, colorArr: l, series: t,
        }); s.add(h);
      } const c = this.drawArcs({
        size: o, centerX: n, centerY: r, colorArr: l, series: t,
      }); let d = 360; e.config.plotOptions.radialBar.startAngle < 0 && (d = this.totalAngle); const g = (360 - d) / 360; if (e.globals.radialSize = o - o * g, this.radialDataLabels.value.show) { const u = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY); e.globals.radialSize += u * g; } return s.add(c.g), e.config.plotOptions.radialBar.hollow.position === 'front' && (c.g.add(c.elHollow), c.dataLabels && c.g.add(c.dataLabels)), a.add(s), a;
    },
  }, {
    key: 'drawTracks',
    value(t) {
      const e = this.w; const i = new Graphics(this.ctx); const a = i.group({ class: 'apexcharts-tracks' }); const s = new Filters(this.ctx); const r = new Fill(this.ctx); const n = this.getStrokeWidth(t); t.size -= n / 2; for (let o = 0; o < t.series.length; o++) {
        const l = i.group({ class: 'apexcharts-radialbar-track apexcharts-track' }); a.add(l), l.attr({ rel: o + 1 }), t.size = t.size - n - this.margin; const h = e.config.plotOptions.radialBar.track; const c = r.fillPath({
          seriesNumber: 0, size: t.size, fillColors: Array.isArray(h.background) ? h.background[o] : h.background, solid: !0,
        }); const d = this.trackStartAngle; let g = this.trackEndAngle; Math.abs(g) + Math.abs(d) >= 360 && (g = 360 - Math.abs(this.startAngle) - 0.1); const u = i.drawPath({
          d: '', stroke: c, strokeWidth: n * parseInt(h.strokeWidth, 10) / 100, fill: 'none', strokeOpacity: h.opacity, classes: 'apexcharts-radialbar-area',
        }); if (h.dropShadow.enabled) { const p = h.dropShadow; s.dropShadow(u, p); }l.add(u), u.attr('id', `apexcharts-radialbarTrack-${o}`), this.animatePaths(u, {
          centerX: t.centerX, centerY: t.centerY, endAngle: g, startAngle: d, size: t.size, i: o, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: !0, easing: e.globals.easing,
        });
      } return a;
    },
  }, {
    key: 'drawArcs',
    value(t) {
      const e = this.w; const i = new Graphics(this.ctx); const a = new Fill(this.ctx); const s = new Filters(this.ctx); const r = i.group(); const n = this.getStrokeWidth(t); t.size -= n / 2; let o = e.config.plotOptions.radialBar.hollow.background; const l = t.size - n * t.series.length - this.margin * t.series.length - n * parseInt(e.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2; const h = l - e.config.plotOptions.radialBar.hollow.margin; void 0 !== e.config.plotOptions.radialBar.hollow.image && (o = this.drawHollowImage(t, r, l, o)); const c = this.drawHollow({
        size: h, centerX: t.centerX, centerY: t.centerY, fill: o,
      }); if (e.config.plotOptions.radialBar.hollow.dropShadow.enabled) { const d = e.config.plotOptions.radialBar.hollow.dropShadow; s.dropShadow(c, d); } let g = 1; !this.radialDataLabels.total.show && e.globals.series.length > 1 && (g = 0); let u = null; this.radialDataLabels.show && (u = this.renderInnerDataLabels(this.radialDataLabels, {
        hollowSize: l, centerX: t.centerX, centerY: t.centerY, opacity: g,
      })), e.config.plotOptions.radialBar.hollow.position === 'back' && (r.add(c), u && r.add(u)); let p = !1; e.config.plotOptions.radialBar.inverseOrder && (p = !0); for (let f = p ? t.series.length - 1 : 0; p ? f >= 0 : f < t.series.length; p ? f-- : f++) {
        const x = i.group({ class: 'apexcharts-series apexcharts-radial-series', seriesName: Utils.escapeString(e.globals.seriesNames[f]) }); r.add(x), x.attr({ rel: f + 1, 'data:realIndex': f }), this.ctx.series.addCollapsedClassToSeries(x, f), t.size = t.size - n - this.margin; const b = a.fillPath({ seriesNumber: f, size: t.size, value: t.series[f] }); const m = this.startAngle; let v = void 0; const y = Utils.negToZero(t.series[f] > 100 ? 100 : t.series[f]) / 100; let w = Math.round(this.totalAngle * y) + this.startAngle; let k = void 0; e.globals.dataChanged && (v = this.startAngle, k = Math.round(this.totalAngle * Utils.negToZero(e.globals.previousPaths[f]) / 100) + v), Math.abs(w) + Math.abs(m) >= 360 && (w -= 0.01), Math.abs(k) + Math.abs(v) >= 360 && (k -= 0.01); const C = w - m; const A = Array.isArray(e.config.stroke.dashArray) ? e.config.stroke.dashArray[f] : e.config.stroke.dashArray; const S = i.drawPath({
          d: '', stroke: b, strokeWidth: n, fill: 'none', fillOpacity: e.config.fill.opacity, classes: `apexcharts-radialbar-area apexcharts-radialbar-slice-${f}`, strokeDashArray: A,
        }); if (Graphics.setAttrs(S.node, { 'data:angle': C, 'data:value': t.series[f] }), e.config.chart.dropShadow.enabled) { const L = e.config.chart.dropShadow; s.dropShadow(S, L, f); } this.addListeners(S, this.radialDataLabels), x.add(S), S.attr({ index: 0, j: f }); let P = 0; !this.initialAnim || e.globals.resized || e.globals.dataChanged || (P = (w - m) / 360 * e.config.chart.animations.speed, this.animDur = P / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), e.globals.dataChanged && (P = (w - m) / 360 * e.config.chart.animations.dynamicAnimation.speed, this.animDur = P / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), this.animatePaths(S, {
          centerX: t.centerX, centerY: t.centerY, endAngle: w, startAngle: m, prevEndAngle: k, prevStartAngle: v, size: t.size, i: f, totalItems: 2, animBeginArr: this.animBeginArr, dur: P, shouldSetPrevPaths: !0, easing: e.globals.easing,
        });
      } return { g: r, elHollow: c, dataLabels: u };
    },
  }, {
    key: 'drawHollow',
    value(t) {
      const e = new Graphics(this.ctx).drawCircle(2 * t.size); return e.attr({
        class: 'apexcharts-radialbar-hollow', cx: t.centerX, cy: t.centerY, r: t.size, fill: t.fill,
      }), e;
    },
  }, {
    key: 'drawHollowImage',
    value(t, e, i, a) {
      const s = this.w; const r = new Fill(this.ctx); const n = Utils.randomId(); const o = s.config.plotOptions.radialBar.hollow.image; if (s.config.plotOptions.radialBar.hollow.imageClipped) {
        r.clippedImgArea({
          width: i, height: i, image: o, patternID: 'pattern'.concat(s.globals.cuid).concat(n),
        }), a = 'url(#pattern'.concat(s.globals.cuid).concat(n, ')');
      } else { const l = s.config.plotOptions.radialBar.hollow.imageWidth; const h = s.config.plotOptions.radialBar.hollow.imageHeight; if (void 0 === l && void 0 === h) { const c = s.globals.dom.Paper.image(o).loaded((function (e) { this.move(t.centerX - e.width / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - e.height / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY); })); e.add(c); } else { const d = s.globals.dom.Paper.image(o).loaded((function (e) { this.move(t.centerX - l / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - h / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l, h); })); e.add(d); } } return a;
    },
  }, { key: 'getStrokeWidth', value(t) { const e = this.w; return t.size * (100 - parseInt(e.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t.series.length + 1) - this.margin; } }]), e;
}()); const RangeBar = (function (t) {
  function e() { return _classCallCheck(this, e), _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments)); } return _inherits(e, Bar), _createClass(e, [{
    key: 'draw',
    value(t, e) {
      const i = this.w; const a = new Graphics(this.ctx); this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.barHelpers.initVariables(t); for (var s = a.group({ class: 'apexcharts-rangebar-series apexcharts-plot-series' }), r = 0; r < t.length; r++) {
        var n; var o; var l; let h = void 0; let c = void 0; let d = void 0; const g = i.globals.comboCharts ? e[r] : r; const u = a.group({
          class: 'apexcharts-series', seriesName: Utils.escapeString(i.globals.seriesNames[g]), rel: r + 1, 'data:realIndex': g,
        }); t[r].length > 0 && (this.visibleI += 1); let p = 0; let f = 0; this.yRatio.length > 1 && (this.yaxisIndex = g); const x = this.barHelpers.initialPositions(); c = x.y, l = x.zeroW, h = x.x, f = x.barWidth, n = x.xDivision, o = x.zeroH; for (let b = a.group({ class: 'apexcharts-datalabels' }), m = 0; m < i.globals.dataPoints; m++) {
          const v = this.barHelpers.getStrokeWidth(r, m, g); const y = this.seriesRangeStart[r][m]; const w = this.seriesRangeEnd[r][m]; let k = null; let C = null; const A = {
            x: h, y: c, strokeWidth: v, elSeries: u,
          }; if (d = x.yDivision, p = x.barHeight, this.isHorizontal) {
            C = c + p * this.visibleI; const S = (d - p * this.seriesLen) / 2; if (void 0 === i.config.series[r].data[m]) break; if (this.isTimelineBar && i.config.series[r].data[m].x) {
              const L = this.detectOverlappingBars({
                i: r, j: m, barYPosition: C, srty: S, barHeight: p, yDivision: d, initPositions: x,
              }); p = L.barHeight, C = L.barYPosition;
            }f = (k = this.drawRangeBarPaths(_objectSpread2({
              indexes: { i: r, j: m, realIndex: g }, barHeight: p, barYPosition: C, zeroW: l, yDivision: d, y1: y, y2: w,
            }, A))).barWidth;
          } else {
            p = (k = this.drawRangeColumnPaths(_objectSpread2({
              indexes: { i: r, j: m, realIndex: g }, zeroH: o, barWidth: f, xDivision: n,
            }, A))).barHeight;
          } c = k.y, h = k.x; const P = this.barHelpers.getPathFillColor(t, r, m, g); const T = i.globals.stroke.colors[g]; this.renderSeries({
            realIndex: g, pathFill: P, lineFill: T, j: m, i: r, x: h, y: c, y1: y, y2: w, pathFrom: k.pathFrom, pathTo: k.pathTo, strokeWidth: v, elSeries: u, series: t, barHeight: p, barYPosition: C, barWidth: f, elDataLabelsWrap: b, visibleSeries: this.visibleI, type: 'rangebar',
          });
        }s.add(u);
      } return s;
    },
  }, { key: 'detectOverlappingBars', value(t) { const e = t.i; const i = t.j; let a = t.barYPosition; const s = t.srty; let r = t.barHeight; const n = t.yDivision; const o = t.initPositions; const l = this.w; let h = []; const c = l.config.series[e].data[i].rangeName; const d = l.config.series[e].data[i].x; const g = l.globals.labels.indexOf(d); const u = l.globals.seriesRangeBarTimeline[e].findIndex(((t) => t.x === d && t.overlaps.length > 0)); return a = s + r * this.visibleI + n * g, u > -1 && (h = l.globals.seriesRangeBarTimeline[e][u].overlaps).indexOf(c) > -1 && (a = (r = o.barHeight / h.length) * this.visibleI + n * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + r * (this.visibleI + h.indexOf(c)) + n * g), { barYPosition: a, barHeight: r }; } }, {
    key: 'drawRangeColumnPaths',
    value(t) {
      const e = t.indexes; let i = t.x; const a = t.strokeWidth; const s = t.xDivision; const r = t.barWidth; const n = t.zeroH; const o = this.w; const l = new Graphics(this.ctx); const h = e.i; const c = e.j; const d = this.yRatio[this.yaxisIndex]; const g = e.realIndex; const u = this.getRangeValue(g, c); let p = Math.min(u.start, u.end); let f = Math.max(u.start, u.end); o.globals.isXNumeric && (i = (o.globals.seriesX[h][c] - o.globals.minX) / this.xRatio - r / 2); const x = i + r * this.visibleI; void 0 === this.series[h][c] || this.series[h][c] === null ? p = n : (p = n - p / d, f = n - f / d); const b = Math.abs(f - p); let m = l.move(x, n); let v = l.move(x, p); return o.globals.previousPaths.length > 0 && (v = this.getPreviousPath(g, c, !0)), m = l.move(x, f) + l.line(x + r, f) + l.line(x + r, p) + l.line(x, p) + l.line(x, f - a / 2), v = v + l.move(x, p) + l.line(x + r, p) + l.line(x + r, p) + l.line(x, p), o.globals.isXNumeric || (i += s), {
        pathTo: m, pathFrom: v, barHeight: b, x: i, y: f, barXPosition: x,
      };
    },
  }, {
    key: 'drawRangeBarPaths',
    value(t) {
      const e = t.indexes; let i = t.y; const a = t.y1; const s = t.y2; const r = t.yDivision; const n = t.barHeight; const o = t.barYPosition; const l = t.zeroW; const h = this.w; const c = new Graphics(this.ctx); const d = l + a / this.invertedYRatio; const g = l + s / this.invertedYRatio; let u = c.move(l, o); let p = c.move(d, o); h.globals.previousPaths.length > 0 && (p = this.getPreviousPath(e.realIndex, e.j)); const f = Math.abs(g - d); return u = c.move(d, o) + c.line(g, o) + c.line(g, o + n) + c.line(d, o + n) + c.line(d, o), p = p + c.line(d, o) + c.line(d, o + n) + c.line(d, o + n) + c.line(d, o), h.globals.isXNumeric || (i += r), {
        pathTo: u, pathFrom: p, barWidth: f, x: g, y: i,
      };
    },
  }, { key: 'getRangeValue', value(t, e) { const i = this.w; return { start: i.globals.seriesRangeStart[t][e], end: i.globals.seriesRangeEnd[t][e] }; } }]), e;
}()); const Helpers$4 = (function () { function t(e) { _classCallCheck(this, t), this.w = e.w, this.lineCtx = e; } return _createClass(t, [{ key: 'sameValueSeriesFix', value(t, e) { const i = this.w; if (i.config.chart.type === 'line' && (i.config.fill.type === 'gradient' || i.config.fill.type[t] === 'gradient') && new CoreUtils(this.lineCtx.ctx, i).seriesHaveSameValues(t)) { const a = e[t].slice(); a[a.length - 1] = a[a.length - 1] + 1e-6, e[t] = a; } return e; } }, { key: 'calculatePoints', value(t) { const e = t.series; const i = t.realIndex; const a = t.x; const s = t.y; const r = t.i; const n = t.j; const o = t.prevY; const l = this.w; const h = []; const c = []; if (n === 0) { let d = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX; l.globals.isXNumeric && (d = (l.globals.seriesX[i][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX), h.push(d), c.push(Utils.isNumber(e[r][0]) ? o + l.config.markers.offsetY : null), h.push(a + l.config.markers.offsetX), c.push(Utils.isNumber(e[r][n + 1]) ? s + l.config.markers.offsetY : null); } else h.push(a + l.config.markers.offsetX), c.push(Utils.isNumber(e[r][n + 1]) ? s + l.config.markers.offsetY : null); return { x: h, y: c }; } }, { key: 'checkPreviousPaths', value(t) { for (var e = t.pathFromLine, i = t.pathFromArea, a = t.realIndex, s = this.w, r = 0; r < s.globals.previousPaths.length; r++) { const n = s.globals.previousPaths[r]; (n.type === 'line' || n.type === 'area') && n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(a, 10) && (n.type === 'line' ? (this.lineCtx.appendPathFrom = !1, e = s.globals.previousPaths[r].paths[0].d) : n.type === 'area' && (this.lineCtx.appendPathFrom = !1, i = s.globals.previousPaths[r].paths[0].d, s.config.stroke.show && (e = s.globals.previousPaths[r].paths[1].d))); } return { pathFromLine: e, pathFromArea: i }; } }, { key: 'determineFirstPrevY', value(t) { const e = t.i; const i = t.series; let a = t.prevY; let s = t.lineYPosition; const r = this.w; if (void 0 !== i[e][0])a = (s = r.config.chart.stacked && e > 0 ? this.lineCtx.prevSeriesY[e - 1][0] : this.lineCtx.zeroY) - i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0); else if (r.config.chart.stacked && e > 0 && void 0 === i[e][0]) for (let n = e - 1; n >= 0; n--) if (i[n][0] !== null && void 0 !== i[n][0]) { a = s = this.lineCtx.prevSeriesY[n][0]; break; } return { prevY: a, lineYPosition: s }; } }]), t; }()); const Line = (function () {
  function t(e, i, a) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.xyRatios = i, this.pointsChart = !(this.w.config.chart.type !== 'bubble' && this.w.config.chart.type !== 'scatter') || a, this.scatter = new Scatter(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Helpers$4(this), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0; } return _createClass(t, [{
    key: 'draw',
    value(t, e, i) {
      const a = this.w; const s = new Graphics(this.ctx); const r = a.globals.comboCharts ? e : a.config.chart.type; const n = s.group({ class: 'apexcharts-'.concat(r, '-series apexcharts-plot-series') }); const o = new CoreUtils(this.ctx, a); this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = o.getLogSeries(t), this.yRatio = o.getLogYRatios(this.yRatio); for (var l = [], h = 0; h < t.length; h++) {
        t = this.lineHelpers.sameValueSeriesFix(h, t); const c = a.globals.comboCharts ? i[h] : h; this._initSerieVariables(t, h, c); const d = []; const g = []; let u = a.globals.padHorizontal + this.categoryAxisCorrection; this.ctx.series.addCollapsedClassToSeries(this.elSeries, c), a.globals.isXNumeric && a.globals.seriesX.length > 0 && (u = (a.globals.seriesX[c][0] - a.globals.minX) / this.xRatio), g.push(u); var p; const f = u; const x = f; let b = this.zeroY; b = this.lineHelpers.determineFirstPrevY({
          i: h, series: t, prevY: b, lineYPosition: 0,
        }).prevY, d.push(b), p = b; const m = this._calculatePathsFrom({
          series: t, i: h, realIndex: c, prevX: x, prevY: b,
        }); const v = this._iterateOverDataPoints({
          series: t, realIndex: c, i: h, x: u, y: 1, pX: f, pY: p, pathsFrom: m, linePaths: [], areaPaths: [], seriesIndex: i, lineYPosition: 0, xArrj: g, yArrj: d,
        }); this._handlePaths({
          type: r, realIndex: c, i: h, paths: v,
        }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l.push(this.elSeries);
      } for (let y = l.length; y > 0; y--)n.add(l[y - 1]); return n;
    },
  }, { key: '_initSerieVariables', value(t, e, i) { const a = this.w; const s = new Graphics(this.ctx); this.xDivision = a.globals.gridWidth / (a.globals.dataPoints - (a.config.xaxis.tickPlacement === 'on' ? 1 : 0)), this.strokeWidth = Array.isArray(a.config.stroke.width) ? a.config.stroke.width[i] : a.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = a.config.yaxis[this.yaxisIndex] && a.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, this.zeroY > a.globals.gridHeight && (this.areaBottomY = a.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s.group({ class: 'apexcharts-series', seriesName: Utils.escapeString(a.globals.seriesNames[i]) }), this.elPointsMain = s.group({ class: 'apexcharts-series-markers-wrap' }), this.elDataLabelsWrap = s.group({ class: 'apexcharts-datalabels' }); const r = t[e].length === a.globals.dataPoints; this.elSeries.attr({ 'data:longestSeries': r, rel: e + 1, 'data:realIndex': i }), this.appendPathFrom = !0; } }, {
    key: '_calculatePathsFrom',
    value(t) {
      let e; let i; let a; let s; const r = t.series; const n = t.i; const o = t.realIndex; let l = t.prevX; let h = t.prevY; const c = this.w; const d = new Graphics(this.ctx); if (r[n][0] === null) { for (let g = 0; g < r[n].length; g++) if (r[n][g] !== null) { l = this.xDivision * g, h = this.zeroY - r[n][g] / this.yRatio[this.yaxisIndex], e = d.move(l, h), i = d.move(l, this.areaBottomY); break; } } else e = d.move(l, h), i = d.move(l, this.areaBottomY) + d.line(l, h); if (a = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), s = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), c.globals.previousPaths.length > 0) { const u = this.lineHelpers.checkPreviousPaths({ pathFromLine: a, pathFromArea: s, realIndex: o }); a = u.pathFromLine, s = u.pathFromArea; } return {
        prevX: l, prevY: h, linePath: e, areaPath: i, pathFromLine: a, pathFromArea: s,
      };
    },
  }, {
    key: '_handlePaths',
    value(t) {
      const e = t.type; const i = t.realIndex; const a = t.i; const s = t.paths; const r = this.w; const n = new Graphics(this.ctx); const o = new Fill(this.ctx); this.prevSeriesY.push(s.yArrj), r.globals.seriesXvalues[i] = s.xArrj, r.globals.seriesYvalues[i] = s.yArrj, this.pointsChart || r.globals.delayedElements.push({ el: this.elPointsMain.node, index: i }); const l = {
        i: a, realIndex: i, animationDelay: a, initialSpeed: r.config.chart.animations.speed, dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed, className: 'apexcharts-'.concat(e),
      }; if (e === 'area') {
        for (let h = o.fillPath({ seriesNumber: i }), c = 0; c < s.areaPaths.length; c++) {
          const d = n.renderPaths(_objectSpread2({}, l, {
            pathFrom: s.pathFromArea, pathTo: s.areaPaths[c], stroke: 'none', strokeWidth: 0, strokeLineCap: null, fill: h,
          })); this.elSeries.add(d);
        }
      } if (r.config.stroke.show && !this.pointsChart) {
        let g = null; g = e === 'line' ? o.fillPath({ seriesNumber: i, i: a }) : r.globals.stroke.colors[i]; for (let u = 0; u < s.linePaths.length; u++) {
          const p = n.renderPaths(_objectSpread2({}, l, {
            pathFrom: s.pathFromLine, pathTo: s.linePaths[u], stroke: g, strokeWidth: this.strokeWidth, strokeLineCap: r.config.stroke.lineCap, fill: 'none',
          })); this.elSeries.add(p);
        }
      }
    },
  }, {
    key: '_iterateOverDataPoints',
    value(t) {
      for (var e = t.series, i = t.realIndex, a = t.i, s = t.x, r = t.y, n = t.pX, o = t.pY, l = t.pathsFrom, h = t.linePaths, c = t.areaPaths, d = t.seriesIndex, g = t.lineYPosition, u = t.xArrj, p = t.yArrj, f = this.w, x = new Graphics(this.ctx), b = this.yRatio, m = l.prevY, v = l.linePath, y = l.areaPath, w = l.pathFromLine, k = l.pathFromArea, C = Utils.isNumber(f.globals.minYArr[i]) ? f.globals.minYArr[i] : f.globals.minY, A = f.globals.dataPoints > 1 ? f.globals.dataPoints - 1 : f.globals.dataPoints, S = 0; S < A; S++) {
        const L = void 0 === e[a][S + 1] || e[a][S + 1] === null; if (f.globals.isXNumeric) { let P = f.globals.seriesX[i][S + 1]; void 0 === f.globals.seriesX[i][S + 1] && (P = f.globals.seriesX[i][A - 1]), s = (P - f.globals.minX) / this.xRatio; } else s += this.xDivision; g = f.config.chart.stacked && a > 0 && f.globals.collapsedSeries.length < f.config.series.length - 1 ? this.prevSeriesY[a - 1][S + 1] : this.zeroY, r = L ? g - C / b[this.yaxisIndex] + 2 * (this.isReversed ? C / b[this.yaxisIndex] : 0) : g - e[a][S + 1] / b[this.yaxisIndex] + 2 * (this.isReversed ? e[a][S + 1] / b[this.yaxisIndex] : 0), u.push(s), p.push(r); const T = this._createPaths({
          series: e, i: a, realIndex: i, j: S, x: s, y: r, pX: n, pY: o, linePath: v, areaPath: y, linePaths: h, areaPaths: c, seriesIndex: d,
        }); c = T.areaPaths, h = T.linePaths, n = T.pX, o = T.pY, y = T.areaPath, v = T.linePath, this.appendPathFrom && (w += x.line(s, this.zeroY), k += x.line(s, this.zeroY)), this._handleMarkersAndLabels({
          series: e, x: s, y: r, prevY: m, i: a, j: S, realIndex: i,
        });
      } return {
        yArrj: p, xArrj: u, pathFromArea: k, areaPaths: c, pathFromLine: w, linePaths: h,
      };
    },
  }, {
    key: '_handleMarkersAndLabels',
    value(t) {
      const e = t.series; const i = t.x; const a = t.y; const s = t.prevY; const r = t.i; const n = t.j; const o = t.realIndex; const l = this.w; const h = new DataLabels(this.ctx); const c = this.lineHelpers.calculatePoints({
        series: e, x: i, y: a, realIndex: o, i: r, j: n, prevY: s,
      }); if (this.pointsChart) {
        this.scatter.draw(this.elSeries, n, {
          realIndex: o, pointsPos: c, zRatio: this.zRatio, elParent: this.elPointsMain,
        });
      } else { const d = new Markers(this.ctx); l.globals.series[r].length > 1 && this.elPointsMain.node.classList.add('apexcharts-element-hidden'); const g = d.plotChartMarkers(c, o, n + 1); g !== null && this.elPointsMain.add(g); } const u = h.drawDataLabel(c, o, n + 1, null, this.strokeWidth); u !== null && this.elDataLabelsWrap.add(u);
    },
  }, {
    key: '_createPaths',
    value(t) {
      const e = t.series; const { i } = t; const a = t.realIndex; const s = t.j; const r = t.x; const n = t.y; let o = t.pX; let l = t.pY; let h = t.linePath; let c = t.areaPath; const d = t.linePaths; const g = t.areaPaths; const u = t.seriesIndex; const p = this.w; const f = new Graphics(this.ctx); let x = p.config.stroke.curve; const b = this.areaBottomY; if (Array.isArray(p.config.stroke.curve) && (x = Array.isArray(u) ? p.config.stroke.curve[u[i]] : p.config.stroke.curve[i]), x === 'smooth') { const m = 0.35 * (r - o); p.globals.hasNullValues ? (e[i][s] !== null && (e[i][s + 1] !== null ? (h = f.move(o, l) + f.curve(o + m, l, r - m, n, r + 1, n), c = `${f.move(o + 1, l) + f.curve(o + m, l, r - m, n, r + 1, n) + f.line(r, b) + f.line(o, b)}z`) : (h = f.move(o, l), c = `${f.move(o, l)}z`)), d.push(h), g.push(c)) : (h += f.curve(o + m, l, r - m, n, r, n), c += f.curve(o + m, l, r - m, n, r, n)), o = r, l = n, s === e[i].length - 2 && (c = `${c + f.curve(o, l, r, n, r, b) + f.move(r, n)}z`, p.globals.hasNullValues || (d.push(h), g.push(c))); } else { if (e[i][s + 1] === null) { h += f.move(r, n); const v = p.globals.isXNumeric ? (p.globals.seriesX[a][s] - p.globals.minX) / this.xRatio : r - this.xDivision; c = `${c + f.line(v, b) + f.move(r, n)}z`; }e[i][s] === null && (h += f.move(r, n), c += f.move(r, b)), x === 'stepline' ? (h = h + f.line(r, null, 'H') + f.line(null, n, 'V'), c = c + f.line(r, null, 'H') + f.line(null, n, 'V')) : x === 'straight' && (h += f.line(r, n), c += f.line(r, n)), s === e[i].length - 2 && (c = `${c + f.line(r, b) + f.move(r, n)}z`, d.push(h), g.push(c)); } return {
        linePaths: d, areaPaths: g, pX: o, pY: l, linePath: h, areaPath: c,
      };
    },
  }]), t;
}()); const TimeScale = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC; } return _createClass(t, [{
    key: 'calculateTimeScaleTicks',
    value(t, e) {
      const i = this; const a = this.w; if (a.globals.allSeriesCollapsed) return a.globals.labels = [], a.globals.timescaleLabels = [], []; const s = new DateTime(this.ctx); const r = (e - t) / 864e5; this.determineInterval(r), a.globals.disableZoomIn = !1, a.globals.disableZoomOut = !1, r < 0.005 ? a.globals.disableZoomIn = !0 : r > 5e4 && (a.globals.disableZoomOut = !0); const n = s.getTimeUnitsfromTimestamp(t, e, this.utc); const o = a.globals.gridWidth / r; const l = o / 24; const h = l / 60; const c = Math.floor(24 * r); const d = Math.floor(24 * r * 60); const g = Math.floor(r); const u = Math.floor(r / 30); const p = Math.floor(r / 365); const f = {
        minMinute: n.minMinute, minHour: n.minHour, minDate: n.minDate, minMonth: n.minMonth, minYear: n.minYear,
      }; const x = {
        firstVal: f, currentMinute: f.minMinute, currentHour: f.minHour, currentMonthDate: f.minDate, currentDate: f.minDate, currentMonth: f.minMonth, currentYear: f.minYear, daysWidthOnXAxis: o, hoursWidthOnXAxis: l, minutesWidthOnXAxis: h, numberOfMinutes: d, numberOfHours: c, numberOfDays: g, numberOfMonths: u, numberOfYears: p,
      }; switch (this.tickInterval) { case 'years': this.generateYearScale(x); break; case 'months': case 'half_year': this.generateMonthScale(x); break; case 'months_days': case 'months_fortnight': case 'days': case 'week_days': this.generateDayScale(x); break; case 'hours': this.generateHourScale(x); break; case 'minutes': this.generateMinuteScale(x); } const b = this.timeScaleArray.map(((t) => {
        const e = {
          position: t.position, unit: t.unit, year: t.year, day: t.day ? t.day : 1, hour: t.hour ? t.hour : 0, month: t.month + 1,
        }; return t.unit === 'month' ? _objectSpread2({}, e, { day: 1, value: t.value + 1 }) : t.unit === 'day' || t.unit === 'hour' ? _objectSpread2({}, e, { value: t.value }) : t.unit === 'minute' ? _objectSpread2({}, e, { value: t.value, minute: t.value }) : t;
      })); return b.filter(((t) => { let e = 1; let s = Math.ceil(a.globals.gridWidth / 120); const r = t.value; void 0 !== a.config.xaxis.tickAmount && (s = a.config.xaxis.tickAmount), b.length > s && (e = Math.floor(b.length / s)); let n = !1; let o = !1; switch (i.tickInterval) { case 'half_year': e = 7, t.unit === 'year' && (n = !0); break; case 'months': e = 1, t.unit === 'year' && (n = !0); break; case 'months_fortnight': e = 15, t.unit !== 'year' && t.unit !== 'month' || (n = !0), r === 30 && (o = !0); break; case 'months_days': e = 10, t.unit === 'month' && (n = !0), r === 30 && (o = !0); break; case 'week_days': e = 8, t.unit === 'month' && (n = !0); break; case 'days': e = 1, t.unit === 'month' && (n = !0); break; case 'hours': t.unit === 'day' && (n = !0); break; case 'minutes': r % 5 != 0 && (o = !0); } if (i.tickInterval === 'minutes' || i.tickInterval === 'hours') { if (!o) return !0; } else if ((r % e == 0 || n) && !o) return !0; }));
    },
  }, { key: 'recalcDimensionsBasedOnFormat', value(t, e) { const i = this.w; const a = this.formatDates(t); const s = this.removeOverlappingTS(a); i.globals.timescaleLabels = s.slice(), new Dimensions(this.ctx).plotCoords(); } }, { key: 'determineInterval', value(t) { switch (!0) { case t > 1825: this.tickInterval = 'years'; break; case t > 800 && t <= 1825: this.tickInterval = 'half_year'; break; case t > 180 && t <= 800: this.tickInterval = 'months'; break; case t > 90 && t <= 180: this.tickInterval = 'months_fortnight'; break; case t > 60 && t <= 90: this.tickInterval = 'months_days'; break; case t > 30 && t <= 60: this.tickInterval = 'week_days'; break; case t > 2 && t <= 30: this.tickInterval = 'days'; break; case t > 0.1 && t <= 2: this.tickInterval = 'hours'; break; case t < 0.1: this.tickInterval = 'minutes'; break; default: this.tickInterval = 'days'; } } }, {
    key: 'generateYearScale',
    value(t) {
      const e = t.firstVal; const i = t.currentMonth; const a = t.currentYear; const s = t.daysWidthOnXAxis; const r = t.numberOfYears; let n = e.minYear; let o = 0; const l = new DateTime(this.ctx); if (e.minDate > 1 && e.minMonth > 0) {
        const h = l.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate); o = (l.determineDaysOfYear(e.minYear) - h + 1) * s, n = e.minYear + 1, this.timeScaleArray.push({
          position: o, value: n, unit: 'year', year: n, month: Utils.monthMod(i + 1),
        });
      } else {
        e.minDate === 1 && e.minMonth === 0 && this.timeScaleArray.push({
          position: o, value: n, unit: 'year', year: a, month: Utils.monthMod(i + 1),
        });
      } for (let c = n, d = o, g = 0; g < r; g++) {
        c++, d = l.determineDaysOfYear(c - 1) * s + d, this.timeScaleArray.push({
          position: d, value: c, unit: 'year', year: c, month: 1,
        });
      }
    },
  }, {
    key: 'generateMonthScale',
    value(t) {
      const e = t.firstVal; const i = t.currentMonthDate; const a = t.currentMonth; const s = t.currentYear; const r = t.daysWidthOnXAxis; const n = t.numberOfMonths; let o = a; let l = 0; const h = new DateTime(this.ctx); let c = 'month'; let d = 0; if (e.minDate > 1) {
        l = (h.determineDaysOfMonths(a + 1, e.minYear) - i + 1) * r, o = Utils.monthMod(a + 1); let g = s + d; let u = Utils.monthMod(o); let p = o; o === 0 && (c = 'year', p = g, u = 1, g += d += 1), this.timeScaleArray.push({
          position: l, value: p, unit: c, year: g, month: u,
        });
      } else {
        this.timeScaleArray.push({
          position: l, value: o, unit: c, year: s, month: Utils.monthMod(a),
        });
      } for (let f = o + 1, x = l, b = 0, m = 1; b < n; b++, m++) {
        (f = Utils.monthMod(f)) === 0 ? (c = 'year', d += 1) : c = 'month'; const v = s + Math.floor(f / 12) + d; x = h.determineDaysOfMonths(f, v) * r + x; const y = f === 0 ? v : f; this.timeScaleArray.push({
          position: x, value: y, unit: c, year: v, month: f === 0 ? 1 : f,
        }), f++;
      }
    },
  }, {
    key: 'generateDayScale',
    value(t) {
      const e = t.firstVal; const i = t.currentMonth; const a = t.currentYear; const s = t.hoursWidthOnXAxis; let r = t.numberOfDays; const n = new DateTime(this.ctx); let o = 'day'; const l = e.minDate + 1; let h = l; const c = function (t, e, i) { return t > n.determineDaysOfMonths(e + 1, i) ? (h = 1, o = 'month', g = e += 1, e) : e; }; let d = (24 - e.minHour) * s; var g = l; let u = c(h, i, a); e.minHour === 0 && e.minDate === 1 && (d = 0, g = Utils.monthMod(e.minMonth), o = 'month', h = e.minDate, r++), this.timeScaleArray.push({
        position: d, value: g, unit: o, year: a, month: Utils.monthMod(u), day: h,
      }); for (let p = d, f = 0; f < r; f++) {
        o = 'day', u = c(h += 1, u, a + Math.floor(u / 12) + 0); const x = a + Math.floor(u / 12) + 0; p = 24 * s + p; const b = h === 1 ? Utils.monthMod(u) : h; this.timeScaleArray.push({
          position: p, value: b, unit: o, year: x, month: Utils.monthMod(u), day: b,
        });
      }
    },
  }, {
    key: 'generateHourScale',
    value(t) {
      const e = t.firstVal; const i = t.currentDate; const a = t.currentMonth; const s = t.currentYear; const r = t.minutesWidthOnXAxis; const n = t.numberOfHours; const o = new DateTime(this.ctx); let l = 'hour'; const h = function (t, e) { return t > o.determineDaysOfMonths(e + 1, s) && (f = 1, e += 1), { month: e, date: f }; }; const c = function (t, e) { return t > o.determineDaysOfMonths(e + 1, s) ? e += 1 : e; }; const d = 60 - e.minMinute; let g = d * r; let u = e.minHour + 1; let p = u + 1; d === 60 && (g = 0, p = (u = e.minHour) + 1); var f = i; let x = c(f, a); this.timeScaleArray.push({
        position: g, value: u, unit: l, day: f, hour: p, year: s, month: Utils.monthMod(x),
      }); for (let b = g, m = 0; m < n; m++) {
        if (l = 'hour', p >= 24)p = 0, l = 'day', x = h(f += 1, x).month, x = c(f, x); const v = s + Math.floor(x / 12) + 0; b = p === 0 && m === 0 ? d * r : 60 * r + b; const y = p === 0 ? f : p; this.timeScaleArray.push({
          position: b, value: y, unit: l, hour: p, day: f, year: v, month: Utils.monthMod(x),
        }), p++;
      }
    },
  }, {
    key: 'generateMinuteScale',
    value(t) {
      const e = t.firstVal; const i = t.currentMinute; const a = t.currentHour; const s = t.currentDate; const r = t.currentMonth; const n = t.currentYear; const o = t.minutesWidthOnXAxis; const l = t.numberOfMinutes; const h = o - (i - e.minMinute); const c = e.minMinute + 1; let d = c + 1; const g = s; const u = r; const p = n; let f = a; this.timeScaleArray.push({
        position: h, value: c, unit: 'minute', day: g, hour: f, minute: d, year: p, month: Utils.monthMod(u),
      }); for (let x = h, b = 0; b < l; b++) {
        d >= 60 && (d = 0, (f += 1) === 24 && (f = 0)), x = o + x, this.timeScaleArray.push({
          position: x, value: d, unit: 'minute', hour: f, minute: d, day: g, year: n + Math.floor(u / 12) + 0, month: Utils.monthMod(u),
        }), d++;
      }
    },
  }, { key: 'createRawDateString', value(t, e) { let i = t.year; return i += `-${(`0${t.month.toString()}`).slice(-2)}`, t.unit === 'day' ? i += t.unit === 'day' ? `-${(`0${e}`).slice(-2)}` : '-01' : i += `-${(`0${t.day ? t.day : '1'}`).slice(-2)}`, t.unit === 'hour' ? i += t.unit === 'hour' ? `T${(`0${e}`).slice(-2)}` : 'T00' : i += `T${(`0${t.hour ? t.hour : '0'}`).slice(-2)}`, i += t.unit === 'minute' ? `:${(`0${e}`).slice(-2)}:00` : ':00:00', this.utc && (i += '.000Z'), i; } }, {
    key: 'formatDates',
    value(t) {
      const e = this; const i = this.w; return t.map(((t) => {
        let a = t.value.toString(); const s = new DateTime(e.ctx); const r = e.createRawDateString(t, a); const n = s.getDate(r); if (void 0 === i.config.xaxis.labels.format) { let o = 'dd MMM'; const l = i.config.xaxis.labels.datetimeFormatter; t.unit === 'year' && (o = l.year), t.unit === 'month' && (o = l.month), t.unit === 'day' && (o = l.day), t.unit === 'hour' && (o = l.hour), t.unit === 'minute' && (o = l.minute), a = s.formatDate(n, o); } else a = s.formatDate(n, i.config.xaxis.labels.format); return {
          dateString: r, position: t.position, value: a, unit: t.unit, year: t.year, month: t.month,
        };
      }));
    },
  }, { key: 'removeOverlappingTS', value(t) { const e = this; const i = new Graphics(this.ctx); let a = 0; let s = t.map(((s, r) => { if (r > 0 && e.w.config.xaxis.labels.hideOverlappingLabels) { const n = i.getTextRects(t[a].value).width; const o = t[a].position; return s.position > o + n + 10 ? (a = r, s) : null; } return s; })); return s = s.filter(((t) => t !== null)); } }]), t;
}()); const Core = (function () { function t(e, i) { _classCallCheck(this, t), this.ctx = i, this.w = i.w, this.el = e; } return _createClass(t, [{ key: 'setupElements', value() { const t = this.w.globals; const e = this.w.config; const i = e.chart.type; t.axisCharts = ['line', 'area', 'bar', 'rangeBar', 'candlestick', 'scatter', 'bubble', 'radar', 'heatmap'].indexOf(i) > -1, t.xyCharts = ['line', 'area', 'bar', 'rangeBar', 'candlestick', 'scatter', 'bubble'].indexOf(i) > -1, t.isBarHorizontal = (e.chart.type === 'bar' || e.chart.type === 'rangeBar') && e.plotOptions.bar.horizontal, t.chartClass = `.apexcharts${t.cuid}`, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement('div'), Graphics.setAttrs(t.dom.elWrap, { id: t.chartClass.substring(1), class: `apexcharts-canvas ${t.chartClass.substring(1)}` }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({ class: 'apexcharts-svg', 'xmlns:data': 'ApexChartsNS', transform: 'translate('.concat(e.chart.offsetX, ', ').concat(e.chart.offsetY, ')') }), t.dom.Paper.node.style.background = e.chart.background, this.setSVGDimensions(), t.dom.elGraphical = t.dom.Paper.group().attr({ class: 'apexcharts-inner apexcharts-graphical' }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.elLegendWrap = document.createElement('div'), t.dom.elLegendWrap.classList.add('apexcharts-legend'), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs); } }, { key: 'plotChartType', value(t, e) { const i = this.w; const a = i.config; const s = i.globals; const r = { series: [], i: [] }; const n = { series: [], i: [] }; const o = { series: [], i: [] }; const l = { series: [], i: [] }; const h = { series: [], i: [] }; const c = { series: [], i: [] }; s.series.map(((e, d) => { void 0 !== t[d].type ? (t[d].type === 'column' || t[d].type === 'bar' ? (s.series.length > 1 && a.plotOptions.bar.horizontal && console.warn('Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`'), h.series.push(e), h.i.push(d), i.globals.columnSeries = h.series) : t[d].type === 'area' ? (n.series.push(e), n.i.push(d)) : t[d].type === 'line' ? (r.series.push(e), r.i.push(d)) : t[d].type === 'scatter' ? (o.series.push(e), o.i.push(d)) : t[d].type === 'bubble' ? (l.series.push(e), l.i.push(d)) : t[d].type === 'candlestick' ? (c.series.push(e), c.i.push(d)) : console.warn('You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble'), s.comboCharts = !0) : (r.series.push(e), r.i.push(d)); })); const d = new Line(this.ctx, e); const g = new CandleStick(this.ctx, e); const u = new Pie(this.ctx); const p = new Radial(this.ctx); const f = new RangeBar(this.ctx, e); const x = new Radar(this.ctx); let b = []; if (s.comboCharts) { if (n.series.length > 0 && b.push(d.draw(n.series, 'area', n.i)), h.series.length > 0) if (i.config.chart.stacked) { const m = new BarStacked(this.ctx, e); b.push(m.draw(h.series, h.i)); } else { const v = new Bar(this.ctx, e); b.push(v.draw(h.series, h.i)); } if (r.series.length > 0 && b.push(d.draw(r.series, 'line', r.i)), c.series.length > 0 && b.push(g.draw(c.series, c.i)), o.series.length > 0) { const y = new Line(this.ctx, e, !0); b.push(y.draw(o.series, 'scatter', o.i)); } if (l.series.length > 0) { const w = new Line(this.ctx, e, !0); b.push(w.draw(l.series, 'bubble', l.i)); } } else switch (a.chart.type) { case 'line': b = d.draw(s.series, 'line'); break; case 'area': b = d.draw(s.series, 'area'); break; case 'bar': if (a.chart.stacked)b = new BarStacked(this.ctx, e).draw(s.series); else b = new Bar(this.ctx, e).draw(s.series); break; case 'candlestick': b = new CandleStick(this.ctx, e).draw(s.series); break; case 'rangeBar': b = f.draw(s.series); break; case 'heatmap': b = new HeatMap(this.ctx, e).draw(s.series); break; case 'pie': case 'donut': b = u.draw(s.series); break; case 'radialBar': b = p.draw(s.series); break; case 'radar': b = x.draw(s.series); break; default: b = d.draw(s.series); } return b; } }, { key: 'setSVGDimensions', value() { const t = this.w.globals; const e = this.w.config; t.svgWidth = e.chart.width, t.svgHeight = e.chart.height; let i = Utils.getDimensions(this.el); const a = e.chart.width.toString().split(/[0-9]+/g).pop(); if (a === '%' ? Utils.isNumber(i[0]) && (i[0].width === 0 && (i = Utils.getDimensions(this.el.parentNode)), t.svgWidth = i[0] * parseInt(e.chart.width, 10) / 100) : a !== 'px' && a !== '' || (t.svgWidth = parseInt(e.chart.width, 10)), t.svgHeight !== 'auto' && t.svgHeight !== '') if (e.chart.height.toString().split(/[0-9]+/g).pop() === '%') { const s = Utils.getDimensions(this.el.parentNode); t.svgHeight = s[1] * parseInt(e.chart.height, 10) / 100; } else t.svgHeight = parseInt(e.chart.height, 10); else t.axisCharts ? t.svgHeight = t.svgWidth / 1.61 : t.svgHeight = t.svgWidth / 1.2; t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), Graphics.setAttrs(t.dom.Paper.node, { width: t.svgWidth, height: t.svgHeight }); const r = e.chart.sparkline.enabled ? 0 : t.axisCharts ? e.chart.parentHeightOffset : 0; t.dom.Paper.node.parentNode.parentNode.style.minHeight = `${t.svgHeight + r}px`, t.dom.elWrap.style.width = `${t.svgWidth}px`, t.dom.elWrap.style.height = `${t.svgHeight}px`; } }, { key: 'shiftGraphPosition', value() { const t = this.w.globals; const e = t.translateY; const i = { transform: `translate(${t.translateX}, ${e})` }; Graphics.setAttrs(t.dom.elGraphical.node, i), t.x2SpaceAvailable = t.svgWidth - t.dom.elGraphical.x() - t.gridWidth; } }, { key: 'resizeNonAxisCharts', value() { const t = this.w; const e = t.globals; let i = 0; t.config.legend.position !== 'top' && t.config.legend.position !== 'bottom' || (i = new Legend(this.ctx).legendHelpers.getLegendBBox().clwh + 10); const a = t.globals.dom.baseEl.querySelector('.apexcharts-radialbar .apexcharts-tracks'); const s = t.globals.dom.baseEl.querySelector('.apexcharts-radialbar .apexcharts-datalabels-group'); let r = 2 * t.globals.radialSize; if (a) { const n = Utils.getBoundingClientRect(a); if (r = n.bottom, s) { const o = Utils.getBoundingClientRect(s); const l = Math.max(n.bottom, o.bottom) - n.top + o.height; r = Math.max(2 * t.globals.radialSize, l); } } const h = r + e.translateY + i + 20; e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute('height', h), e.dom.elWrap.style.height = `${h}px`, Graphics.setAttrs(e.dom.Paper.node, { height: h }), e.dom.Paper.node.parentNode.parentNode.style.minHeight = `${h}px`; } }, { key: 'coreCalculations', value() { new Range$1(this.ctx).init(); } }, { key: 'resetGlobals', value() { const t = this; const e = function () { return t.w.config.series.map(((t) => [])); }; const i = new Globals(); const a = this.w.globals; i.initGlobalVars(a), a.seriesXvalues = e(), a.seriesYvalues = e(); } }, { key: 'isMultipleY', value() { if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0; } }, { key: 'xySettings', value() { let t = null; const e = this.w; if (e.globals.axisCharts) { if (e.config.xaxis.crosshairs.position === 'back') new Crosshairs(this.ctx).drawXCrosshairs(); if (e.config.yaxis[0].crosshairs.position === 'back') new Crosshairs(this.ctx).drawYCrosshairs(); if (t = new CoreUtils(this.ctx).getCalculatedRatios(), e.config.xaxis.type === 'datetime' && void 0 === e.config.xaxis.labels.formatter) { const i = new TimeScale(this.ctx); let a = []; isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? a = i.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (a = i.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), i.recalcDimensionsBasedOnFormat(a); } } return t; } }, { key: 'setupBrushHandler', value() { const t = this; const e = this.w; if (e.config.chart.brush.enabled && typeof e.config.chart.events.selection !== 'function') { const i = e.config.chart.brush.targets || [e.config.chart.brush.target]; i.forEach(((e) => { const i = ApexCharts.getChartByID(e); i.w.globals.brushSource = t.ctx; const a = function () { t.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: i.w.globals.minX, max: i.w.globals.maxX } } } }, !1, !1); }; typeof i.w.config.chart.events.zoomed !== 'function' && (i.w.config.chart.events.zoomed = function () { a(); }), typeof i.w.config.chart.events.scrolled !== 'function' && (i.w.config.chart.events.scrolled = function () { a(); }); })), e.config.chart.events.selection = function (t, a) { i.forEach(((t) => { const i = ApexCharts.getChartByID(t); let s = Utils.clone(e.config.yaxis); e.config.chart.brush.autoScaleYaxis && (s = new Range(i).autoScaleY(i, s, a)); i.ctx.updateHelpers._updateOptions({ xaxis: { min: a.xaxis.min, max: a.xaxis.max }, yaxis: _objectSpread2({}, i.w.config.yaxis[0], { min: s[0].min, max: s[0].max }) }, !1, !1, !1, !1); })); }; } } }]), t; }()); const UpdateHelpers = (function () {
  function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: '_updateOptions', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; const s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let r = [this.ctx]; a && (r = this.ctx.getSyncedCharts()), this.ctx.w.globals.isExecCalled && (r = [this.ctx], this.ctx.w.globals.isExecCalled = !1), r.forEach(((a) => { const r = a.w; return r.globals.shouldAnimate = i, e || (r.globals.resized = !0, r.globals.dataChanged = !0, i && a.series.getPreviousPaths()), t && _typeof(t) === 'object' && (a.config = new Config(t), t = CoreUtils.extendArrayProps(a.config, t), r.config = Utils.extend(r.config, t), s && (r.globals.lastXAxis = [], r.globals.lastYAxis = [], r.globals.initialConfig = Utils.extend({}, r.config), r.globals.initialSeries = JSON.parse(JSON.stringify(r.config.series)))), a.update(t); })); } }, { key: '_updateSeries', value(t, e) { let i; const a = this; const s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const r = this.w; return r.globals.shouldAnimate = e, r.globals.dataChanged = !0, r.globals.allSeriesCollapsed && (r.globals.allSeriesCollapsed = !1), e && this.ctx.series.getPreviousPaths(), r.globals.axisCharts ? ((i = t.map(((t, e) => a._extendSeries(t, e)))).length === 0 && (i = [{ data: [] }]), r.config.series = i) : r.config.series = t.slice(), s && (r.globals.initialConfig.series = JSON.parse(JSON.stringify(r.config.series)), r.globals.initialSeries = JSON.parse(JSON.stringify(r.config.series))), this.ctx.update(); } }, { key: '_extendSeries', value(t, e) { const i = this.w; return _objectSpread2({}, i.config.series[e], { name: t.name ? t.name : i.config.series[e] && i.config.series[e].name, type: t.type ? t.type : i.config.series[e] && i.config.series[e].type, data: t.data ? t.data : i.config.series[e] && i.config.series[e].data }); } }, {
    key: 'toggleDataPointSelection',
    value(t, e) {
      const i = this.w; let a = null; const s = ".apexcharts-series[data\\:realIndex='".concat(t, "']"); i.globals.axisCharts ? a = i.globals.dom.Paper.select(''.concat(s, " path[j='").concat(e, "'], ").concat(s, " circle[j='").concat(e, "'], ")
        .concat(s, " rect[j='")
        .concat(e, "']")).members[0] : void 0 === e && (a = i.globals.dom.Paper.select(''.concat(s, " path[j='").concat(t, "']")).members[0], (i.config.chart.type === 'pie' || i.config.chart.type === 'donut') && new Pie(this.ctx).pieClicked(t)); a ? new Graphics(this.ctx).pathMouseDown(a, null) : console.warn('toggleDataPointSelection: Element not found'); return a.node ? a.node : null;
    },
  }, { key: 'forceXAxisUpdate', value(t) { const e = this.w; if (['min', 'max'].forEach(((i) => { void 0 !== t.xaxis[i] && (e.config.xaxis[i] = t.xaxis[i], e.globals.lastXAxis[i] = t.xaxis[i]); })), t.xaxis.categories && t.xaxis.categories.length && (e.config.xaxis.categories = t.xaxis.categories), e.config.xaxis.convertedCatToNumeric) { const i = new Defaults(t); t = i.convertCatToNumericXaxis(t, this.ctx); } return t; } }, { key: 'forceYAxisUpdate', value(t) { const e = this.w; return e.config.chart.stacked && e.config.chart.stackType === '100%' && (Array.isArray(t.yaxis) ? t.yaxis.forEach(((e, i) => { t.yaxis[i].min = 0, t.yaxis[i].max = 100; })) : (t.yaxis.min = 0, t.yaxis.max = 100)), t; } }, { key: 'revertDefaultAxisMinMax', value() { const t = this; const e = this.w; e.config.xaxis.min = e.globals.lastXAxis.min, e.config.xaxis.max = e.globals.lastXAxis.max, e.config.yaxis.map(((i, a) => { e.globals.zoomed ? void 0 !== e.globals.lastYAxis[a] && (i.min = e.globals.lastYAxis[a].min, i.max = e.globals.lastYAxis[a].max) : void 0 !== t.ctx.opts.yaxis[a] && (i.min = t.ctx.opts.yaxis[a].min, i.max = t.ctx.opts.yaxis[a].max); })); } }]), t;
}()); function styleInject(t, e) { void 0 === e && (e = {}); const i = e.insertAt; if (t && typeof document !== 'undefined') { const a = document.head || document.getElementsByTagName('head')[0]; const s = document.createElement('style'); s.type = 'text/css', i === 'top' && a.firstChild ? a.insertBefore(s, a.firstChild) : a.appendChild(s), s.styleSheet ? s.styleSheet.cssText = t : s.appendChild(document.createTextNode(t)); } }!(function (t, e) { typeof define === 'function' && define.amd ? define((() => e(t, t.document))) : (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = t.document ? e(t, t.document) : function (t) { return e(t, t.document); } : t.SVG = e(t, t.document); }(typeof window !== 'undefined' ? window : void 0, (function (t, e) {
  var i = (void 0 !== this ? this : t).SVG = function (t) { if (i.supported) return t = new i.Doc(t), i.parser.draw || i.prepare(), t; }; if (i.ns = 'http://www.w3.org/2000/svg', i.xmlns = 'http://www.w3.org/2000/xmlns/', i.xlink = 'http://www.w3.org/1999/xlink', i.svgjs = 'http://svgjs.com/svgjs', i.supported = !0, !i.supported) return !1; i.did = 1e3, i.eid = function (t) { return `Svgjs${c(t)}${i.did++}`; }, i.create = function (t) { const i = e.createElementNS(this.ns, t); return i.setAttribute('id', this.eid(t)), i; }, i.extend = function () { let t; let e; let a; let s; for (e = (t = [].slice.call(arguments)).pop(), s = t.length - 1; s >= 0; s--) if (t[s]) for (a in e)t[s].prototype[a] = e[a]; i.Set && i.Set.inherit && i.Set.inherit(); }, i.invent = function (t) { const e = typeof t.create === 'function' ? t.create : function () { this.constructor.call(this, i.create(t.create)); }; return t.inherit && (e.prototype = new t.inherit()), t.extend && i.extend(e, t.extend), t.construct && i.extend(t.parent || i.Container, t.construct), e; }, i.adopt = function (e) { return e ? e.instance ? e.instance : ((a = e.nodeName == 'svg' ? e.parentNode instanceof t.SVGElement ? new i.Nested() : new i.Doc() : e.nodeName == 'linearGradient' ? new i.Gradient('linear') : e.nodeName == 'radialGradient' ? new i.Gradient('radial') : i[c(e.nodeName)] ? new (i[c(e.nodeName)])() : new i.Element(e)).type = e.nodeName, a.node = e, e.instance = a, a instanceof i.Doc && a.namespace().defs(), a.setData(JSON.parse(e.getAttribute('svgjs:data')) || {}), a) : null; let a; }, i.prepare = function () {
    const t = e.getElementsByTagName('body')[0]; const a = (t ? new i.Doc(t) : i.adopt(e.documentElement).nested()).size(2, 0); i.parser = {
      body: t || e.documentElement, draw: a.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node, poly: a.polyline().node, path: a.path().node, native: i.create('svg'),
    };
  }, i.parser = { native: i.create('svg') }, e.addEventListener('DOMContentLoaded', (() => { i.parser.draw || i.prepare(); }), !1), i.regex = {
    numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g,
  }, i.utils = { map(t, e) { let i; const a = t.length; const s = []; for (i = 0; i < a; i++)s.push(e(t[i])); return s; }, filter(t, e) { let i; const a = t.length; const s = []; for (i = 0; i < a; i++)e(t[i]) && s.push(t[i]); return s; }, filterSVGElements(e) { return this.filter(e, ((e) => e instanceof t.SVGElement)); } }, i.defaults = {
    attrs: {
      'fill-opacity': 1, 'stroke-opacity': 1, 'stroke-width': 0, 'stroke-linejoin': 'miter', 'stroke-linecap': 'butt', fill: '#000000', stroke: '#000000', opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, 'stop-opacity': 1, 'stop-color': '#000000', 'font-size': 16, 'font-family': 'Helvetica, Arial, sans-serif', 'text-anchor': 'start',
    },
  }, i.Color = function (t) { let e; let a; (this.r = 0, this.g = 0, this.b = 0, t) && (typeof t === 'string' ? i.regex.isRgb.test(t) ? (e = i.regex.rgb.exec(t.replace(i.regex.whitespace, '')), this.r = parseInt(e[1]), this.g = parseInt(e[2]), this.b = parseInt(e[3])) : i.regex.isHex.test(t) && (e = i.regex.hex.exec((a = t).length == 4 ? ['#', a.substring(1, 2), a.substring(1, 2), a.substring(2, 3), a.substring(2, 3), a.substring(3, 4), a.substring(3, 4)].join('') : a), this.r = parseInt(e[1], 16), this.g = parseInt(e[2], 16), this.b = parseInt(e[3], 16)) : _typeof(t) === 'object' && (this.r = t.r, this.g = t.g, this.b = t.b)); }, i.extend(i.Color, {
    toString() { return this.toHex(); }, toHex() { return `#${d(this.r)}${d(this.g)}${d(this.b)}`; }, toRgb() { return `rgb(${[this.r, this.g, this.b].join()})`; }, brightness() { return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11; }, morph(t) { return this.destination = new i.Color(t), this; }, at(t) { return this.destination ? (t = t < 0 ? 0 : t > 1 ? 1 : t, new i.Color({ r: ~~(this.r + (this.destination.r - this.r) * t), g: ~~(this.g + (this.destination.g - this.g) * t), b: ~~(this.b + (this.destination.b - this.b) * t) })) : this; },
  }), i.Color.test = function (t) { return t += '', i.regex.isHex.test(t) || i.regex.isRgb.test(t); }, i.Color.isRgb = function (t) { return t && typeof t.r === 'number' && typeof t.g === 'number' && typeof t.b === 'number'; }, i.Color.isColor = function (t) { return i.Color.isRgb(t) || i.Color.test(t); }, i.Array = function (t, e) { (t = (t || []).valueOf()).length == 0 && e && (t = e.valueOf()), this.value = this.parse(t); }, i.extend(i.Array, { toString() { return this.value.join(' '); }, valueOf() { return this.value; }, parse(t) { return t = t.valueOf(), Array.isArray(t) ? t : this.split(t); } }), i.PointArray = function (t, e) { i.Array.call(this, t, e || [[0, 0]]); }, i.PointArray.prototype = new i.Array(), i.PointArray.prototype.constructor = i.PointArray; for (var a = {
      M(t, e, i) { return e.x = i.x = t[0], e.y = i.y = t[1], ['M', e.x, e.y]; }, L(t, e) { return e.x = t[0], e.y = t[1], ['L', t[0], t[1]]; }, H(t, e) { return e.x = t[0], ['H', t[0]]; }, V(t, e) { return e.y = t[0], ['V', t[0]]; }, C(t, e) { return e.x = t[4], e.y = t[5], ['C', t[0], t[1], t[2], t[3], t[4], t[5]]; }, Q(t, e) { return e.x = t[2], e.y = t[3], ['Q', t[0], t[1], t[2], t[3]]; }, Z(t, e, i) { return e.x = i.x, e.y = i.y, ['Z']; },
    }, s = 'mlhvqtcsaz'.split(''), r = 0, n = s.length; r < n; ++r)a[s[r]] = (function (t) { return function (e, i, s) { if (t == 'H')e[0] += i.x; else if (t == 'V')e[0] += i.y; else if (t == 'A')e[5] += i.x, e[6] += i.y; else for (let r = 0, n = e.length; r < n; ++r)e[r] = e[r] + (r % 2 ? i.y : i.x); return a[t](e, i, s); }; }(s[r].toUpperCase())); i.PathArray = function (t, e) { i.Array.call(this, t, e || [['M', 0, 0]]); }, i.PathArray.prototype = new i.Array(), i.PathArray.prototype.constructor = i.PathArray, i.extend(i.PathArray, {
    toString() { return (function (t) { for (var e = 0, i = t.length, a = ''; e < i; e++)a += t[e][0], t[e][1] != null && (a += t[e][1], t[e][2] != null && (a += ' ', a += t[e][2], t[e][3] != null && (a += ' ', a += t[e][3], a += ' ', a += t[e][4], t[e][5] != null && (a += ' ', a += t[e][5], a += ' ', a += t[e][6], t[e][7] != null && (a += ' ', a += t[e][7]))))); return `${a} `; }(this.value)); },
    move(t, e) { const i = this.bbox(); return i.x, i.y, this; },
    at(t) { if (!this.destination) return this; let e; let a; let s; let r; const n = this.value; const o = this.destination.value; const l = []; const h = new i.PathArray(); for (e = 0, a = n.length; e < a; e++) { for (l[e] = [n[e][0]], s = 1, r = n[e].length; s < r; s++)l[e][s] = n[e][s] + (o[e][s] - n[e][s]) * t; l[e][0] === 'A' && (l[e][4] = +(l[e][4] != 0), l[e][5] = +(l[e][5] != 0)); } return h.value = l, h; },
    parse(t) {
      if (t instanceof i.PathArray) return t.valueOf(); let e; const s = {
        M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0,
      }; t = typeof t === 'string' ? t.replace(i.regex.numbersWithDots, l).replace(i.regex.pathLetters, ' $& ').replace(i.regex.hyphen, '$1 -').trim()
        .split(i.regex.delimiter) : t.reduce(((t, e) => [].concat.call(t, e)), []); const r = []; const n = new i.Point(); const o = new i.Point(); let h = 0; const c = t.length; do { i.regex.isPathLetter.test(t[h]) ? (e = t[h], ++h) : e == 'M' ? e = 'L' : e == 'm' && (e = 'l'), r.push(a[e].call(null, t.slice(h, h += s[e.toUpperCase()]).map(parseFloat), n, o)); } while (c > h);return r;
    },
    bbox() { return i.parser.draw || i.prepare(), i.parser.path.setAttribute('d', this.toString()), i.parser.path.getBBox(); },
  }), i.Number = i.invent({
    create(t, e) { this.value = 0, this.unit = e || '', typeof t === 'number' ? this.value = isNaN(t) ? 0 : isFinite(t) ? t : t < 0 ? -34e37 : 34e37 : typeof t === 'string' ? (e = t.match(i.regex.numberAndUnit)) && (this.value = parseFloat(e[1]), e[5] == '%' ? this.value /= 100 : e[5] == 's' && (this.value *= 1e3), this.unit = e[5]) : t instanceof i.Number && (this.value = t.valueOf(), this.unit = t.unit); },
    extend: {
      toString() { return (this.unit == '%' ? ~~(1e8 * this.value) / 1e6 : this.unit == 's' ? this.value / 1e3 : this.value) + this.unit; }, toJSON() { return this.toString(); }, valueOf() { return this.value; }, plus(t) { return t = new i.Number(t), new i.Number(this + t, this.unit || t.unit); }, minus(t) { return t = new i.Number(t), new i.Number(this - t, this.unit || t.unit); }, times(t) { return t = new i.Number(t), new i.Number(this * t, this.unit || t.unit); }, divide(t) { return t = new i.Number(t), new i.Number(this / t, this.unit || t.unit); }, to(t) { const e = new i.Number(this); return typeof t === 'string' && (e.unit = t), e; }, morph(t) { return this.destination = new i.Number(t), t.relative && (this.destination.value += this.value), this; }, at(t) { return this.destination ? new i.Number(this.destination).minus(this).times(t).plus(this) : this; },
    },
  }), i.Element = i.invent({
    create(t) { this._stroke = i.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t) && (this.type = t.nodeName, this.node.instance = this, this._stroke = t.getAttribute('stroke') || this._stroke); },
    extend: {
      x(t) { return this.attr('x', t); }, y(t) { return this.attr('y', t); }, cx(t) { return t == null ? this.x() + this.width() / 2 : this.x(t - this.width() / 2); }, cy(t) { return t == null ? this.y() + this.height() / 2 : this.y(t - this.height() / 2); }, move(t, e) { return this.x(t).y(e); }, center(t, e) { return this.cx(t).cy(e); }, width(t) { return this.attr('width', t); }, height(t) { return this.attr('height', t); }, size(t, e) { const a = g(this, t, e); return this.width(new i.Number(a.width)).height(new i.Number(a.height)); }, clone(t) { this.writeDataToDom(); const e = f(this.node.cloneNode(!0)); return t ? t.add(e) : this.after(e), e; }, remove() { return this.parent() && this.parent().removeElement(this), this; }, replace(t) { return this.after(t).remove(), t; }, addTo(t) { return t.put(this); }, putIn(t) { return t.add(this); }, id(t) { return this.attr('id', t); }, show() { return this.style('display', ''); }, hide() { return this.style('display', 'none'); }, visible() { return this.style('display') != 'none'; }, toString() { return this.attr('id'); }, classes() { const t = this.attr('class'); return t == null ? [] : t.trim().split(i.regex.delimiter); }, hasClass(t) { return this.classes().indexOf(t) != -1; }, addClass(t) { if (!this.hasClass(t)) { const e = this.classes(); e.push(t), this.attr('class', e.join(' ')); } return this; }, removeClass(t) { return this.hasClass(t) && this.attr('class', this.classes().filter(((e) => e != t)).join(' ')), this; }, toggleClass(t) { return this.hasClass(t) ? this.removeClass(t) : this.addClass(t); }, reference(t) { return i.get(this.attr(t)); }, parent(e) { let a = this; if (!a.node.parentNode) return null; if (a = i.adopt(a.node.parentNode), !e) return a; for (;a && a.node instanceof t.SVGElement;) { if (typeof e === 'string' ? a.matches(e) : a instanceof e) return a; if (!a.node.parentNode || a.node.parentNode.nodeName == '#document') return null; a = i.adopt(a.node.parentNode); } }, doc() { return this instanceof i.Doc ? this : this.parent(i.Doc); }, parents(t) { const e = []; let i = this; do { if (!(i = i.parent(t)) || !i.node) break; e.push(i); } while (i.parent);return e; }, matches(t) { return (function (t, e) { return (t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector).call(t, e); }(this.node, t)); }, native() { return this.node; }, svg(t) { const a = e.createElement('svg'); if (!(t && this instanceof i.Parent)) return a.appendChild(t = e.createElement('svg')), this.writeDataToDom(), t.appendChild(this.node.cloneNode(!0)), a.innerHTML.replace(/^<svg>/, '').replace(/<\/svg>$/, ''); a.innerHTML = `<svg>${t.replace(/\n/, '').replace(/<([\w:-]+)([^<]+?)\/>/g, '<$1$2></$1>')}</svg>`; for (let s = 0, r = a.firstChild.childNodes.length; s < r; s++) this.node.appendChild(a.firstChild.firstChild); return this; }, writeDataToDom() { (this.each || this.lines) && (this.each ? this : this.lines()).each((function () { this.writeDataToDom(); })); return this.node.removeAttribute('svgjs:data'), Object.keys(this.dom).length && this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)), this; }, setData(t) { return this.dom = t, this; }, is(t) { return (function (t, e) { return t instanceof e; }(this, t)); },
    },
  }), i.easing = {
    '-': function (t) { return t; }, '<>': function (t) { return -Math.cos(t * Math.PI) / 2 + 0.5; }, '>': function (t) { return Math.sin(t * Math.PI / 2); }, '<': function (t) { return 1 - Math.cos(t * Math.PI / 2); },
  }, i.morph = function (t) { return function (e, a) { return new i.MorphObj(e, a).at(t); }; }, i.Situation = i.invent({ create(t) { this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new i.Number(t.duration).valueOf(), this.delay = new i.Number(t.delay).valueOf(), this.start = +new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {}; } }), i.FX = i.invent({
    create(t) { this._target = t, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1; },
    extend: {
      animate(t, e, a) { _typeof(t) === 'object' && (e = t.ease, a = t.delay, t = t.duration); const s = new i.Situation({ duration: t || 1e3, delay: a || 0, ease: i.easing[e || '-'] || e }); return this.queue(s), this; },
      target(t) { return t && t instanceof i.Element ? (this._target = t, this) : this._target; },
      timeToAbsPos(t) { return (t - this.situation.start) / (this.situation.duration / this._speed); },
      absPosToTime(t) { return this.situation.duration / this._speed * t + this.situation.start; },
      startAnimFrame() { this.stopAnimFrame(), this.animationFrame = t.requestAnimationFrame(() => { this.step(); }); },
      stopAnimFrame() { t.cancelAnimationFrame(this.animationFrame); },
      start() { return !this.active && this.situation && (this.active = !0, this.startCurrent()), this; },
      startCurrent() { return this.situation.start = +new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step(); },
      queue(t) { return (typeof t === 'function' || t instanceof i.Situation) && this.situations.push(t), this.situation || (this.situation = this.situations.shift()), this; },
      dequeue() { return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof i.Situation ? this.start() : this.situation.call(this)), this; },
      initAnimations() { let t; let e; let a; const s = this.situation; if (s.init) return this; for (t in s.animations) for (a = this.target()[t](), Array.isArray(a) || (a = [a]), Array.isArray(s.animations[t]) || (s.animations[t] = [s.animations[t]]), e = a.length; e--;)s.animations[t][e] instanceof i.Number && (a[e] = new i.Number(a[e])), s.animations[t][e] = a[e].morph(s.animations[t][e]); for (t in s.attrs)s.attrs[t] = new i.MorphObj(this.target().attr(t), s.attrs[t]); for (t in s.styles)s.styles[t] = new i.MorphObj(this.target().style(t), s.styles[t]); return s.initialTransformation = this.target().matrixify(), s.init = !0, this; },
      clearQueue() { return this.situations = [], this; },
      clearCurrent() { return this.situation = null, this; },
      stop(t, e) { const i = this.active; return this.active = !1, e && this.clearQueue(), t && this.situation && (!i && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent(); },
      after(t) { const e = this.last(); return this.target().on('finished.fx', (function i(a) { a.detail.situation == e && (t.call(this, e), this.off('finished.fx', i)); })), this._callStart(); },
      during(t) { const e = this.last(); const a = function (a) { a.detail.situation == e && t.call(this, a.detail.pos, i.morph(a.detail.pos), a.detail.eased, e); }; return this.target().off('during.fx', a).on('during.fx', a), this.after((function () { this.off('during.fx', a); })), this._callStart(); },
      afterAll(t) { const e = function e(i) { t.call(this), this.off('allfinished.fx', e); }; return this.target().off('allfinished.fx', e).on('allfinished.fx', e), this._callStart(); },
      last() { return this.situations.length ? this.situations[this.situations.length - 1] : this.situation; },
      add(t, e, i) { return this.last()[i || 'animations'][t] = e, this._callStart(); },
      step(t) {
        let e; let i; let a; (t || (this.absPos = this.timeToAbsPos(+new Date())), !1 !== this.situation.loops) ? (e = Math.max(this.absPos, 0), i = Math.floor(e), !0 === this.situation.loops || i < this.situation.loops ? (this.pos = e - i, a = this.situation.loop, this.situation.loop = i) : (this.absPos = this.situation.loops, this.pos = 1, a = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos); this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos); const s = this.situation.ease(this.pos); for (const r in this.situation.once)r > this.lastPos && r <= s && (this.situation.once[r].call(this.target(), this.pos, s), delete this.situation.once[r]); return this.active && this.target().fire('during', {
          pos: this.pos, eased: s, fx: this, situation: this.situation,
        }), this.situation ? (this.eachAt(), this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0 ? (this.stopAnimFrame(), this.target().fire('finished', { fx: this, situation: this.situation }), this.situations.length || (this.target().fire('allfinished'), this.situations.length || (this.target().off('.fx'), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s, this) : this;
      },
      eachAt() { let t; let e; let a; const s = this; const r = this.target(); const n = this.situation; for (t in n.animations)a = [].concat(n.animations[t]).map(((t) => (typeof t !== 'string' && t.at ? t.at(n.ease(s.pos), s.pos) : t))), r[t].apply(r, a); for (t in n.attrs)a = [t].concat(n.attrs[t]).map(((t) => (typeof t !== 'string' && t.at ? t.at(n.ease(s.pos), s.pos) : t))), r.attr.apply(r, a); for (t in n.styles)a = [t].concat(n.styles[t]).map(((t) => (typeof t !== 'string' && t.at ? t.at(n.ease(s.pos), s.pos) : t))), r.style.apply(r, a); if (n.transforms.length) { for (a = n.initialTransformation, t = 0, e = n.transforms.length; t < e; t++) { const o = n.transforms[t]; o instanceof i.Matrix ? a = o.relative ? a.multiply((new i.Matrix()).morph(o).at(n.ease(this.pos))) : a.morph(o).at(n.ease(this.pos)) : (o.relative || o.undo(a.extract()), a = a.multiply(o.at(n.ease(this.pos)))); }r.matrix(a); } return this; },
      once(t, e, i) { const a = this.last(); return i || (t = a.ease(t)), a.once[t] = e, this; },
      _callStart() { return setTimeout(() => { this.start(); }, 0), this; },
    },
    parent: i.Element,
    construct: {
      animate(t, e, a) { return (this.fx || (this.fx = new i.FX(this))).animate(t, e, a); }, delay(t) { return (this.fx || (this.fx = new i.FX(this))).delay(t); }, stop(t, e) { return this.fx && this.fx.stop(t, e), this; }, finish() { return this.fx && this.fx.finish(), this; },
    },
  }), i.MorphObj = i.invent({ create(t, e) { return i.Color.isColor(e) ? new i.Color(t).morph(e) : i.regex.delimiter.test(t) ? i.regex.pathLetters.test(t) ? new i.PathArray(t).morph(e) : new i.Array(t).morph(e) : i.regex.numberAndUnit.test(e) ? new i.Number(t).morph(e) : (this.value = t, void (this.destination = e)); }, extend: { at(t, e) { return e < 1 ? this.value : this.destination; }, valueOf() { return this.value; } } }), i.extend(i.FX, { attr(t, e, i) { if (_typeof(t) === 'object') for (const a in t) this.attr(a, t[a]); else this.add(t, e, 'attrs'); return this; }, plot(t, e, i, a) { return arguments.length == 4 ? this.plot([t, e, i, a]) : this.add('plot', new (this.target().morphArray)(t)); } }), i.Box = i.invent({ create(t, e, a, s) { if (!(_typeof(t) !== 'object' || t instanceof i.Element)) return i.Box.call(this, t.left != null ? t.left : t.x, t.top != null ? t.top : t.y, t.width, t.height); arguments.length == 4 && (this.x = t, this.y = e, this.width = a, this.height = s), x(this); } }), i.BBox = i.invent({
    create(t) {
      if (i.Box.apply(this, [].slice.call(arguments)), t instanceof i.Element) {
        let a; try { if (!e.documentElement.contains) { for (var s = t.node; s.parentNode;)s = s.parentNode; if (s != e) throw new Error('Element not in the dom'); }a = t.node.getBBox(); } catch (e) {
          if (t instanceof i.Shape) { i.parser.draw || i.prepare(); const r = t.clone(i.parser.draw.instance).show(); a = r.node.getBBox(), r.remove(); } else {
            a = {
              x: t.node.clientLeft, y: t.node.clientTop, width: t.node.clientWidth, height: t.node.clientHeight,
            };
          }
        }i.Box.call(this, a);
      }
    },
    inherit: i.Box,
    parent: i.Element,
    construct: { bbox() { return new i.BBox(this); } },
  }), i.BBox.prototype.constructor = i.BBox, i.Matrix = i.invent({
    create(t) { let e; const a = p([1, 0, 0, 1, 0, 0]); for (t = t instanceof i.Element ? t.matrixify() : typeof t === 'string' ? p(t.split(i.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? p([].slice.call(arguments)) : Array.isArray(t) ? p(t) : _typeof(t) === 'object' ? t : a, e = m.length - 1; e >= 0; --e) this[m[e]] = t[m[e]] != null ? t[m[e]] : a[m[e]]; },
    extend: {
      extract() {
        const t = u(this, 0, 1); const e = (u(this, 1, 0), 180 / Math.PI * Math.atan2(t.y, t.x) - 90); return {
          x: this.e, y: this.f, transformedX: (this.e * Math.cos(e * Math.PI / 180) + this.f * Math.sin(e * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(e * Math.PI / 180) + this.e * Math.sin(-e * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: e, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new i.Matrix(this),
        };
      },
      clone() { return new i.Matrix(this); },
      morph(t) { return this.destination = new i.Matrix(t), this; },
      multiply(t) { return new i.Matrix(this.native().multiply((function (t) { t instanceof i.Matrix || (t = new i.Matrix(t)); return t; }(t)).native())); },
      inverse() { return new i.Matrix(this.native().inverse()); },
      translate(t, e) { return new i.Matrix(this.native().translate(t || 0, e || 0)); },
      native() { for (var t = i.parser.native.createSVGMatrix(), e = m.length - 1; e >= 0; e--)t[m[e]] = this[m[e]]; return t; },
      toString() { return `matrix(${b(this.a)},${b(this.b)},${b(this.c)},${b(this.d)},${b(this.e)},${b(this.f)})`; },
    },
    parent: i.Element,
    construct: { ctm() { return new i.Matrix(this.node.getCTM()); }, screenCTM() { if (this instanceof i.Nested) { const t = this.rect(1, 1); const e = t.node.getScreenCTM(); return t.remove(), new i.Matrix(e); } return new i.Matrix(this.node.getScreenCTM()); } },
  }), i.Point = i.invent({ create(t, e) { let i; i = Array.isArray(t) ? { x: t[0], y: t[1] } : _typeof(t) === 'object' ? { x: t.x, y: t.y } : t != null ? { x: t, y: e != null ? e : t } : { x: 0, y: 0 }, this.x = i.x, this.y = i.y; }, extend: { clone() { return new i.Point(this); }, morph(t, e) { return this.destination = new i.Point(t, e), this; } } }), i.extend(i.Element, { point(t, e) { return new i.Point(t, e).transform(this.screenCTM().inverse()); } }), i.extend(i.Element, { attr(t, e, a) { if (t == null) { for (t = {}, a = (e = this.node.attributes).length - 1; a >= 0; a--)t[e[a].nodeName] = i.regex.isNumber.test(e[a].nodeValue) ? parseFloat(e[a].nodeValue) : e[a].nodeValue; return t; } if (_typeof(t) === 'object') for (e in t) this.attr(e, t[e]); else if (e === null) this.node.removeAttribute(t); else { if (e == null) return (e = this.node.getAttribute(t)) == null ? i.defaults.attrs[t] : i.regex.isNumber.test(e) ? parseFloat(e) : e; t == 'stroke-width' ? this.attr('stroke', parseFloat(e) > 0 ? this._stroke : null) : t == 'stroke' && (this._stroke = e), t != 'fill' && t != 'stroke' || (i.regex.isImage.test(e) && (e = this.doc().defs().image(e, 0, 0)), e instanceof i.Image && (e = this.doc().defs().pattern(0, 0, (function () { this.add(e); })))), typeof e === 'number' ? e = new i.Number(e) : i.Color.isColor(e) ? e = new i.Color(e) : Array.isArray(e) && (e = new i.Array(e)), t == 'leading' ? this.leading && this.leading(e) : typeof a === 'string' ? this.node.setAttributeNS(a, t, e.toString()) : this.node.setAttribute(t, e.toString()), !this.rebuild || t != 'font-size' && t != 'x' || this.rebuild(t, e); } return this; } }), i.extend(i.Element, { transform(t, e) { let a; return _typeof(t) !== 'object' ? (a = new i.Matrix(this).extract(), typeof t === 'string' ? a[t] : a) : (a = new i.Matrix(this), e = !!e || !!t.relative, t.a != null && (a = e ? a.multiply(new i.Matrix(t)) : new i.Matrix(t)), this.attr('transform', a)); } }), i.extend(i.Element, {
    untransform() { return this.attr('transform', null); }, matrixify() { return (this.attr('transform') || '').split(i.regex.transforms).slice(0, -1).map(((t) => { const e = t.trim().split('('); return [e[0], e[1].split(i.regex.delimiter).map(((t) => parseFloat(t)))]; })).reduce(((t, e) => (e[0] == 'matrix' ? t.multiply(p(e[1])) : t[e[0]].apply(t, e[1]))), new i.Matrix()); }, toParent(t) { if (this == t) return this; const e = this.screenCTM(); const i = t.screenCTM().inverse(); return this.addTo(t).untransform().transform(i.multiply(e)), this; }, toDoc() { return this.toParent(this.doc()); },
  }), i.Transformation = i.invent({ create(t, e) { if (arguments.length > 1 && typeof e !== 'boolean') return this.constructor.call(this, [].slice.call(arguments)); if (Array.isArray(t)) for (var i = 0, a = this.arguments.length; i < a; ++i) this[this.arguments[i]] = t[i]; else if (_typeof(t) === 'object') for (i = 0, a = this.arguments.length; i < a; ++i) this[this.arguments[i]] = t[this.arguments[i]]; this.inversed = !1, !0 === e && (this.inversed = !0); } }), i.Translate = i.invent({
    parent: i.Matrix, inherit: i.Transformation, create(t, e) { this.constructor.apply(this, [].slice.call(arguments)); }, extend: { arguments: ['transformedX', 'transformedY'], method: 'translate' },
  }), i.extend(i.Element, { style(t, e) { if (arguments.length == 0) return this.node.style.cssText || ''; if (arguments.length < 2) if (_typeof(t) === 'object') for (e in t) this.style(e, t[e]); else { if (!i.regex.isCss.test(t)) return this.node.style[h(t)]; for (t = t.split(/\s*;\s*/).filter(((t) => !!t)).map(((t) => t.split(/\s*:\s*/))); e = t.pop();) this.style(e[0], e[1]); } else this.node.style[h(t)] = e === null || i.regex.isBlank.test(e) ? '' : e; return this; } }), i.Parent = i.invent({
    create(t) { this.constructor.call(this, t); },
    inherit: i.Element,
    extend: {
      children() { return i.utils.map(i.utils.filterSVGElements(this.node.childNodes), ((t) => i.adopt(t))); }, add(t, e) { return e == null ? this.node.appendChild(t.node) : t.node != this.node.childNodes[e] && this.node.insertBefore(t.node, this.node.childNodes[e]), this; }, put(t, e) { return this.add(t, e), t; }, has(t) { return this.index(t) >= 0; }, index(t) { return [].slice.call(this.node.childNodes).indexOf(t.node); }, get(t) { return i.adopt(this.node.childNodes[t]); }, first() { return this.get(0); }, last() { return this.get(this.node.childNodes.length - 1); }, each(t, e) { let a; let s; const r = this.children(); for (a = 0, s = r.length; a < s; a++)r[a] instanceof i.Element && t.apply(r[a], [a, r]), e && r[a] instanceof i.Container && r[a].each(t, e); return this; }, removeElement(t) { return this.node.removeChild(t.node), this; }, clear() { for (;this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild); return delete this._defs, this; }, defs() { return this.doc().defs(); },
    },
  }), i.extend(i.Parent, { ungroup(t, e) { return e === 0 || this instanceof i.Defs || this.node == i.parser.draw ? this : (t = t || (this instanceof i.Doc ? this : this.parent(i.Parent)), e = e || 1 / 0, this.each((function () { return this instanceof i.Defs ? this : this instanceof i.Parent ? this.ungroup(t, e - 1) : this.toParent(t); })), this.node.firstChild || this.remove(), this); }, flatten(t, e) { return this.ungroup(t, e); } }), i.Container = i.invent({ create(t) { this.constructor.call(this, t); }, inherit: i.Parent }), i.ViewBox = i.invent({ parent: i.Container, construct: {} }), ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].forEach(((t) => { i.Element.prototype[t] = function (e) { return i.on(this.node, t, e), this; }; })), i.listeners = [], i.handlerMap = [], i.listenerId = 0, i.on = function (t, e, a, s, r) { const n = a.bind(s || t.instance || t); const o = (i.handlerMap.indexOf(t) + 1 || i.handlerMap.push(t)) - 1; const l = e.split('.')[0]; const h = e.split('.')[1] || '*'; i.listeners[o] = i.listeners[o] || {}, i.listeners[o][l] = i.listeners[o][l] || {}, i.listeners[o][l][h] = i.listeners[o][l][h] || {}, a._svgjsListenerId || (a._svgjsListenerId = ++i.listenerId), i.listeners[o][l][h][a._svgjsListenerId] = n, t.addEventListener(l, n, r || !1); }, i.off = function (t, e, a) { const s = i.handlerMap.indexOf(t); const r = e && e.split('.')[0]; const n = e && e.split('.')[1]; let o = ''; if (s != -1) if (a) { if (typeof a === 'function' && (a = a._svgjsListenerId), !a) return; i.listeners[s][r] && i.listeners[s][r][n || '*'] && (t.removeEventListener(r, i.listeners[s][r][n || '*'][a], !1), delete i.listeners[s][r][n || '*'][a]); } else if (n && r) { if (i.listeners[s][r] && i.listeners[s][r][n]) { for (a in i.listeners[s][r][n])i.off(t, [r, n].join('.'), a); delete i.listeners[s][r][n]; } } else if (n) for (e in i.listeners[s]) for (o in i.listeners[s][e])n === o && i.off(t, [e, n].join('.')); else if (r) { if (i.listeners[s][r]) { for (o in i.listeners[s][r])i.off(t, [r, o].join('.')); delete i.listeners[s][r]; } } else { for (e in i.listeners[s])i.off(t, e); delete i.listeners[s], delete i.handlerMap[s]; } }, i.extend(i.Element, {
    on(t, e, a, s) { return i.on(this.node, t, e, a, s), this; }, off(t, e) { return i.off(this.node, t, e), this; }, fire(e, a) { return e instanceof t.Event ? this.node.dispatchEvent(e) : this.node.dispatchEvent(e = new i.CustomEvent(e, { detail: a, cancelable: !0 })), this._event = e, this; }, event() { return this._event; },
  }), i.Defs = i.invent({ create: 'defs', inherit: i.Container }), i.G = i.invent({
    create: 'g', inherit: i.Container, extend: { x(t) { return t == null ? this.transform('x') : this.transform({ x: t - this.x() }, !0); } }, construct: { group() { return this.put(new i.G()); } },
  }), i.Doc = i.invent({
    create(t) { t && ((t = typeof t === 'string' ? e.getElementById(t) : t).nodeName == 'svg' ? this.constructor.call(this, t) : (this.constructor.call(this, i.create('svg')), t.appendChild(this.node), this.size('100%', '100%')), this.namespace().defs()); },
    inherit: i.Container,
    extend: {
      namespace() { return this.attr({ xmlns: i.ns, version: '1.1' }).attr('xmlns:xlink', i.xlink, i.xmlns).attr('xmlns:svgjs', i.svgjs, i.xmlns); }, defs() { let t; this._defs || ((t = this.node.getElementsByTagName('defs')[0]) ? this._defs = i.adopt(t) : this._defs = new i.Defs(), this.node.appendChild(this._defs.node)); return this._defs; }, parent() { return this.node.parentNode && this.node.parentNode.nodeName != '#document' ? this.node.parentNode : null; }, remove() { return this.parent() && this.parent().removeChild(this.node), this; }, clear() { for (;this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild); return delete this._defs, i.parser.draw && !i.parser.draw.parentNode && this.node.appendChild(i.parser.draw), this; }, clone(t) { this.writeDataToDom(); const e = this.node; const i = f(e.cloneNode(!0)); return t ? (t.node || t).appendChild(i.node) : e.parentNode.insertBefore(i.node, e.nextSibling), i; },
    },
  }), i.extend(i.Element, {}), i.Gradient = i.invent({
    create(t) { this.constructor.call(this, i.create(`${t}Gradient`)), this.type = t; },
    inherit: i.Container,
    extend: {
      at(t, e, a) { return this.put(new i.Stop()).update(t, e, a); }, update(t) { return this.clear(), typeof t === 'function' && t.call(this, this), this; }, fill() { return `url(#${this.id()})`; }, toString() { return this.fill(); }, attr(t, e, a) { return t == 'transform' && (t = 'gradientTransform'), i.Container.prototype.attr.call(this, t, e, a); },
    },
    construct: { gradient(t, e) { return this.defs().gradient(t, e); } },
  }), i.extend(i.Gradient, i.FX, { from(t, e) { return (this._target || this).type == 'radial' ? this.attr({ fx: new i.Number(t), fy: new i.Number(e) }) : this.attr({ x1: new i.Number(t), y1: new i.Number(e) }); }, to(t, e) { return (this._target || this).type == 'radial' ? this.attr({ cx: new i.Number(t), cy: new i.Number(e) }) : this.attr({ x2: new i.Number(t), y2: new i.Number(e) }); } }), i.extend(i.Defs, { gradient(t, e) { return this.put(new i.Gradient(t)).update(e); } }), i.Stop = i.invent({ create: 'stop', inherit: i.Element, extend: { update(t) { return (typeof t === 'number' || t instanceof i.Number) && (t = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), t.opacity != null && this.attr('stop-opacity', t.opacity), t.color != null && this.attr('stop-color', t.color), t.offset != null && this.attr('offset', new i.Number(t.offset)), this; } } }), i.Pattern = i.invent({
    create: 'pattern',
    inherit: i.Container,
    extend: {
      fill() { return `url(#${this.id()})`; }, update(t) { return this.clear(), typeof t === 'function' && t.call(this, this), this; }, toString() { return this.fill(); }, attr(t, e, a) { return t == 'transform' && (t = 'patternTransform'), i.Container.prototype.attr.call(this, t, e, a); },
    },
    construct: { pattern(t, e, i) { return this.defs().pattern(t, e, i); } },
  }), i.extend(i.Defs, {
    pattern(t, e, a) {
      return this.put(new i.Pattern()).update(a).attr({
        x: 0, y: 0, width: t, height: e, patternUnits: 'userSpaceOnUse',
      });
    },
  }), i.Shape = i.invent({ create(t) { this.constructor.call(this, t); }, inherit: i.Element }), i.Symbol = i.invent({ create: 'symbol', inherit: i.Container, construct: { symbol() { return this.put(new i.Symbol()); } } }), i.Use = i.invent({
    create: 'use', inherit: i.Shape, extend: { element(t, e) { return this.attr('href', `${e || ''}#${t}`, i.xlink); } }, construct: { use(t, e) { return this.put(new i.Use()).element(t, e); } },
  }), i.Rect = i.invent({ create: 'rect', inherit: i.Shape, construct: { rect(t, e) { return this.put(new i.Rect()).size(t, e); } } }), i.Circle = i.invent({ create: 'circle', inherit: i.Shape, construct: { circle(t) { return this.put(new i.Circle()).rx(new i.Number(t).divide(2)).move(0, 0); } } }), i.extend(i.Circle, i.FX, { rx(t) { return this.attr('r', t); }, ry(t) { return this.rx(t); } }), i.Ellipse = i.invent({ create: 'ellipse', inherit: i.Shape, construct: { ellipse(t, e) { return this.put(new i.Ellipse()).size(t, e).move(0, 0); } } }), i.extend(i.Ellipse, i.Rect, i.FX, { rx(t) { return this.attr('rx', t); }, ry(t) { return this.attr('ry', t); } }), i.extend(i.Circle, i.Ellipse, {
    x(t) { return t == null ? this.cx() - this.rx() : this.cx(t + this.rx()); }, y(t) { return t == null ? this.cy() - this.ry() : this.cy(t + this.ry()); }, cx(t) { return t == null ? this.attr('cx') : this.attr('cx', t); }, cy(t) { return t == null ? this.attr('cy') : this.attr('cy', t); }, width(t) { return t == null ? 2 * this.rx() : this.rx(new i.Number(t).divide(2)); }, height(t) { return t == null ? 2 * this.ry() : this.ry(new i.Number(t).divide(2)); }, size(t, e) { const a = g(this, t, e); return this.rx(new i.Number(a.width).divide(2)).ry(new i.Number(a.height).divide(2)); },
  }), i.Line = i.invent({
    create: 'line',
    inherit: i.Shape,
    extend: {
      array() { return new i.PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]); },
      plot(t, e, a, s) {
        return t == null ? this.array() : (t = void 0 !== e ? {
          x1: t, y1: e, x2: a, y2: s,
        } : new i.PointArray(t).toLine(), this.attr(t));
      },
      move(t, e) { return this.attr(this.array().move(t, e).toLine()); },
      size(t, e) { const i = g(this, t, e); return this.attr(this.array().size(i.width, i.height).toLine()); },
    },
    construct: { line(t, e, a, s) { return i.Line.prototype.plot.apply(this.put(new i.Line()), t != null ? [t, e, a, s] : [0, 0, 0, 0]); } },
  }), i.Polyline = i.invent({ create: 'polyline', inherit: i.Shape, construct: { polyline(t) { return this.put(new i.Polyline()).plot(t || new i.PointArray()); } } }), i.Polygon = i.invent({ create: 'polygon', inherit: i.Shape, construct: { polygon(t) { return this.put(new i.Polygon()).plot(t || new i.PointArray()); } } }), i.extend(i.Polyline, i.Polygon, {
    array() { return this._array || (this._array = new i.PointArray(this.attr('points'))); }, plot(t) { return t == null ? this.array() : this.clear().attr('points', typeof t === 'string' ? t : this._array = new i.PointArray(t)); }, clear() { return delete this._array, this; }, move(t, e) { return this.attr('points', this.array().move(t, e)); }, size(t, e) { const i = g(this, t, e); return this.attr('points', this.array().size(i.width, i.height)); },
  }), i.extend(i.Line, i.Polyline, i.Polygon, {
    morphArray: i.PointArray, x(t) { return t == null ? this.bbox().x : this.move(t, this.bbox().y); }, y(t) { return t == null ? this.bbox().y : this.move(this.bbox().x, t); }, width(t) { const e = this.bbox(); return t == null ? e.width : this.size(t, e.height); }, height(t) { const e = this.bbox(); return t == null ? e.height : this.size(e.width, t); },
  }), i.Path = i.invent({
    create: 'path',
    inherit: i.Shape,
    extend: {
      morphArray: i.PathArray, array() { return this._array || (this._array = new i.PathArray(this.attr('d'))); }, plot(t) { return t == null ? this.array() : this.clear().attr('d', typeof t === 'string' ? t : this._array = new i.PathArray(t)); }, clear() { return delete this._array, this; },
    },
    construct: { path(t) { return this.put(new i.Path()).plot(t || new i.PathArray()); } },
  }), i.Image = i.invent({
    create: 'image',
    inherit: i.Shape,
    extend: {
      load(e) {
        if (!e) return this; const a = this; const s = new t.Image(); return i.on(s, 'load', (() => {
          i.off(s); const t = a.parent(i.Pattern); t !== null && (a.width() == 0 && a.height() == 0 && a.size(s.width, s.height), t && t.width() == 0 && t.height() == 0 && t.size(a.width(), a.height()), typeof a._loaded === 'function' && a._loaded.call(a, {
            width: s.width, height: s.height, ratio: s.width / s.height, url: e,
          }));
        })), i.on(s, 'error', ((t) => { i.off(s), typeof a._error === 'function' && a._error.call(a, t); })), this.attr('href', s.src = this.src = e, i.xlink);
      },
      loaded(t) { return this._loaded = t, this; },
      error(t) { return this._error = t, this; },
    },
    construct: { image(t, e, a) { return this.put(new i.Image()).load(t).size(e || 0, a || e || 0); } },
  }), i.Text = i.invent({
    create() { this.constructor.call(this, i.create('text')), this.dom.leading = new i.Number(1.3), this._rebuild = !0, this._build = !1, this.attr('font-family', i.defaults.attrs['font-family']); },
    inherit: i.Shape,
    extend: {
      x(t) { return t == null ? this.attr('x') : this.attr('x', t); }, text(t) { if (void 0 === t) { t = ''; for (var e = this.node.childNodes, a = 0, s = e.length; a < s; ++a)a != 0 && e[a].nodeType != 3 && i.adopt(e[a]).dom.newLined == 1 && (t += '\n'), t += e[a].textContent; return t; } if (this.clear().build(!0), typeof t === 'function')t.call(this, this); else { a = 0; for (let r = (t = t.split('\n')).length; a < r; a++) this.tspan(t[a]).newLine(); } return this.build(!1).rebuild(); }, size(t) { return this.attr('font-size', t).rebuild(); }, leading(t) { return t == null ? this.dom.leading : (this.dom.leading = new i.Number(t), this.rebuild()); }, lines() { const t = (this.textPath && this.textPath() || this).node; const e = i.utils.map(i.utils.filterSVGElements(t.childNodes), ((t) => i.adopt(t))); return new i.Set(e); }, rebuild(t) { if (typeof t === 'boolean' && (this._rebuild = t), this._rebuild) { const e = this; let a = 0; const s = this.dom.leading * new i.Number(this.attr('font-size')); this.lines().each((function () { this.dom.newLined && (e.textPath() || this.attr('x', e.attr('x')), this.text() == '\n' ? a += s : (this.attr('dy', s + a), a = 0)); })), this.fire('rebuild'); } return this; }, build(t) { return this._build = !!t, this; }, setData(t) { return this.dom = t, this.dom.leading = new i.Number(t.leading || 1.3), this; },
    },
    construct: { text(t) { return this.put(new i.Text()).text(t); }, plain(t) { return this.put(new i.Text()).plain(t); } },
  }), i.Tspan = i.invent({
    create: 'tspan',
    inherit: i.Shape,
    extend: {
      text(t) { return t == null ? this.node.textContent + (this.dom.newLined ? '\n' : '') : (typeof t === 'function' ? t.call(this, this) : this.plain(t), this); }, dx(t) { return this.attr('dx', t); }, dy(t) { return this.attr('dy', t); }, newLine() { const t = this.parent(i.Text); return this.dom.newLined = !0, this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x()); },
    },
  }), i.extend(i.Text, i.Tspan, {
    plain(t) { return !1 === this._build && this.clear(), this.node.appendChild(e.createTextNode(t)), this; }, tspan(t) { const e = (this.textPath && this.textPath() || this).node; const a = new i.Tspan(); return !1 === this._build && this.clear(), e.appendChild(a.node), a.text(t); }, clear() { for (let t = (this.textPath && this.textPath() || this).node; t.hasChildNodes();)t.removeChild(t.lastChild); return this; }, length() { return this.node.getComputedTextLength(); },
  }), i.TextPath = i.invent({
    create: 'textPath',
    inherit: i.Parent,
    parent: i.Text,
    construct: {
      morphArray: i.PathArray, array() { const t = this.track(); return t ? t.array() : null; }, plot(t) { const e = this.track(); let i = null; return e && (i = e.plot(t)), t == null ? i : this; }, track() { const t = this.textPath(); if (t) return t.reference('href'); }, textPath() { if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath') return i.adopt(this.node.firstChild); },
    },
  }), i.Nested = i.invent({ create() { this.constructor.call(this, i.create('svg')), this.style('overflow', 'visible'); }, inherit: i.Container, construct: { nested() { return this.put(new i.Nested()); } } }); const o = { stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'], fill: ['color', 'opacity', 'rule'], prefix(t, e) { return e == 'color' ? t : `${t}-${e}`; } }; function l(t, e, a, s) { return a + s.replace(i.regex.dots, ' .'); } function h(t) { return t.toLowerCase().replace(/-(.)/g, ((t, e) => e.toUpperCase())); } function c(t) { return t.charAt(0).toUpperCase() + t.slice(1); } function d(t) { const e = t.toString(16); return e.length == 1 ? `0${e}` : e; } function g(t, e, i) { if (e == null || i == null) { const a = t.bbox(); e == null ? e = a.width / a.height * i : i == null && (i = a.height / a.width * e); } return { width: e, height: i }; } function u(t, e, i) { return { x: e * t.a + i * t.c + 0, y: e * t.b + i * t.d + 0 }; } function p(t) {
    return {
      a: t[0], b: t[1], c: t[2], d: t[3], e: t[4], f: t[5],
    };
  } function f(e) { for (let a = e.childNodes.length - 1; a >= 0; a--)e.childNodes[a] instanceof t.SVGElement && f(e.childNodes[a]); return i.adopt(e).id(i.eid(e.nodeName)); } function x(t) { return t.x == null && (t.x = 0, t.y = 0, t.width = 0, t.height = 0), t.w = t.width, t.h = t.height, t.x2 = t.x + t.width, t.y2 = t.y + t.height, t.cx = t.x + t.width / 2, t.cy = t.y + t.height / 2, t; } function b(t) { return Math.abs(t) > 1e-37 ? t : 0; }['fill', 'stroke'].forEach(((t) => { let e; const a = {}; a[t] = function (a) { if (void 0 === a) return this; if (typeof a === 'string' || i.Color.isRgb(a) || a && typeof a.fill === 'function') this.attr(t, a); else for (e = o[t].length - 1; e >= 0; e--)a[o[t][e]] != null && this.attr(o.prefix(t, o[t][e]), a[o[t][e]]); return this; }, i.extend(i.Element, i.FX, a); })), i.extend(i.Element, i.FX, {
    translate(t, e) { return this.transform({ x: t, y: e }); }, matrix(t) { return this.attr('transform', new i.Matrix(arguments.length == 6 ? [].slice.call(arguments) : t)); }, opacity(t) { return this.attr('opacity', t); }, dx(t) { return this.x(new i.Number(t).plus(this instanceof i.FX ? 0 : this.x()), !0); }, dy(t) { return this.y(new i.Number(t).plus(this instanceof i.FX ? 0 : this.y()), !0); },
  }), i.extend(i.Path, { length() { return this.node.getTotalLength(); }, pointAt(t) { return this.node.getPointAtLength(t); } }), i.Set = i.invent({
    create(t) { Array.isArray(t) ? this.members = t : this.clear(); },
    extend: {
      add() { let t; let e; const i = [].slice.call(arguments); for (t = 0, e = i.length; t < e; t++) this.members.push(i[t]); return this; }, remove(t) { const e = this.index(t); return e > -1 && this.members.splice(e, 1), this; }, each(t) { for (let e = 0, i = this.members.length; e < i; e++)t.apply(this.members[e], [e, this.members]); return this; }, clear() { return this.members = [], this; }, length() { return this.members.length; }, has(t) { return this.index(t) >= 0; }, index(t) { return this.members.indexOf(t); }, get(t) { return this.members[t]; }, first() { return this.get(0); }, last() { return this.get(this.members.length - 1); }, valueOf() { return this.members; },
    },
    construct: { set(t) { return new i.Set(t); } },
  }), i.FX.Set = i.invent({ create(t) { this.set = t; } }), i.Set.inherit = function () { let t = []; for (var e in i.Shape.prototype) typeof i.Shape.prototype[e] === 'function' && typeof i.Set.prototype[e] !== 'function' && t.push(e); for (var e in t.forEach(((t) => { i.Set.prototype[t] = function () { for (let e = 0, a = this.members.length; e < a; e++) this.members[e] && typeof this.members[e][t] === 'function' && this.members[e][t].apply(this.members[e], arguments); return t == 'animate' ? this.fx || (this.fx = new i.FX.Set(this)) : this; }; })), t = [], i.FX.prototype) typeof i.FX.prototype[e] === 'function' && typeof i.FX.Set.prototype[e] !== 'function' && t.push(e); t.forEach(((t) => { i.FX.Set.prototype[t] = function () { for (let e = 0, i = this.set.members.length; e < i; e++) this.set.members[e].fx[t].apply(this.set.members[e].fx, arguments); return this; }; })); }, i.extend(i.Element, {}), i.extend(i.Element, { remember(t, e) { if (_typeof(arguments[0]) === 'object') for (var e in t) this.remember(e, t[e]); else { if (arguments.length == 1) return this.memory()[t]; this.memory()[t] = e; } return this; }, forget() { if (arguments.length == 0) this._memory = {}; else for (let t = arguments.length - 1; t >= 0; t--) delete this.memory()[arguments[t]]; return this; }, memory() { return this._memory || (this._memory = {}); } }), i.get = function (t) { const a = e.getElementById((function (t) { const e = (t || '').toString().match(i.regex.reference); if (e) return e[1]; }(t)) || t); return i.adopt(a); }, i.select = function (t, a) { return new i.Set(i.utils.map((a || e).querySelectorAll(t), ((t) => i.adopt(t)))); }, i.extend(i.Parent, { select(t) { return i.select(t, this.node); } }); var m = 'abcdef'.split(''); if (typeof t.CustomEvent !== 'function') { const v = function (t, i) { i = i || { bubbles: !1, cancelable: !1, detail: void 0 }; const a = e.createEvent('CustomEvent'); return a.initCustomEvent(t, i.bubbles, i.cancelable, i.detail), a; }; v.prototype = t.Event.prototype, i.CustomEvent = v; } else i.CustomEvent = t.CustomEvent; return i;
}))),
/*! svg.filter.js - v2.0.2 - 2016-02-24
* https://github.com/wout/svg.filter.js
* Copyright (c) 2016 Wout Fierens; Licensed MIT */
function () {
  SVG.Filter = SVG.invent({
    create: 'filter',
    inherit: SVG.Parent,
    extend: {
      source: 'SourceGraphic', sourceAlpha: 'SourceAlpha', background: 'BackgroundImage', backgroundAlpha: 'BackgroundAlpha', fill: 'FillPaint', stroke: 'StrokePaint', autoSetIn: !0, put(t, e) { return this.add(t, e), !t.attr('in') && this.autoSetIn && t.attr('in', this.source), t.attr('result') || t.attr('result', t), t; }, blend(t, e, i) { return this.put(new SVG.BlendEffect(t, e, i)); }, colorMatrix(t, e) { return this.put(new SVG.ColorMatrixEffect(t, e)); }, convolveMatrix(t) { return this.put(new SVG.ConvolveMatrixEffect(t)); }, componentTransfer(t) { return this.put(new SVG.ComponentTransferEffect(t)); }, composite(t, e, i) { return this.put(new SVG.CompositeEffect(t, e, i)); }, flood(t, e) { return this.put(new SVG.FloodEffect(t, e)); }, offset(t, e) { return this.put(new SVG.OffsetEffect(t, e)); }, image(t) { return this.put(new SVG.ImageEffect(t)); }, merge() { const t = [void 0]; for (const e in arguments)t.push(arguments[e]); return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t))()); }, gaussianBlur(t, e) { return this.put(new SVG.GaussianBlurEffect(t, e)); }, morphology(t, e) { return this.put(new SVG.MorphologyEffect(t, e)); }, diffuseLighting(t, e, i) { return this.put(new SVG.DiffuseLightingEffect(t, e, i)); }, displacementMap(t, e, i, a, s) { return this.put(new SVG.DisplacementMapEffect(t, e, i, a, s)); }, specularLighting(t, e, i, a) { return this.put(new SVG.SpecularLightingEffect(t, e, i, a)); }, tile() { return this.put(new SVG.TileEffect()); }, turbulence(t, e, i, a, s) { return this.put(new SVG.TurbulenceEffect(t, e, i, a, s)); }, toString() { return `url(#${this.attr('id')})`; },
    },
  }), SVG.extend(SVG.Defs, { filter(t) { const e = this.put(new SVG.Filter()); return typeof t === 'function' && t.call(e, e), e; } }), SVG.extend(SVG.Container, { filter(t) { return this.defs().filter(t); } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter(t) { return this.filterer = t instanceof SVG.Element ? t : this.doc().filter(t), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr('filter', this.filterer), this.filterer; }, unfilter(t) { return this.filterer && !0 === t && this.filterer.remove(), delete this.filterer, this.attr('filter', null); } }), SVG.Effect = SVG.invent({ create() { this.constructor.call(this); }, inherit: SVG.Element, extend: { in(t) { return t == null ? this.parent() && this.parent().select(`[result="${this.attr('in')}"]`).get(0) || this.attr('in') : this.attr('in', t); }, result(t) { return t == null ? this.attr('result') : this.attr('result', t); }, toString() { return this.result(); } } }), SVG.ParentEffect = SVG.invent({ create() { this.constructor.call(this); }, inherit: SVG.Parent, extend: { in(t) { return t == null ? this.parent() && this.parent().select(`[result="${this.attr('in')}"]`).get(0) || this.attr('in') : this.attr('in', t); }, result(t) { return t == null ? this.attr('result') : this.attr('result', t); }, toString() { return this.result(); } } }); const t = {
    blend(t, e) { return this.parent() && this.parent().blend(this, t, e); }, colorMatrix(t, e) { return this.parent() && this.parent().colorMatrix(t, e).in(this); }, convolveMatrix(t) { return this.parent() && this.parent().convolveMatrix(t).in(this); }, componentTransfer(t) { return this.parent() && this.parent().componentTransfer(t).in(this); }, composite(t, e) { return this.parent() && this.parent().composite(this, t, e); }, flood(t, e) { return this.parent() && this.parent().flood(t, e); }, offset(t, e) { return this.parent() && this.parent().offset(t, e).in(this); }, image(t) { return this.parent() && this.parent().image(t); }, merge() { return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments)); }, gaussianBlur(t, e) { return this.parent() && this.parent().gaussianBlur(t, e).in(this); }, morphology(t, e) { return this.parent() && this.parent().morphology(t, e).in(this); }, diffuseLighting(t, e, i) { return this.parent() && this.parent().diffuseLighting(t, e, i).in(this); }, displacementMap(t, e, i, a) { return this.parent() && this.parent().displacementMap(this, t, e, i, a); }, specularLighting(t, e, i, a) { return this.parent() && this.parent().specularLighting(t, e, i, a).in(this); }, tile() { return this.parent() && this.parent().tile().in(this); }, turbulence(t, e, i, a, s) { return this.parent() && this.parent().turbulence(t, e, i, a, s).in(this); },
  }; SVG.extend(SVG.Effect, t), SVG.extend(SVG.ParentEffect, t), SVG.ChildEffect = SVG.invent({ create() { this.constructor.call(this); }, inherit: SVG.Element, extend: { in(t) { this.attr('in', t); } } }); const e = {
    blend(t, e, i) { this.attr({ in: t, in2: e, mode: i || 'normal' }); },
    colorMatrix(t, e) { t == 'matrix' && (e = s(e)), this.attr({ type: t, values: void 0 === e ? null : e }); },
    convolveMatrix(t) { t = s(t), this.attr({ order: Math.sqrt(t.split(' ').length), kernelMatrix: t }); },
    composite(t, e, i) { this.attr({ in: t, in2: e, operator: i }); },
    flood(t, e) { this.attr('flood-color', t), e != null && this.attr('flood-opacity', e); },
    offset(t, e) { this.attr({ dx: t, dy: e }); },
    image(t) { this.attr('href', t, SVG.xlink); },
    displacementMap(t, e, i, a, s) {
      this.attr({
        in: t, in2: e, scale: i, xChannelSelector: a, yChannelSelector: s,
      });
    },
    gaussianBlur(t, e) { t != null || e != null ? this.attr('stdDeviation', r(Array.prototype.slice.call(arguments))) : this.attr('stdDeviation', '0 0'); },
    morphology(t, e) { this.attr({ operator: t, radius: e }); },
    tile() {},
    turbulence(t, e, i, a, s) {
      this.attr({
        numOctaves: e, seed: i, stitchTiles: a, baseFrequency: t, type: s,
      });
    },
  }; const i = {
    merge() { let t; if (arguments[0] instanceof SVG.Set) { const e = this; arguments[0].each((function (t) { this instanceof SVG.MergeNode ? e.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e.put(new SVG.MergeNode(this)); })); } else { t = Array.isArray(arguments[0]) ? arguments[0] : arguments; for (let i = 0; i < t.length; i++)t[i] instanceof SVG.MergeNode ? this.put(t[i]) : this.put(new SVG.MergeNode(t[i])); } },
    componentTransfer(t) { if (this.rgb = new SVG.Set(), ['r', 'g', 'b', 'a'].forEach((t) => { this[t] = new (SVG[`Func${t.toUpperCase()}`])('identity'), this.rgb.add(this[t]), this.node.appendChild(this[t].node); }), t) for (const e in t.rgb && (['r', 'g', 'b'].forEach((e) => { this[e].attr(t.rgb); }), delete t.rgb), t) this[e].attr(t[e]); },
    diffuseLighting(t, e, i) { this.attr({ surfaceScale: t, diffuseConstant: e, kernelUnitLength: i }); },
    specularLighting(t, e, i, a) {
      this.attr({
        surfaceScale: t, diffuseConstant: e, specularExponent: i, kernelUnitLength: a,
      });
    },
  }; const a = {
    distantLight(t, e) { this.attr({ azimuth: t, elevation: e }); },
    pointLight(t, e, i) { this.attr({ x: t, y: e, z: i }); },
    spotLight(t, e, i, a, s, r) {
      this.attr({
        x: t, y: e, z: i, pointsAtX: a, pointsAtY: s, pointsAtZ: r,
      });
    },
    mergeNode(t) { this.attr('in', t); },
  }; function s(t) { return Array.isArray(t) && (t = new SVG.Array(t)), t.toString().replace(/^\s+/, '').replace(/\s+$/, '').replace(/\s+/g, ' '); } function r(t) { if (!Array.isArray(t)) return t; for (var e = 0, i = t.length, a = []; e < i; e++)a.push(t[e]); return a.join(' '); } function n() { let t = function () {}; for (const e in typeof arguments[arguments.length - 1] === 'function' && (t = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments) for (const i in arguments[e])t(arguments[e][i], i, arguments[e]); }['r', 'g', 'b', 'a'].forEach(((t) => { a[`Func${t.toUpperCase()}`] = function (t) { switch (this.attr('type', t), t) { case 'table': this.attr('tableValues', arguments[1]); break; case 'linear': this.attr('slope', arguments[1]), this.attr('intercept', arguments[2]); break; case 'gamma': this.attr('amplitude', arguments[1]), this.attr('exponent', arguments[2]), this.attr('offset', arguments[2]); } }; })), n(e, ((t, e) => { const i = e.charAt(0).toUpperCase() + e.slice(1); SVG[`${i}Effect`] = SVG.invent({ create() { this.constructor.call(this, SVG.create(`fe${i}`)), t.apply(this, arguments), this.result(`${this.attr('id')}Out`); }, inherit: SVG.Effect, extend: {} }); })), n(i, ((t, e) => { const i = e.charAt(0).toUpperCase() + e.slice(1); SVG[`${i}Effect`] = SVG.invent({ create() { this.constructor.call(this, SVG.create(`fe${i}`)), t.apply(this, arguments), this.result(`${this.attr('id')}Out`); }, inherit: SVG.ParentEffect, extend: {} }); })), n(a, ((t, e) => { const i = e.charAt(0).toUpperCase() + e.slice(1); SVG[i] = SVG.invent({ create() { this.constructor.call(this, SVG.create(`fe${i}`)), t.apply(this, arguments); }, inherit: SVG.ChildEffect, extend: {} }); })), SVG.extend(SVG.MergeEffect, { in(t) { return t instanceof SVG.MergeNode ? this.add(t, 0) : this.add(new SVG.MergeNode(t), 0), this; } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2(t) { return t == null ? this.parent() && this.parent().select(`[result="${this.attr('in2')}"]`).get(0) || this.attr('in2') : this.attr('in2', t); } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
}.call(void 0), (function () { function t(t, s, r, n, o, l, h) { for (var c = t.slice(s, r || h), d = n.slice(o, l || h), g = 0, u = { pos: [0, 0], start: [0, 0] }, p = { pos: [0, 0], start: [0, 0] }; ;) { if (c[g] = e.call(u, c[g]), d[g] = e.call(p, d[g]), c[g][0] != d[g][0] || c[g][0] == 'M' || c[g][0] == 'A' && (c[g][4] != d[g][4] || c[g][5] != d[g][5]) ? (Array.prototype.splice.apply(c, [g, 1].concat(a.call(u, c[g]))), Array.prototype.splice.apply(d, [g, 1].concat(a.call(p, d[g])))) : (c[g] = i.call(u, c[g]), d[g] = i.call(p, d[g])), ++g == c.length && g == d.length) break; g == c.length && c.push(['C', u.pos[0], u.pos[1], u.pos[0], u.pos[1], u.pos[0], u.pos[1]]), g == d.length && d.push(['C', p.pos[0], p.pos[1], p.pos[0], p.pos[1], p.pos[0], p.pos[1]]); } return { start: c, dest: d }; } function e(t) { switch (t[0]) { case 'z': case 'Z': t[0] = 'L', t[1] = this.start[0], t[2] = this.start[1]; break; case 'H': t[0] = 'L', t[2] = this.pos[1]; break; case 'V': t[0] = 'L', t[2] = t[1], t[1] = this.pos[0]; break; case 'T': t[0] = 'Q', t[3] = t[1], t[4] = t[2], t[1] = this.reflection[1], t[2] = this.reflection[0]; break; case 'S': t[0] = 'C', t[6] = t[4], t[5] = t[3], t[4] = t[2], t[3] = t[1], t[2] = this.reflection[1], t[1] = this.reflection[0]; } return t; } function i(t) { const e = t.length; return this.pos = [t[e - 2], t[e - 1]], 'SCQT'.indexOf(t[0]) != -1 && (this.reflection = [2 * this.pos[0] - t[e - 4], 2 * this.pos[1] - t[e - 3]]), t; } function a(t) { let e = [t]; switch (t[0]) { case 'M': return this.pos = this.start = [t[1], t[2]], e; case 'L': t[5] = t[3] = t[1], t[6] = t[4] = t[2], t[1] = this.pos[0], t[2] = this.pos[1]; break; case 'Q': t[6] = t[4], t[5] = t[3], t[4] = 1 * t[4] / 3 + 2 * t[2] / 3, t[3] = 1 * t[3] / 3 + 2 * t[1] / 3, t[2] = 1 * this.pos[1] / 3 + 2 * t[2] / 3, t[1] = 1 * this.pos[0] / 3 + 2 * t[1] / 3; break; case 'A': t = (e = (function (t, e) { let i; let a; let s; let r; let n; let o; let l; let h; let c; let d; let g; let u; let p; let f; let x; let b; let m; let v; let y; let w; let k; let C; let A; let S; let L; let P; let T = Math.abs(e[1]); let z = Math.abs(e[2]); const E = e[3] % 360; const M = e[4]; const I = e[5]; let X = e[6]; let Y = e[7]; let D = new SVG.Point(t); let R = new SVG.Point(X, Y); const F = []; if (T === 0 || z === 0 || D.x === R.x && D.y === R.y) return [['C', D.x, D.y, R.x, R.y, R.x, R.y]]; i = new SVG.Point((D.x - R.x) / 2, (D.y - R.y) / 2).transform((new SVG.Matrix()).rotate(E)), (a = i.x * i.x / (T * T) + i.y * i.y / (z * z)) > 1 && (a = Math.sqrt(a), T *= a, z *= a); s = (new SVG.Matrix()).rotate(E).scale(1 / T, 1 / z).rotate(-E), D = D.transform(s), R = R.transform(s), r = [R.x - D.x, R.y - D.y], o = r[0] * r[0] + r[1] * r[1], n = Math.sqrt(o), r[0] /= n, r[1] /= n, l = o < 4 ? Math.sqrt(1 - o / 4) : 0, M === I && (l *= -1); h = new SVG.Point((R.x + D.x) / 2 + l * -r[1], (R.y + D.y) / 2 + l * r[0]), c = new SVG.Point(D.x - h.x, D.y - h.y), d = new SVG.Point(R.x - h.x, R.y - h.y), g = Math.acos(c.x / Math.sqrt(c.x * c.x + c.y * c.y)), c.y < 0 && (g *= -1); u = Math.acos(d.x / Math.sqrt(d.x * d.x + d.y * d.y)), d.y < 0 && (u *= -1); I && g > u && (u += 2 * Math.PI); !I && g < u && (u -= 2 * Math.PI); for (f = Math.ceil(2 * Math.abs(g - u) / Math.PI), b = [], m = g, p = (u - g) / f, x = 4 * Math.tan(p / 4) / 3, k = 0; k <= f; k++)y = Math.cos(m), v = Math.sin(m), w = new SVG.Point(h.x + y, h.y + v), b[k] = [new SVG.Point(w.x + x * v, w.y - x * y), w, new SVG.Point(w.x - x * v, w.y + x * y)], m += p; for (b[0][0] = b[0][1].clone(), b[b.length - 1][2] = b[b.length - 1][1].clone(), s = (new SVG.Matrix()).rotate(E).scale(T, z).rotate(-E), k = 0, C = b.length; k < C; k++)b[k][0] = b[k][0].transform(s), b[k][1] = b[k][1].transform(s), b[k][2] = b[k][2].transform(s); for (k = 1, C = b.length; k < C; k++)w = b[k - 1][2], A = w.x, S = w.y, w = b[k][0], L = w.x, P = w.y, w = b[k][1], X = w.x, Y = w.y, F.push(['C', A, S, L, P, X, Y]); return F; }(this.pos, t)))[0]; } return t[0] = 'C', this.pos = [t[5], t[6]], this.reflection = [2 * t[5] - t[3], 2 * t[6] - t[4]], e; } function s(t, e) { if (!1 === e) return !1; for (let i = e, a = t.length; i < a; ++i) if (t[i][0] == 'M') return i; return !1; }SVG.extend(SVG.PathArray, { morph(e) { for (var i = this.value, a = this.parse(e), r = 0, n = 0, o = !1, l = !1; !1 !== r || !1 !== n;) { var h; o = s(i, !1 !== r && r + 1), l = s(a, !1 !== n && n + 1), !1 === r && (r = (h = new SVG.PathArray(c.start).bbox()).height == 0 || h.width == 0 ? i.push(i[0]) - 1 : i.push(['M', h.x + h.width / 2, h.y + h.height / 2]) - 1), !1 === n && (n = (h = new SVG.PathArray(c.dest).bbox()).height == 0 || h.width == 0 ? a.push(a[0]) - 1 : a.push(['M', h.x + h.width / 2, h.y + h.height / 2]) - 1); var c = t(i, r, o, a, n, l); i = i.slice(0, r).concat(c.start, !1 === o ? [] : i.slice(o)), a = a.slice(0, n).concat(c.dest, !1 === l ? [] : a.slice(l)), r = !1 !== o && r + c.start.length, n = !1 !== l && n + c.dest.length; } return this.value = i, this.destination = new SVG.PathArray(), this.destination.value = a, this; } }); }()),
/*! svg.draggable.js - v2.2.2 - 2019-01-08
* https://github.com/svgdotjs/svg.draggable.js
* Copyright (c) 2019 Wout Fierens; Licensed MIT */
function () {
  function t(t) { t.remember('_draggable', this), this.el = t; }t.prototype.init = function (t, e) { const i = this; this.constraint = t, this.value = e, this.el.on('mousedown.drag', ((t) => { i.start(t); })), this.el.on('touchstart.drag', ((t) => { i.start(t); })); }, t.prototype.transformPoint = function (t, e) { const i = (t = t || window.event).changedTouches && t.changedTouches[0] || t; return this.p.x = i.clientX - (e || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m); }, t.prototype.getBBox = function () { let t = this.el.bbox(); return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t; }, t.prototype.start = function (t) {
    if (t.type != 'click' && t.type != 'mousedown' && t.type != 'mousemove' || (t.which || t.buttons) == 1) {
      const e = this; if (this.el.fire('beforedrag', { event: t, handler: this }), !this.el.event().defaultPrevented) {
        t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse(); let i; const a = this.getBBox(); if (this.el instanceof SVG.Text) switch (i = this.el.node.getComputedTextLength(), this.el.attr('text-anchor')) { case 'middle': i /= 2; break; case 'start': i = 0; } this.startPoints = { point: this.transformPoint(t, i), box: a, transform: this.el.transform() }, SVG.on(window, 'mousemove.drag', ((t) => { e.drag(t); })), SVG.on(window, 'touchmove.drag', ((t) => { e.drag(t); })), SVG.on(window, 'mouseup.drag', ((t) => { e.end(t); })), SVG.on(window, 'touchend.drag', ((t) => { e.end(t); })), this.el.fire('dragstart', {
          event: t, p: this.startPoints.point, m: this.m, handler: this,
        });
      }
    }
  }, t.prototype.drag = function (t) {
    const e = this.getBBox(); const i = this.transformPoint(t); let a = this.startPoints.box.x + i.x - this.startPoints.point.x; let s = this.startPoints.box.y + i.y - this.startPoints.point.y; const r = this.constraint; let n = i.x - this.startPoints.point.x; let o = i.y - this.startPoints.point.y; if (this.el.fire('dragmove', {
      event: t, p: i, m: this.m, handler: this,
    }), this.el.event().defaultPrevented) return i; if (typeof r === 'function') { let l = r.call(this.el, a, s, this.m); typeof l === 'boolean' && (l = { x: l, y: l }), !0 === l.x ? this.el.x(a) : !1 !== l.x && this.el.x(l.x), !0 === l.y ? this.el.y(s) : !1 !== l.y && this.el.y(l.y); } else typeof r === 'object' && (r.minX != null && a < r.minX ? n = (a = r.minX) - this.startPoints.box.x : r.maxX != null && a > r.maxX - e.width && (n = (a = r.maxX - e.width) - this.startPoints.box.x), r.minY != null && s < r.minY ? o = (s = r.minY) - this.startPoints.box.y : r.maxY != null && s > r.maxY - e.height && (o = (s = r.maxY - e.height) - this.startPoints.box.y), r.snapToGrid != null && (a -= a % r.snapToGrid, s -= s % r.snapToGrid, n -= n % r.snapToGrid, o -= o % r.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: n, y: o }, !0) : this.el.move(a, s)); return i;
  }, t.prototype.end = function (t) {
    const e = this.drag(t); this.el.fire('dragend', {
      event: t, p: e, m: this.m, handler: this,
    }), SVG.off(window, 'mousemove.drag'), SVG.off(window, 'touchmove.drag'), SVG.off(window, 'mouseup.drag'), SVG.off(window, 'touchend.drag');
  }, SVG.extend(SVG.Element, { draggable(e, i) { typeof e !== 'function' && typeof e !== 'object' || (i = e, e = !0); const a = this.remember('_draggable') || new t(this); return (e = void 0 === e || e) ? a.init(i || {}, e) : (this.off('mousedown.drag'), this.off('touchstart.drag')), this; } });
}.call(void 0), (function () {
  function t(t) { this.el = t, t.remember('_selectHandler', this), this.pointSelection = { isSelected: !1 }, this.rectSelection = { isSelected: !1 }; }t.prototype.init = function (t, e) { const i = this.el.bbox(); for (const a in this.options = {}, this.el.selectize.defaults) this.options[a] = this.el.selectize.defaults[a], void 0 !== e[a] && (this.options[a] = e[a]); this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && ['line', 'polyline', 'polygon'].indexOf(this.el.type) !== -1 ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup(); }, t.prototype.selectPoints = function (t) { return this.pointSelection.isSelected = t, this.pointSelection.set ? this : (this.pointSelection.set = this.parent.set(), this.drawCircles(), this); }, t.prototype.getPointArray = function () { const t = this.el.bbox(); return this.el.array().valueOf().map(((e) => [e[0] - t.x, e[1] - t.y])); }, t.prototype.drawCircles = function () {
    for (var t = this, e = this.getPointArray(), i = 0, a = e.length; i < a; ++i) {
      const s = (function (e) {
        return function (i) {
          (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation(); const a = i.pageX || i.touches[0].pageX; const s = i.pageY || i.touches[0].pageY; t.el.fire('point', {
            x: a, y: s, i: e, event: i,
          });
        };
      }(i)); this.pointSelection.set.add(this.nested.circle(this.options.radius).center(e[i][0], e[i][1]).addClass(this.options.classPoints).addClass(`${this.options.classPoints}_point`)
        .on('touchstart', s)
        .on('mousedown', s));
    }
  }, t.prototype.updatePointSelection = function () { const t = this.getPointArray(); this.pointSelection.set.each((function (e) { this.cx() === t[e][0] && this.cy() === t[e][1] || this.center(t[e][0], t[e][1]); })); }, t.prototype.updateRectSelection = function () { const t = this.el.bbox(); this.rectSelection.set.get(0).attr({ width: t.width, height: t.height }), this.options.points && (this.rectSelection.set.get(2).center(t.width, 0), this.rectSelection.set.get(3).center(t.width, t.height), this.rectSelection.set.get(4).center(0, t.height), this.rectSelection.set.get(5).center(t.width / 2, 0), this.rectSelection.set.get(6).center(t.width, t.height / 2), this.rectSelection.set.get(7).center(t.width / 2, t.height), this.rectSelection.set.get(8).center(0, t.height / 2)), this.options.rotationPoint && (this.options.points ? this.rectSelection.set.get(9).center(t.width / 2, 20) : this.rectSelection.set.get(1).center(t.width / 2, 20)); }, t.prototype.selectRect = function (t) {
    const e = this; const i = this.el.bbox(); function a(t) { return function (i) { (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation(); const a = i.pageX || i.touches[0].pageX; const s = i.pageY || i.touches[0].pageY; e.el.fire(t, { x: a, y: s, event: i }); }; } if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points && !this.rectSelection.set.get(1)) {
      const s = 'touchstart'; const r = 'mousedown'; this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, 0).attr('class', `${this.options.classPoints}_lt`).on(r, a('lt'))
        .on(s, a('lt'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width, 0).attr('class', `${this.options.classPoints}_rt`).on(r, a('rt'))
        .on(s, a('rt'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width, i.height).attr('class', `${this.options.classPoints}_rb`).on(r, a('rb'))
        .on(s, a('rb'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, i.height).attr('class', `${this.options.classPoints}_lb`).on(r, a('lb'))
        .on(s, a('lb'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width / 2, 0).attr('class', `${this.options.classPoints}_t`).on(r, a('t'))
        .on(s, a('t'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width, i.height / 2).attr('class', `${this.options.classPoints}_r`).on(r, a('r'))
        .on(s, a('r'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width / 2, i.height).attr('class', `${this.options.classPoints}_b`).on(r, a('b'))
        .on(s, a('b'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, i.height / 2).attr('class', `${this.options.classPoints}_l`).on(r, a('l'))
        .on(s, a('l'))), this.rectSelection.set.each((function () { this.addClass(e.options.classPoints); }));
    } if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
      const n = function (t) { (t = t || window.event).preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation(); const i = t.pageX || t.touches[0].pageX; const a = t.pageY || t.touches[0].pageY; e.el.fire('rot', { x: i, y: a, event: t }); }; this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width / 2, 20).attr('class', `${this.options.classPoints}_rot`).on('touchstart', n)
        .on('mousedown', n));
    }
  }, t.prototype.handler = function () { const t = this.el.bbox(); this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection(); }, t.prototype.observe = function () { const t = this; if (MutationObserver) if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(((() => { t.handler(); }))), this.observerInst.observe(this.el.node, { attributes: !0 }); else try { this.observerInst.disconnect(), delete this.observerInst; } catch (t) {} else this.el.off('DOMAttrModified.select'), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on('DOMAttrModified.select', (() => { t.handler(); })); }, t.prototype.cleanup = function () { !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each((function () { this.remove(); })), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each((function () { this.remove(); })), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested); }, SVG.extend(SVG.Element, { selectize(e, i) { return typeof e === 'object' && (i = e, e = !0), (this.remember('_selectHandler') || new t(this)).init(void 0 === e || e, i || {}), this; } }), SVG.Element.prototype.selectize.defaults = {
    points: !0, classRect: 'svg_select_boundingRect', classPoints: 'svg_select_points', radius: 7, rotationPoint: !0, deepSelect: !1,
  };
}()), (function () {
  (function () {
    function t(t) { t.remember('_resizeHandler', this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint(); }t.prototype.transformPoint = function (t, e, i) { return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = e - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m); }, t.prototype._extractPosition = function (t) { return { x: t.clientX != null ? t.clientX : t.touches[0].clientX, y: t.clientY != null ? t.clientY : t.touches[0].clientY }; }, t.prototype.init = function (t) { const e = this; if (this.stop(), t !== 'stop') { for (const i in this.options = {}, this.el.resize.defaults) this.options[i] = this.el.resize.defaults[i], void 0 !== t[i] && (this.options[i] = t[i]); this.el.on('lt.resize', ((t) => { e.resize(t || window.event); })), this.el.on('rt.resize', ((t) => { e.resize(t || window.event); })), this.el.on('rb.resize', ((t) => { e.resize(t || window.event); })), this.el.on('lb.resize', ((t) => { e.resize(t || window.event); })), this.el.on('t.resize', ((t) => { e.resize(t || window.event); })), this.el.on('r.resize', ((t) => { e.resize(t || window.event); })), this.el.on('b.resize', ((t) => { e.resize(t || window.event); })), this.el.on('l.resize', ((t) => { e.resize(t || window.event); })), this.el.on('rot.resize', ((t) => { e.resize(t || window.event); })), this.el.on('point.resize', ((t) => { e.resize(t || window.event); })), this.update(); } }, t.prototype.stop = function () { return this.el.off('lt.resize'), this.el.off('rt.resize'), this.el.off('rb.resize'), this.el.off('lb.resize'), this.el.off('t.resize'), this.el.off('r.resize'), this.el.off('b.resize'), this.el.off('l.resize'), this.el.off('rot.resize'), this.el.off('point.resize'), this; }, t.prototype.resize = function (t) {
      const e = this; this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset }; const i = this._extractPosition(t.detail.event); if (this.parameters = {
        type: this.el.type, p: this.transformPoint(i.x, i.y), x: t.detail.x, y: t.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation,
      }, this.el.type === 'text' && (this.parameters.fontSize = this.el.attr()['font-size']), void 0 !== t.detail.i) { const a = this.el.array().valueOf(); this.parameters.i = t.detail.i, this.parameters.pointCoords = [a[t.detail.i][0], a[t.detail.i][1]]; } switch (t.type) { case 'lt': this.calc = function (t, e) { let i = this.snapToGrid(t, e); if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height - i[1] > 0) { if (this.parameters.type === 'text') return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr('font-size', this.parameters.fontSize - i[0]); i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y + i[1]).size(this.parameters.box.width - i[0], this.parameters.box.height - i[1]); } }; break; case 'rt': this.calc = function (t, e) { let i = this.snapToGrid(t, e, 2); if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height - i[1] > 0) { if (this.parameters.type === 'text') return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr('font-size', this.parameters.fontSize + i[0]); i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).size(this.parameters.box.width + i[0], this.parameters.box.height - i[1]); } }; break; case 'rb': this.calc = function (t, e) { let i = this.snapToGrid(t, e, 0); if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height + i[1] > 0) { if (this.parameters.type === 'text') return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr('font-size', this.parameters.fontSize + i[0]); i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i[0], this.parameters.box.height + i[1]); } }; break; case 'lb': this.calc = function (t, e) { let i = this.snapToGrid(t, e, 1); if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height + i[1] > 0) { if (this.parameters.type === 'text') return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr('font-size', this.parameters.fontSize - i[0]); i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).size(this.parameters.box.width - i[0], this.parameters.box.height + i[1]); } }; break; case 't': this.calc = function (t, e) { const i = this.snapToGrid(t, e, 2); if (this.parameters.box.height - i[1] > 0) { if (this.parameters.type === 'text') return; this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).height(this.parameters.box.height - i[1]); } }; break; case 'r': this.calc = function (t, e) { const i = this.snapToGrid(t, e, 0); if (this.parameters.box.width + i[0] > 0) { if (this.parameters.type === 'text') return; this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i[0]); } }; break; case 'b': this.calc = function (t, e) { const i = this.snapToGrid(t, e, 0); if (this.parameters.box.height + i[1] > 0) { if (this.parameters.type === 'text') return; this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i[1]); } }; break; case 'l': this.calc = function (t, e) { const i = this.snapToGrid(t, e, 1); if (this.parameters.box.width - i[0] > 0) { if (this.parameters.type === 'text') return; this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).width(this.parameters.box.width - i[0]); } }; break; case 'rot': this.calc = function (t, e) { const i = t + this.parameters.p.x; const a = e + this.parameters.p.y; const s = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2); const r = Math.atan2(a - this.parameters.box.y - this.parameters.box.height / 2, i - this.parameters.box.x - this.parameters.box.width / 2); const n = this.parameters.rotation + 180 * (r - s) / Math.PI + this.options.snapToAngle / 2; this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(n - n % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy); }; break; case 'point': this.calc = function (t, e) { const i = this.snapToGrid(t, e, this.parameters.pointCoords[0], this.parameters.pointCoords[1]); const a = this.el.array().valueOf(); a[this.parameters.i][0] = this.parameters.pointCoords[0] + i[0], a[this.parameters.i][1] = this.parameters.pointCoords[1] + i[1], this.el.plot(a); }; } this.el.fire('resizestart', { dx: this.parameters.x, dy: this.parameters.y, event: t }), SVG.on(window, 'touchmove.resize', ((t) => { e.update(t || window.event); })), SVG.on(window, 'touchend.resize', (() => { e.done(); })), SVG.on(window, 'mousemove.resize', ((t) => { e.update(t || window.event); })), SVG.on(window, 'mouseup.resize', (() => { e.done(); }));
    }, t.prototype.update = function (t) { if (t) { const e = this._extractPosition(t); const i = this.transformPoint(e.x, e.y); const a = i.x - this.parameters.p.x; const s = i.y - this.parameters.p.y; this.lastUpdateCall = [a, s], this.calc(a, s), this.el.fire('resizing', { dx: a, dy: s, event: t }); } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]); }, t.prototype.done = function () { this.lastUpdateCall = null, SVG.off(window, 'mousemove.resize'), SVG.off(window, 'mouseup.resize'), SVG.off(window, 'touchmove.resize'), SVG.off(window, 'touchend.resize'), this.el.fire('resizedone'); }, t.prototype.snapToGrid = function (t, e, i, a) { let s; return void 0 !== a ? s = [(i + t) % this.options.snapToGrid, (a + e) % this.options.snapToGrid] : (i = i == null ? 3 : i, s = [(this.parameters.box.x + t + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t < 0 && (s[0] -= this.options.snapToGrid), e < 0 && (s[1] -= this.options.snapToGrid), t -= Math.abs(s[0]) < this.options.snapToGrid / 2 ? s[0] : s[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e -= Math.abs(s[1]) < this.options.snapToGrid / 2 ? s[1] : s[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, e, i, a); }, t.prototype.constraintToBox = function (t, e, i, a) { let s; let r; const n = this.options.constraint || {}; return void 0 !== a ? (s = i, r = a) : (s = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), r = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), void 0 !== n.minX && s + t < n.minX && (t = n.minX - s), void 0 !== n.maxX && s + t > n.maxX && (t = n.maxX - s), void 0 !== n.minY && r + e < n.minY && (e = n.minY - r), void 0 !== n.maxY && r + e > n.maxY && (e = n.maxY - r), [t, e]; }, t.prototype.checkAspectRatio = function (t, e) { if (!this.options.saveAspectRatio) return t; const i = t.slice(); const a = this.parameters.box.width / this.parameters.box.height; const s = this.parameters.box.width + t[0]; const r = this.parameters.box.height - t[1]; const n = s / r; return n < a ? (i[1] = s / a - this.parameters.box.height, e && (i[1] = -i[1])) : n > a && (i[0] = this.parameters.box.width - r * a, e && (i[0] = -i[0])), i; }, SVG.extend(SVG.Element, { resize(e) { return (this.remember('_resizeHandler') || new t(this)).init(e || {}), this; } }), SVG.Element.prototype.resize.defaults = {
      snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: !1,
    };
  }).call(this);
}()); const css = '.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5);\n}\n.apexcharts-canvas.apexcharts-theme-dark {\n  background: #343F57;\n}\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-gridline, .apexcharts-text {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30,30,30, 0.8);\n}\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n.apexcharts-tooltip-series-group.apexcharts-active, .apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n.apexcharts-tooltip-candlestick {\n  padding: 4px 8px;\n}\n.apexcharts-tooltip-candlestick > div {\n  margin: 4px 0;\n}\n.apexcharts-tooltip-candlestick span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after, .apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after, .apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after, .apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color:#ECEFF1\n}\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color:rgba(0, 0, 0, 0.5);\n}\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after, .apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after, .apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after, .apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs, .apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active, .apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-zoom-rect {\n  pointer-events: none;\n}\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_points, .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n.svg_select_points_l, .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n  fill: #888;\n}\n.apexcharts-canvas.apexcharts-zoomable .hovering-zoom {\n  cursor: crosshair\n}\n.apexcharts-canvas.apexcharts-zoomable .hovering-pan {\n  cursor: move\n}\n\n.apexcharts-xaxis,\n.apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoom-in-icon,\n.apexcharts-zoom-out-icon,\n.apexcharts-reset-zoom-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoom-in-icon svg,\n.apexcharts-zoom-out-icon svg,\n.apexcharts-reset-zoom-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-in-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-out-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg{\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-in-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoom-out-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-zoom-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon, .apexcharts-menu-icon {\n  position: relative;\n}\n.apexcharts-reset-zoom-icon {\n  margin-left: 5px;\n}\n.apexcharts-zoom-icon, .apexcharts-reset-zoom-icon, .apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoom-in-icon, .apexcharts-zoom-out-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoom-out-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  top: 0px;\n  right: 3px;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-toolbar svg {\n  pointer-events: none;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-toolbar {\n    /*opacity: 0;*/\n  }\n\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels, .apexcharts-datalabel, .apexcharts-datalabel-label, .apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events, .apexcharts-radar-series path, .apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n/* Resize generated styles */\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers, .resize-triggers > div, .contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers > div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}\n'; styleInject(css), (function () { function t(t) { const e = t.__resizeTriggers__; const i = e.firstElementChild; const a = e.lastElementChild; const s = i.firstElementChild; a.scrollLeft = a.scrollWidth, a.scrollTop = a.scrollHeight, s.style.width = `${i.offsetWidth + 1}px`, s.style.height = `${i.offsetHeight + 1}px`, i.scrollLeft = i.scrollWidth, i.scrollTop = i.scrollHeight; } function e(e) { const i = this; t(this), this.__resizeRAF__ && r(this.__resizeRAF__), this.__resizeRAF__ = s((() => { (function (t) { return t.offsetWidth != t.__resizeLast__.width || t.offsetHeight != t.__resizeLast__.height; }(i)) && (i.__resizeLast__.width = i.offsetWidth, i.__resizeLast__.height = i.offsetHeight, i.__resizeListeners__.forEach(((t) => { t.call(e); }))); })); } let i; let a; var s = (i = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (t) { return window.setTimeout(t, 20); }, function (t) { return i(t); }); var r = (a = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout, function (t) { return a(t); }); let n = !1; let o = 'animationstart'; const l = 'Webkit Moz O ms'.split(' '); const h = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '); const c = document.createElement('fakeelement'); if (void 0 !== c.style.animationName && (n = !0), !1 === n) for (let d = 0; d < l.length; d++) if (void 0 !== c.style[`${l[d]}AnimationName`]) { o = h[d]; break; }window.addResizeListener = function (i, a) { i.__resizeTriggers__ || (getComputedStyle(i).position == 'static' && (i.style.position = 'relative'), i.__resizeLast__ = {}, i.__resizeListeners__ = [], (i.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers', i.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', i.appendChild(i.__resizeTriggers__), t(i), i.addEventListener('scroll', e, !0), o && i.__resizeTriggers__.addEventListener(o, ((e) => { e.animationName == 'resizeanim' && t(i); }))), i.__resizeListeners__.push(a); }, window.removeResizeListener = function (t, i) { t && (t.__resizeListeners__.splice(t.__resizeListeners__.indexOf(i), 1), t.__resizeListeners__.length || (t.removeEventListener('scroll', e), t.__resizeTriggers__ = !t.removeChild(t.__resizeTriggers__))); }; }()), window.Apex = {}; const InitCtxVariables = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'initModules', value() { this.ctx.publicMethods = ['updateOptions', 'updateSeries', 'appendData', 'appendSeries', 'toggleSeries', 'showSeries', 'hideSeries', 'setLocale', 'resetSeries', 'toggleDataPointSelection', 'dataURI', 'addXaxisAnnotation', 'addYaxisAnnotation', 'addPointAnnotation', 'addText', 'clearAnnotations', 'removeAnnotation', 'paper', 'destroy'], this.ctx.eventList = ['click', 'mousedown', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'], this.ctx.animations = new Animations(this.ctx), this.ctx.axes = new Axes(this.ctx), this.ctx.core = new Core(this.ctx.el, this.ctx), this.ctx.data = new Data(this.ctx), this.ctx.grid = new Grid(this.ctx), this.ctx.coreUtils = new CoreUtils(this.ctx), this.ctx.crosshairs = new Crosshairs(this.ctx), this.ctx.events = new Events(this.ctx), this.ctx.localization = new Localization(this.ctx), this.ctx.options = new Options(), this.ctx.responsive = new Responsive(this.ctx), this.ctx.series = new Series(this.ctx), this.ctx.theme = new Theme(this.ctx), this.ctx.formatters = new Formatters(this.ctx), this.ctx.titleSubtitle = new TitleSubtitle(this.ctx), this.ctx.legend = new Legend(this.ctx), this.ctx.toolbar = new Toolbar(this.ctx), this.ctx.dimensions = new Dimensions(this.ctx), this.ctx.updateHelpers = new UpdateHelpers(this.ctx), this.ctx.zoomPanSelection = new ZoomPanSelection(this.ctx), this.ctx.w.globals.tooltip = new Tooltip(this.ctx); } }]), t; }()); const Destroy = (function () { function t(e) { _classCallCheck(this, t), this.ctx = e, this.w = e.w; } return _createClass(t, [{ key: 'clear', value() { this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements(); } }, { key: 'killSVG', value(t) { return new Promise((((e, i) => { t.each((function (t, e) { this.removeClass('*'), this.off(), this.stop(); }), !0), t.ungroup(), t.clear(), e('done'); }))); } }, { key: 'clearDomElements', value() { const t = this; this.ctx.eventList.forEach(((e) => { document.removeEventListener(e, t.ctx.events.documentEvent); })); const e = this.w.globals.dom; if (this.ctx.el !== null) for (;this.ctx.el.firstChild;) this.ctx.el.removeChild(this.ctx.el.firstChild); this.killSVG(e.Paper), e.Paper.remove(), e.elWrap = null, e.elGraphical = null, e.elLegendWrap = null, e.baseEl = null, e.elGridRect = null, e.elGridRectMask = null, e.elGridRectMarkerMask = null, e.elDefs = null; } }]), t; }()); const ApexCharts$1 = (function () {
  function t(e, i) { _classCallCheck(this, t), this.opts = i, this.ctx = this, this.w = new Base(i).init(), this.el = e, this.w.globals.cuid = Utils.randomId(), this.w.globals.chartID = this.w.config.chart.id ? this.w.config.chart.id : this.w.globals.cuid, new InitCtxVariables(this).initModules(), this.create = Utils.bind(this.create, this), this.windowResizeHandler = this._windowResize.bind(this); } return _createClass(t, [{ key: 'render', value() { const t = this; return new Promise((((e, i) => { if (t.el !== null) { void 0 === Apex._chartInstances && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({ id: t.w.globals.chartID, group: t.w.config.chart.group, chart: t }), t.setLocale(t.w.config.chart.defaultLocale); const a = t.w.config.chart.events.beforeMount; typeof a === 'function' && a(t, t.w), t.events.fireEvent('beforeMount', [t, t.w]), window.addEventListener('resize', t.windowResizeHandler), window.addResizeListener(t.el.parentNode, t._parentResizeCallback.bind(t)); const s = t.create(t.w.config.series, {}); if (!s) return e(t); t.mount(s).then((() => { typeof t.w.config.chart.events.mounted === 'function' && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent('mounted', [t, t.w]), e(s); })).catch(((t) => { i(t); })); } else i(new Error('Element not found')); }))); } }, {
    key: 'create',
    value(t, e) {
      const i = this.w; new InitCtxVariables(this).initModules(); const a = this.w.globals; (a.noData = !1, a.animationEnded = !1, this.responsive.checkResponsiveConfig(e), i.config.xaxis.convertedCatToNumeric) && new Defaults(i.config).convertCatToNumericXaxis(i.config, this.ctx); if (this.el === null) return a.animationEnded = !0, null; if (this.core.setupElements(), a.svgWidth === 0) return a.animationEnded = !0, null; const s = CoreUtils.checkComboSeries(t); a.comboCharts = s.comboCharts, a.comboBarCount = s.comboBarCount, (t.length === 0 || t.length === 1 && t[0].data && t[0].data.length === 0) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new Markers(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a.noData && a.collapsedSeries.length !== a.series.length || this.legend.init(), this.series.hasAllSeriesEqualX(), a.axisCharts && (this.core.coreCalculations(), i.config.xaxis.type !== 'category' && this.formatters.setLabelFormatters()), this.formatters.heatmapLabelFormatters(), this.dimensions.plotCoords(); const r = this.core.xySettings(); this.grid.createGridMask(); const n = this.core.plotChartType(t, r); const o = new DataLabels(this); o.bringForward(), i.config.dataLabels.background.enabled && o.dataLabelsBackground(), this.core.shiftGraphPosition(); const l = {
        plot: {
          left: i.globals.translateX, top: i.globals.translateY, width: i.globals.gridWidth, height: i.globals.gridHeight,
        },
      }; return {
        elGraph: n, xyRatios: r, elInner: i.globals.dom.elGraphical, dimensions: l,
      };
    },
  }, { key: 'mount', value() { const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; const i = this; const a = i.w; return new Promise((((s, r) => { if (i.el === null) return r(new Error('Not enough data to display or target element not found')); (e === null || a.globals.allSeriesCollapsed) && i.series.handleNoData(), i.axes.drawAxis(a.config.chart.type, e.xyRatios), i.grid = new Grid(i); let n = null; a.config.grid.position === 'back' && (n = i.grid.drawGrid()); const o = new XAxis(t.ctx); const l = new YAxis(t.ctx); if (n !== null && (o.xAxisLabelCorrections(n.xAxisTickWidth), l.setYAxisTextAlignments()), i.annotations = new Annotations(i), a.config.annotations.position === 'back' && i.annotations.drawAnnotations(), e.elGraph instanceof Array) for (let h = 0; h < e.elGraph.length; h++)a.globals.dom.elGraphical.add(e.elGraph[h]); else a.globals.dom.elGraphical.add(e.elGraph); if (a.config.grid.position === 'front' && i.grid.drawGrid(), a.config.xaxis.crosshairs.position === 'front' && i.crosshairs.drawXCrosshairs(), a.config.yaxis[0].crosshairs.position === 'front' && i.crosshairs.drawYCrosshairs(), a.config.annotations.position === 'front' && i.annotations.drawAnnotations(), !a.globals.noData) { if (a.config.tooltip.enabled && !a.globals.noData && i.w.globals.tooltip.drawTooltip(e.xyRatios), a.globals.axisCharts && (a.globals.isXNumeric || a.config.xaxis.convertedCatToNumeric))(a.config.chart.zoom.enabled || a.config.chart.selection && a.config.chart.selection.enabled || a.config.chart.pan && a.config.chart.pan.enabled) && i.zoomPanSelection.init({ xyRatios: e.xyRatios }); else { const c = a.config.chart.toolbar.tools; ['zoom', 'zoomin', 'zoomout', 'selection', 'pan', 'reset'].forEach(((t) => { c[t] = !1; })); }a.config.chart.toolbar.show && !a.globals.allSeriesCollapsed && i.toolbar.createToolbar(); }a.globals.memory.methodsToExec.length > 0 && a.globals.memory.methodsToExec.forEach(((t) => { t.method(t.params, !1, t.context); })), a.globals.axisCharts || a.globals.noData || i.core.resizeNonAxisCharts(), s(i); }))); } }, { key: 'destroy', value() { window.removeEventListener('resize', this.windowResizeHandler), window.removeResizeListener(this.el.parentNode, this._parentResizeCallback.bind(this)); const t = this.w.config.chart.id; t && Apex._chartInstances.forEach(((e, i) => { e.id === t && Apex._chartInstances.splice(i, 1); })), new Destroy(this.ctx).clear(); } }, { key: 'updateOptions', value(t) { const e = this; const i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; const r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]; const n = this.w; return t.series && (this.series.resetSeries(!1), t.series.length && t.series[0].data && (t.series = t.series.map(((t, i) => e.updateHelpers._extendSeries(t, i)))), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), n.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, i, a, s, r); } }, { key: 'updateSeries', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, e, i); } }, { key: 'appendSeries', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const a = this.w.config.series.slice(); return a.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a, e, i); } }, { key: 'appendData', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = this; i.w.globals.dataChanged = !0, i.series.getPreviousPaths(); for (var a = i.w.config.series.slice(), s = 0; s < a.length; s++) if (void 0 !== t[s]) for (let r = 0; r < t[s].data.length; r++)a[s].data.push(t[s].data[r]); return i.w.config.series = a, e && (i.w.globals.initialSeries = JSON.parse(JSON.stringify(i.w.config.series))), this.update(); } }, { key: 'update', value(t) { const e = this; return new Promise((((i, a) => { new Destroy(e.ctx).clear(); const s = e.create(e.w.config.series, t); if (!s) return i(e); e.mount(s).then((() => { typeof e.w.config.chart.events.updated === 'function' && e.w.config.chart.events.updated(e, e.w), e.events.fireEvent('updated', [e, e.w]), e.w.globals.isDirty = !0, i(e); })).catch(((t) => { a(t); })); }))); } }, { key: 'getSyncedCharts', value() { const t = this.getGroupedCharts(); let e = [this]; return t.length && (e = [], t.forEach(((t) => { e.push(t); }))), e; } }, { key: 'getGroupedCharts', value() { const t = this; return Apex._chartInstances.filter(((t) => { if (t.group) return !0; })).map(((e) => (t.w.config.chart.group === e.group ? e.chart : t))); } }, { key: 'toggleSeries', value(t) { return this.series.toggleSeries(t); } }, { key: 'showSeries', value(t) { this.series.showSeries(t); } }, { key: 'hideSeries', value(t) { this.series.hideSeries(t); } }, { key: 'resetSeries', value() { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; this.series.resetSeries(t); } }, { key: 'addXaxisAnnotation', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; let a = this; i && (a = i), a.annotations.addXaxisAnnotationExternal(t, e, a); } }, { key: 'addYaxisAnnotation', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; let a = this; i && (a = i), a.annotations.addYaxisAnnotationExternal(t, e, a); } }, { key: 'addPointAnnotation', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; let a = this; i && (a = i), a.annotations.addPointAnnotationExternal(t, e, a); } }, { key: 'clearAnnotations', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0; let e = this; t && (e = t), e.annotations.clearAnnotations(e); } }, { key: 'removeAnnotation', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0; let i = this; e && (i = e), i.annotations.removeAnnotation(i, t); } }, { key: 'addText', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; let a = this; i && (a = i), a.annotations.addText(t, e, a); } }, { key: 'getChartArea', value() { return this.w.globals.dom.baseEl.querySelector('.apexcharts-inner'); } }, { key: 'getSeriesTotalXRange', value(t, e) { return this.coreUtils.getSeriesTotalsXRange(t, e); } }, { key: 'getHighestValueInSeries', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = new Range$1(this.ctx); return e.getMinYMaxY(t).highestY; } }, { key: 'getLowestValueInSeries', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = new Range$1(this.ctx); return e.getMinYMaxY(t).lowestY; } }, { key: 'getSeriesTotal', value() { return this.w.globals.seriesTotals; } }, { key: 'toggleDataPointSelection', value(t, e) { return this.updateHelpers.toggleDataPointSelection(t, e); } }, { key: 'setLocale', value(t) { this.localization.setCurrentLocaleValues(t); } }, { key: 'dataURI', value() { return new Exports(this.ctx).dataURI(); } }, { key: 'paper', value() { return this.w.globals.dom.Paper; } }, { key: '_parentResizeCallback', value() { this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize(); } }, { key: '_windowResize', value() { const t = this; clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout((() => { t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update(); }), 150); } }], [{ key: 'getChartByID', value(t) { return Apex._chartInstances.filter(((e) => e.id === t))[0].chart; } }, { key: 'initOnLoad', value() { for (let e = document.querySelectorAll('[data-apexcharts]'), i = 0; i < e.length; i++) { new t(e[i], JSON.parse(e[i].getAttribute('data-options'))).render(); } } }, { key: 'exec', value(t, e) { const i = this.getChartByID(t); if (i) { i.w.globals.isExecCalled = !0; let a = null; if (i.publicMethods.indexOf(e) !== -1) { for (var s = arguments.length, r = new Array(s > 2 ? s - 2 : 0), n = 2; n < s; n++)r[n - 2] = arguments[n]; a = i[e].apply(i, r); } return a; } } }, { key: 'merge', value(t, e) { return Utils.extend(t, e); } }]), t;
}()); module.exports = ApexCharts$1;
