/*!
 * ApexCharts v3.15.6
 * (c) 2018-2020 Juned Chhipa
 * Released under the MIT License.
 */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = e() : typeof define === 'function' && define.amd ? define(e) : (t = t || self).ApexCharts = e(); }(this, (() => {
  function t(e) { return (t = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t; })(e); } function e(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function'); } function i(t, e) { for (let i = 0; i < e.length; i++) { const a = e[i]; a.enumerable = a.enumerable || !1, a.configurable = !0, 'value' in a && (a.writable = !0), Object.defineProperty(t, a.key, a); } } function a(t, e, a) { return e && i(t.prototype, e), a && i(t, a), t; } function s(t, e, i) {
    return e in t ? Object.defineProperty(t, e, {
      value: i, enumerable: !0, configurable: !0, writable: !0,
    }) : t[e] = i, t;
  } function r(t, e) { const i = Object.keys(t); if (Object.getOwnPropertySymbols) { let a = Object.getOwnPropertySymbols(t); e && (a = a.filter(((e) => Object.getOwnPropertyDescriptor(t, e).enumerable))), i.push.apply(i, a); } return i; } function n(t) { for (let e = 1; e < arguments.length; e++) { var i = arguments[e] != null ? arguments[e] : {}; e % 2 ? r(Object(i), !0).forEach(((e) => { s(t, e, i[e]); })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : r(Object(i)).forEach(((e) => { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e)); })); } return t; } function o(t, e) { if (typeof e !== 'function' && e !== null) throw new TypeError('Super expression must either be null or a function'); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && h(t, e); } function l(t) { return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t); })(t); } function h(t, e) { return (h = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t; })(t, e); } function c(t, e) { return !e || typeof e !== 'object' && typeof e !== 'function' ? (function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; }(t)) : e; } function d(t) { return (function (t) { if (Array.isArray(t)) { for (var e = 0, i = new Array(t.length); e < t.length; e++)i[e] = t[e]; return i; } }(t)) || (function (t) { if (Symbol.iterator in Object(t) || Object.prototype.toString.call(t) === '[object Arguments]') return Array.from(t); }(t)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance'); }()); } const g = (function () {
    function i() { e(this, i); } return a(i, [{ key: 'shadeRGBColor', value(t, e) { const i = e.split(','); const a = t < 0 ? 0 : 255; const s = t < 0 ? -1 * t : t; const r = parseInt(i[0].slice(4), 10); const n = parseInt(i[1], 10); const o = parseInt(i[2], 10); return `rgb(${Math.round((a - r) * s) + r},${Math.round((a - n) * s) + n},${Math.round((a - o) * s) + o})`; } }, { key: 'shadeHexColor', value(t, e) { t < 0 && (t = 0); const i = parseInt(e.slice(1), 16); const a = t < 0 ? 0 : 255; const s = t < 0 ? -1 * t : t; const r = i >> 16; const n = i >> 8 & 255; const o = 255 & i; return `#${(16777216 + 65536 * (Math.round((a - r) * s) + r) + 256 * (Math.round((a - n) * s) + n) + (Math.round((a - o) * s) + o)).toString(16).slice(1)}`; } }, { key: 'shadeColor', value(t, e) { return e.length > 7 ? this.shadeRGBColor(t, e) : this.shadeHexColor(t, e); } }], [{ key: 'bind', value(t, e) { return function () { return t.apply(e, arguments); }; } }, { key: 'isObject', value(e) { return e && t(e) === 'object' && !Array.isArray(e) && e != null; } }, { key: 'listToArray', value(t) { let e; const i = []; for (e = 0; e < t.length; e++)i[e] = t[e]; return i; } }, { key: 'extend', value(t, e) { const i = this; typeof Object.assign !== 'function' && (Object.assign = function (t) { if (t == null) throw new TypeError('Cannot convert undefined or null to object'); for (var e = Object(t), i = 1; i < arguments.length; i++) { const a = arguments[i]; if (a != null) for (const s in a)a.hasOwnProperty(s) && (e[s] = a[s]); } return e; }); const a = { ...t }; return this.isObject(t) && this.isObject(e) && Object.keys(e).forEach(((r) => { i.isObject(e[r]) && r in t ? a[r] = i.extend(t[r], e[r]) : Object.assign(a, s({}, r, e[r])); })), a; } }, { key: 'extendArray', value(t, e) { const a = []; return t.map(((t) => { a.push(i.extend(e, t)); })), t = a; } }, { key: 'monthMod', value(t) { return t % 12; } }, { key: 'clone', value(e) { if (Object.prototype.toString.call(e) === '[object Array]') { for (var i = [], a = 0; a < e.length; a++)i[a] = this.clone(e[a]); return i; } if (t(e) === 'object') { const s = {}; for (const r in e)e.hasOwnProperty(r) && (s[r] = this.clone(e[r])); return s; } return e; } }, { key: 'log10', value(t) { return Math.log(t) / Math.LN10; } }, { key: 'roundToBase10', value(t) { return Math.pow(10, Math.floor(Math.log10(t))); } }, { key: 'roundToBase', value(t, e) { return Math.pow(e, Math.floor(Math.log(t) / Math.log(e))); } }, { key: 'parseNumber', value(t) { return t === null ? t : parseFloat(t); } }, { key: 'randomId', value() { return (new Date() % 9e6).toString(16); } }, { key: 'noExponents', value(t) { const e = String(t).split(/[eE]/); if (e.length === 1) return e[0]; let i = ''; const a = t < 0 ? '-' : ''; const s = e[0].replace('.', ''); let r = Number(e[1]) + 1; if (r < 0) { for (i = `${a}0.`; r++;)i += '0'; return i + s.replace(/^-/, ''); } for (r -= s.length; r--;)i += '0'; return s + i; } }, { key: 'getDimensions', value(t) { const e = getComputedStyle(t); const i = []; let a = t.clientHeight; let s = t.clientWidth; return a -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), s -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), i.push(s), i.push(a), i; } }, {
      key: 'getBoundingClientRect',
      value(t) {
        const e = t.getBoundingClientRect(); return {
          top: e.top, right: e.right, bottom: e.bottom, left: e.left, width: e.width, height: e.height, x: e.x, y: e.y,
        };
      },
    }, { key: 'getLargestStringFromArr', value(t) { return t.reduce(((t, e) => (Array.isArray(e) && (e = e.reduce(((t, e) => (t.length > e.length ? t:e)))), t.length > e.length ? t : e)), 0); } }, {
      key: 'hexToRgba',
      value() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : '#999999'; const
          e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6; t.substring(0, 1) !== '#' && (t = '#999999'); let i = t.replace('#', ''); i = i.match(new RegExp(`(.{${i.length / 3}})`, 'g')); for (let a = 0; a < i.length; a++)i[a] = parseInt(i[a].length === 1 ? i[a] + i[a] : i[a], 16); return void 0 !== e && i.push(e), `rgba(${i.join(',')})`;
      },
    }, { key: 'getOpacityFromRGBA', value(t) { return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i))[3]; } }, { key: 'rgb2hex', value(t) { return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && t.length === 4 ? `#${(`0${parseInt(t[1], 10).toString(16)}`).slice(-2)}${(`0${parseInt(t[2], 10).toString(16)}`).slice(-2)}${(`0${parseInt(t[3], 10).toString(16)}`).slice(-2)}` : ''; } }, { key: 'isColorHex', value(t) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t); } }, { key: 'polarToCartesian', value(t, e, i, a) { const s = (a - 90) * Math.PI / 180; return { x: t + i * Math.cos(s), y: e + i * Math.sin(s) }; } }, {
      key: 'escapeString',
      value(t) {
        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'x'; let
          i = t.toString().slice(); return i = i.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, e);
      },
    }, { key: 'negToZero', value(t) { return t < 0 ? 0 : t; } }, { key: 'moveIndexInArray', value(t, e, i) { if (i >= t.length) for (let a = i - t.length + 1; a--;)t.push(void 0); return t.splice(i, 0, t.splice(e, 1)[0]), t; } }, { key: 'extractNumber', value(t) { return parseFloat(t.replace(/[^\d.]*/g, '')); } }, { key: 'findAncestor', value(t, e) { for (;(t = t.parentElement) && !t.classList.contains(e););return t; } }, { key: 'setELstyles', value(t, e) { for (const i in e)e.hasOwnProperty(i) && (t.style.key = e[i]); } }, { key: 'isNumber', value(t) { return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10)); } }, { key: 'isFloat', value(t) { return Number(t) === t && t % 1 != 0; } }, { key: 'isSafari', value() { return /^((?!chrome|android).)*safari/i.test(navigator.userAgent); } }, { key: 'isFirefox', value() { return navigator.userAgent.toLowerCase().indexOf('firefox') > -1; } }, { key: 'isIE11', value() { if (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.appVersion.indexOf('Trident/') > -1) return !0; } }, { key: 'isIE', value() { const t = window.navigator.userAgent; const e = t.indexOf('MSIE '); if (e > 0) return parseInt(t.substring(e + 5, t.indexOf('.', e)), 10); if (t.indexOf('Trident/') > 0) { const i = t.indexOf('rv:'); return parseInt(t.substring(i + 3, t.indexOf('.', i)), 10); } const a = t.indexOf('Edge/'); return a > 0 && parseInt(t.substring(a + 5, t.indexOf('.', a)), 10); } }]), i;
  }()); const u = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'getDefaultFilter', value(t, e) { const i = this.w; t.unfilter(!0), (new window.SVG.Filter()).size('120%', '180%', '-5%', '-40%'), i.config.states.normal.filter !== 'none' ? this.applyFilter(t, e, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e); } }, { key: 'addNormalFilter', value(t, e) { const i = this.w; i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e); } }, { key: 'addLightenFilter', value(t, e, i) { const a = this; const s = this.w; const r = i.intensity; if (!g.isFirefox()) { t.unfilter(!0); new window.SVG.Filter(); t.filter(((t) => { const i = s.config.chart.dropShadow; (i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({ rgb: { type: 'linear', slope: 1.5, intercept: r } }); })), t.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse'), this._scaleFilterSize(t.filterer.node); } } }, { key: 'addDarkenFilter', value(t, e, i) { const a = this; const s = this.w; const r = i.intensity; if (!g.isFirefox()) { t.unfilter(!0); new window.SVG.Filter(); t.filter(((t) => { const i = s.config.chart.dropShadow; (i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({ rgb: { type: 'linear', slope: r } }); })), t.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse'), this._scaleFilterSize(t.filterer.node); } } }, { key: 'applyFilter', value(t, e, i) { const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5; switch (i) { case 'none': this.addNormalFilter(t, e); break; case 'lighten': this.addLightenFilter(t, e, { intensity: a }); break; case 'darken': this.addDarkenFilter(t, e, { intensity: a }); } } }, {
      key: 'addShadow',
      value(t, e, i) {
        const a = i.blur; const s = i.top; const r = i.left; const n = i.color; const o = i.opacity; const l = t.flood(Array.isArray(n) ? n[e] : n, o).composite(t.sourceAlpha, 'in').offset(r, s).gaussianBlur(a)
          .merge(t.source); return t.blend(t.source, l);
      },
    }, {
      key: 'dropShadow',
      value(t, e) {
        const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const a = e.top; const s = e.left; const r = e.blur; let n = e.color; const o = e.opacity; const l = e.noUserSpaceOnUse; const h = this.w; return t.unfilter(!0), g.isIE() && h.config.chart.type === 'radialBar' ? t : (n = Array.isArray(n) ? n[i] : n, t.filter(((t) => {
          let e = null; e = g.isSafari() || g.isFirefox() || g.isIE() ? t.flood(n, o).composite(t.sourceAlpha, 'in').offset(s, a).gaussianBlur(r) : t.flood(n, o).composite(t.sourceAlpha, 'in').offset(s, a).gaussianBlur(r)
            .merge(t.source), t.blend(t.source, e);
        })), l || t.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse'), this._scaleFilterSize(t.filterer.node), t);
      },
    }, { key: 'setSelectionFilter', value(t, e, i) { const a = this.w; if (void 0 !== a.globals.selectedDataPoints[e] && a.globals.selectedDataPoints[e].indexOf(i) > -1) { t.node.setAttribute('selected', !0); const s = a.config.states.active.filter; s !== 'none' && this.applyFilter(t, e, s.type, s.value); } } }, {
      key: '_scaleFilterSize',
      value(t) {
        !(function (e) { for (const i in e)e.hasOwnProperty(i) && t.setAttribute(i, e[i]); }({
          width: '200%', height: '200%', x: '-50%', y: '-50%',
        }));
      }, 
    }]), t;
  }()); const f = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.setEasingFunctions(); } return a(t, [{ key: 'setEasingFunctions', value() { let t; if (!this.w.globals.easing) { switch (this.w.config.chart.animations.easing) { case 'linear': t = '-'; break; case 'easein': t = '<'; break; case 'easeout': t = '>'; break; case 'easeinout': t = '<>'; break; case 'swing': t = function (t) { const e = 1.70158; return (t -= 1) * t * ((e + 1) * t + e) + 1; }; break; case 'bounce': t = function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }; break; case 'elastic': t = function (t) { return t === !!t ? t : Math.pow(2, -10 * t) * Math.sin((t - 0.075) * (2 * Math.PI) / 0.3) + 1; }; break; default: t = '<>'; } this.w.globals.easing = t; } } }, { key: 'animateLine', value(t, e, i, a) { t.attr(e).animate(a).attr(i); } }, { key: 'animateCircleRadius', value(t, e, i, a, s, r) { e || (e = 0), t.attr({ r: e }).animate(a, s).attr({ r: i }).afterAll((() => { r(); })); } }, { key: 'animateCircle', value(t, e, i, a, s) { t.attr({ r: e.r, cx: e.cx, cy: e.cy }).animate(a, s).attr({ r: i.r, cx: i.cx, cy: i.cy }); } }, { key: 'animateRect', value(t, e, i, a, s) { t.attr(e).animate(a).attr(i).afterAll((() => s())); } }, { key: 'animatePathsGradually', value(t) { const e = t.el; const i = t.realIndex; const a = t.j; const s = t.fill; const r = t.pathFrom; const n = t.pathTo; const o = t.speed; const l = t.delay; const h = this.w; let c = 0; h.config.chart.animations.animateGradually.enabled && (c = h.config.chart.animations.animateGradually.delay), h.config.chart.animations.dynamicAnimation.enabled && h.globals.dataChanged && h.config.chart.type !== 'bar' && (c = 0), this.morphSVG(e, i, a, h.config.chart.type !== 'line' || h.globals.comboCharts ? s : 'stroke', r, n, o, l * c); } }, { key: 'showDelayedElements', value() { this.w.globals.delayedElements.forEach(((t) => { t.el.classList.remove('apexcharts-element-hidden'); })); } }, { key: 'animationCompleted', value(t) { const e = this.w; e.globals.animationEnded || (e.globals.animationEnded = !0, typeof e.config.chart.events.animationEnd === 'function' && e.config.chart.events.animationEnd(this.ctx, { el: t, w: e })); } }, {
      key: 'morphSVG',
      value(t, e, i, a, s, r, n, o) {
        const l = this; const h = this.w; s || (s = t.attr('pathFrom')), r || (r = t.attr('pathTo')), (!s || s.indexOf('undefined') > -1 || s.indexOf('NaN') > -1) && (s = 'M 0 '.concat(h.globals.gridHeight)), (r.indexOf('undefined') > -1 || r.indexOf('NaN') > -1) && (r = 'M 0 '.concat(h.globals.gridHeight)), h.globals.shouldAnimate || (n = 1), t.plot(s).animate(1, h.globals.easing, o).plot(s).animate(n, h.globals.easing, o)
          .plot(r)
          .afterAll((() => { g.isNumber(i) ? i === h.globals.series[h.globals.maxValsInArrayIndex].length - 2 && h.globals.shouldAnimate && l.animationCompleted(t) : a !== 'none' && h.globals.shouldAnimate && (!h.globals.comboCharts && e === h.globals.series.length - 1 || h.globals.comboCharts) && l.animationCompleted(t), l.showDelayedElements(); }));
      },
    }]), t;
  }()); const p = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{
      key: 'drawLine',
      value(t, e, i, a) {
        const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : '#a8a8a8'; const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; const n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null; const o = this.w; const
          l = o.globals.dom.Paper.line().attr({
            x1: t, y1: e, x2: i, y2: a, stroke: s, 'stroke-dasharray': r, 'stroke-width': n,
          }); return l;
      },
    }, {
      key: 'drawRect',
      value() {
        const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0; const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0; const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : '#fefefe'; const n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1; const o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null; const l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null; const h = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0; const c = this.w; const d = c.globals.dom.Paper.rect(); return d.attr({
          x: t, y: e, width: i > 0 ? i : 0, height: a > 0 ? a : 0, rx: s, ry: s, fill: r, opacity: n, 'stroke-width': o !== null ? o : 0, stroke: l !== null ? l : 'none', 'stroke-dasharray': h,
        }), d;
      },
    }, {
      key: 'drawPolygon',
      value(t) {
        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '#e1e1e1'; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'none'; const a = this.w; const
          s = a.globals.dom.Paper.polygon(t).attr({ fill: i, stroke: e }); return s;
      },
    }, { key: 'drawCircle', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const i = this.w; const a = i.globals.dom.Paper.circle(2 * t); return e !== null && a.attr(e), a; } }, {
      key: 'drawPath',
      value(t) {
        const e = t.d; let i = void 0 === e ? '' : e; const a = t.stroke; const s = void 0 === a ? '#a8a8a8' : a; const r = t.strokeWidth; const n = void 0 === r ? 1 : r; const o = t.fill; const l = t.fillOpacity; const h = void 0 === l ? 1 : l; const c = t.strokeOpacity; const d = void 0 === c ? 1 : c; const g = t.classes; const u = t.strokeLinecap; let f = void 0 === u ? null : u; const p = t.strokeDashArray; const x = void 0 === p ? 0 : p; const b = this.w; return f === null && (f = b.config.stroke.lineCap), (i.indexOf('undefined') > -1 || i.indexOf('NaN') > -1) && (i = 'M 0 '.concat(b.globals.gridHeight)), b.globals.dom.Paper.path(i).attr({
          fill: o, 'fill-opacity': h, stroke: s, 'stroke-opacity': d, 'stroke-linecap': f, 'stroke-width': n, 'stroke-dasharray': x, class: g,
        });
      },
    }, { key: 'group', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; const e = this.w; const i = e.globals.dom.Paper.group(); return t !== null && i.attr(t), i; } }, { key: 'move', value(t, e) { const i = ['M', t, e].join(' '); return i; } }, { key: 'line', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; let a = null; return i === null ? a = ['L', t, e].join(' ') : i === 'H' ? a = ['H', t].join(' ') : i === 'V' && (a = ['V', e].join(' ')), a; } }, { key: 'curve', value(t, e, i, a, s, r) { const n = ['C', t, e, i, a, s, r].join(' '); return n; } }, { key: 'quadraticCurve', value(t, e, i, a) { return ['Q', t, e, i, a].join(' '); } }, { key: 'arc', value(t, e, i, a, s, r, n) { const o = arguments.length > 7 && void 0 !== arguments[7] && arguments[7]; let l = 'A'; o && (l = 'a'); const h = [l, t, e, i, a, s, r, n].join(' '); return h; } }, {
      key: 'renderPaths',
      value(t) {
        let e; const i = t.j; const a = t.realIndex; const s = t.pathFrom; const r = t.pathTo; const o = t.stroke; const l = t.strokeWidth; const h = t.strokeLinecap; const c = t.fill; const d = t.animationDelay; const g = t.initialSpeed; const p = t.dataChangeSpeed; const x = t.className; const b = t.shouldClipToGrid; const m = void 0 === b || b; const v = t.bindEventsOnPaths; const y = void 0 === v || v; const w = t.drawShadow; const k = void 0 === w || w; const A = this.w; const S = new u(this.ctx); const C = new f(this.ctx); const L = this.w.config.chart.animations.enabled; const P = L && this.w.config.chart.animations.dynamicAnimation.enabled; const T = !!(L && !A.globals.resized || P && A.globals.dataChanged && A.globals.shouldAnimate); T ? e = s : (e = r, A.globals.animationEnded = !0); const z = A.config.stroke.dashArray; let I = 0; I = Array.isArray(z) ? z[a] : A.config.stroke.dashArray; const M = this.drawPath({
          d: e, stroke: o, strokeWidth: l, fill: c, fillOpacity: 1, classes: x, strokeLinecap: h, strokeDashArray: I,
        }); if (M.attr('index', a), m && M.attr({ 'clip-path': 'url(#gridRectMask'.concat(A.globals.cuid, ')') }), A.config.states.normal.filter.type !== 'none')S.getDefaultFilter(M, a); else if (A.config.chart.dropShadow.enabled && k && (!A.config.chart.dropShadow.enabledOnSeries || A.config.chart.dropShadow.enabledOnSeries && A.config.chart.dropShadow.enabledOnSeries.indexOf(a) !== -1)) { const X = A.config.chart.dropShadow; S.dropShadow(M, X, a); }y && (M.node.addEventListener('mouseenter', this.pathMouseEnter.bind(this, M)), M.node.addEventListener('mouseleave', this.pathMouseLeave.bind(this, M)), M.node.addEventListener('mousedown', this.pathMouseDown.bind(this, M))), M.attr({ pathTo: r, pathFrom: s }); const E = {
          el: M, j: i, realIndex: a, pathFrom: s, pathTo: r, fill: c, strokeWidth: l, delay: d,
        }; return !L || A.globals.resized || A.globals.dataChanged ? !A.globals.resized && A.globals.dataChanged || C.showDelayedElements() : C.animatePathsGradually(n({}, E, { speed: g })), A.globals.dataChanged && P && T && C.animatePathsGradually(n({}, E, { speed: p })), M;
      },
    }, {
      key: 'drawPattern',
      value(t, e, i) {
        const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : '#a8a8a8'; const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0; const r = this.w; const
          n = r.globals.dom.Paper.pattern(e, i, ((r) => { t === 'horizontalLines' ? r.line(0, 0, i, 0).stroke({ color: a, width: s + 1 }) : t === 'verticalLines' ? r.line(0, 0, 0, e).stroke({ color: a, width: s + 1 }) : t === 'slantedLines' ? r.line(0, 0, e, i).stroke({ color: a, width: s }) : t === 'squares' ? r.rect(e, i).fill('none').stroke({ color: a, width: s }) : t === 'circles' && r.circle(e).fill('none').stroke({ color: a, width: s }); })); return n;
      },
    }, {
      key: 'drawGradient',
      value(t, e, i, a, s) {
        let r; const n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null; const o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null; const l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null; const h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0; const c = this.w; e = g.hexToRgba(e, a), i = g.hexToRgba(i, s); let d = 0; let u = 1; let f = 1; let p = null; o !== null && (d = void 0 !== o[0] ? o[0] / 100 : 0, u = void 0 !== o[1] ? o[1] / 100 : 1, f = void 0 !== o[2] ? o[2] / 100 : 1, p = void 0 !== o[3] ? o[3] / 100 : null); const x = !(c.config.chart.type !== 'donut' && c.config.chart.type !== 'pie' && c.config.chart.type !== 'bubble'); if (r = l === null || l.length === 0 ? c.globals.dom.Paper.gradient(x ? 'radial' : 'linear', ((t) => { t.at(d, e, a), t.at(u, i, s), t.at(f, i, s), p !== null && t.at(p, e, a); })) : c.globals.dom.Paper.gradient(x ? 'radial' : 'linear', ((t) => { (Array.isArray(l[h]) ? l[h] : l).forEach(((e) => { t.at(e.offset / 100, e.color, e.opacity); })); })), x) {
          const b = c.globals.gridWidth / 2; const m = c.globals.gridHeight / 2; c.config.chart.type !== 'bubble' ? r.attr({
            gradientUnits: 'userSpaceOnUse', cx: b, cy: m, r: n,
          }) : r.attr({
            cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2,
          });
        } else t === 'vertical' ? r.from(0, 0).to(0, 1) : t === 'diagonal' ? r.from(0, 0).to(1, 1) : t === 'horizontal' ? r.from(0, 1).to(1, 1) : t === 'diagonal2' && r.from(1, 0).to(0, 1); return r;
      },
    }, {
      key: 'drawText',
      value(t) {
        let e; const i = t.x; const a = t.y; let s = t.text; let r = t.textAnchor; const n = t.fontSize; let o = t.fontFamily; let l = t.fontWeight; let h = t.foreColor; const c = t.opacity; const d = t.cssClass; const g = void 0 === d ? '' : d; const u = t.isPlainText; const f = void 0 === u || u; const p = this.w; return void 0 === s && (s = ''), r || (r = 'start'), h && h.length || (h = p.config.chart.foreColor), o = o || p.config.chart.fontFamily, l = l || 'regular', (e = Array.isArray(s) ? p.globals.dom.Paper.text(((t) => { for (let e = 0; e < s.length; e++)e === 0 ? t.tspan(s[e]) : t.tspan(s[e]).newLine(); })) : f ? p.globals.dom.Paper.plain(s) : p.globals.dom.Paper.text(((t) => t.tspan(s)))).attr({
          x: i, y: a, 'text-anchor': r, 'dominant-baseline': 'auto', 'font-size': n, 'font-family': o, 'font-weight': l, fill: h, class: `apexcharts-text ${g}`,
        }), e.node.style.fontFamily = o, e.node.style.opacity = c, e;
      },
    }, {
      key: 'drawMarker',
      value(t, e, i) {
        t = t || 0; let a = i.pSize || 0; let s = null; if (i.shape === 'square') {
          let r = void 0 === i.pRadius ? a / 2 : i.pRadius; e !== null && a || (a = 0, r = 0); const n = 1.2 * a + r; const o = this.drawRect(n, n, n, n, r); o.attr({
            x: t - n / 2, y: e - n / 2, cx: t, cy: e, class: i.class ? i.class : '', fill: i.pointFillColor, 'fill-opacity': i.pointFillOpacity ? i.pointFillOpacity : 1, stroke: i.pointStrokeColor, 'stroke-width': i.pWidth ? i.pWidth : 0, 'stroke-opacity': i.pointStrokeOpacity ? i.pointStrokeOpacity : 1,
          }), s = o;
        } else { i.shape !== 'circle' && i.shape || (g.isNumber(e) || (a = 0, e = 0), s = this.drawCircle(a, {
          cx: t, cy: e, class: i.class ? i.class : '', stroke: i.pointStrokeColor, fill: i.pointFillColor, 'fill-opacity': i.pointFillOpacity ? i.pointFillOpacity : 1, 'stroke-width': i.pWidth ? i.pWidth : 0, 'stroke-opacity': i.pointStrokeOpacity ? i.pointStrokeOpacity : 1,
        })); } return s;
      },
    }, { key: 'pathMouseEnter', value(t, e) { const i = this.w; const a = new u(this.ctx); const s = parseInt(t.node.getAttribute('index'), 10); const r = parseInt(t.node.getAttribute('j'), 10); if (typeof i.config.chart.events.dataPointMouseEnter === 'function' && i.config.chart.events.dataPointMouseEnter(e, this.ctx, { seriesIndex: s, dataPointIndex: r, w: i }), this.ctx.events.fireEvent('dataPointMouseEnter', [e, this.ctx, { seriesIndex: s, dataPointIndex: r, w: i }]), (i.config.states.active.filter.type === 'none' || t.node.getAttribute('selected') !== 'true') && i.config.states.hover.filter.type !== 'none' && i.config.states.active.filter.type !== 'none' && !i.globals.isTouchDevice) { const n = i.config.states.hover.filter; a.applyFilter(t, s, n.type, n.value); } } }, { key: 'pathMouseLeave', value(t, e) { const i = this.w; const a = new u(this.ctx); const s = parseInt(t.node.getAttribute('index'), 10); const r = parseInt(t.node.getAttribute('j'), 10); typeof i.config.chart.events.dataPointMouseLeave === 'function' && i.config.chart.events.dataPointMouseLeave(e, this.ctx, { seriesIndex: s, dataPointIndex: r, w: i }), this.ctx.events.fireEvent('dataPointMouseLeave', [e, this.ctx, { seriesIndex: s, dataPointIndex: r, w: i }]), i.config.states.active.filter.type !== 'none' && t.node.getAttribute('selected') === 'true' || i.config.states.hover.filter.type !== 'none' && a.getDefaultFilter(t, s); } }, {
      key: 'pathMouseDown',
      value(t, e) {
        const i = this.w; const a = new u(this.ctx); const s = parseInt(t.node.getAttribute('index'), 10); const r = parseInt(t.node.getAttribute('j'), 10); let n = 'false'; if (t.node.getAttribute('selected') === 'true') { if (t.node.setAttribute('selected', 'false'), i.globals.selectedDataPoints[s].indexOf(r) > -1) { const o = i.globals.selectedDataPoints[s].indexOf(r); i.globals.selectedDataPoints[s].splice(o, 1); } } else { if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) { i.globals.selectedDataPoints = []; const l = i.globals.dom.Paper.select('.apexcharts-series path').members; const h = i.globals.dom.Paper.select('.apexcharts-series circle, .apexcharts-series rect').members; const c = function (t) { Array.prototype.forEach.call(t, ((t) => { t.node.setAttribute('selected', 'false'), a.getDefaultFilter(t, s); })); }; c(l), c(h); }t.node.setAttribute('selected', 'true'), n = 'true', void 0 === i.globals.selectedDataPoints[s] && (i.globals.selectedDataPoints[s] = []), i.globals.selectedDataPoints[s].push(r); } if (n === 'true') { const d = i.config.states.active.filter; d !== 'none' && a.applyFilter(t, s, d.type, d.value); } else i.config.states.active.filter.type !== 'none' && a.getDefaultFilter(t, s); typeof i.config.chart.events.dataPointSelection === 'function' && i.config.chart.events.dataPointSelection(e, this.ctx, {
          selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: s, dataPointIndex: r, w: i,
        }), e && this.ctx.events.fireEvent('dataPointSelection', [e, this.ctx, {
          selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: s, dataPointIndex: r, w: i,
        }]);
      },
    }, { key: 'rotateAroundCenter', value(t) { const e = t.getBBox(); return { x: e.x + e.width / 2, y: e.y + e.height / 2 }; } }, {
      key: 'getTextRects',
      value(t, e, i, a) {
        const s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]; const r = this.w; const n = this.drawText({
          x: -200, y: -200, text: t, textAnchor: 'start', fontSize: e, fontFamily: i, foreColor: '#fff', opacity: 0,
        }); a && n.attr('transform', a), r.globals.dom.Paper.add(n); let o = n.bbox(); return s || (o = n.node.getBoundingClientRect()), n.remove(), { width: o.width, height: o.height };
      },
    }, { key: 'placeTextWithEllipsis', value(t, e, i) { if (typeof t.getComputedTextLength === 'function' && (t.textContent = e, e.length > 0 && t.getComputedTextLength() >= i / 0.8)) { for (let a = e.length - 3; a > 0; a -= 3) if (t.getSubStringLength(0, a) <= i / 0.8) return void (t.textContent = `${e.substring(0, a)}...`); t.textContent = '.'; } } }], [{ key: 'setAttrs', value(t, e) { for (const i in e)e.hasOwnProperty(i) && t.setAttribute(i, e[i]); } }]), t;
  }()); const x = (function () { function t(i) { e(this, t), this.w = i.w, this.annoCtx = i; } return a(t, [{ key: 'setOrientations', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const i = this.w; if (t.label.orientation === 'vertical') { const a = e !== null ? e : 0; const s = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a, "']")); if (s !== null) { const r = s.getBoundingClientRect(); s.setAttribute('x', parseFloat(s.getAttribute('x')) - r.height + 4), t.label.position === 'top' ? s.setAttribute('y', parseFloat(s.getAttribute('y')) + r.width) : s.setAttribute('y', parseFloat(s.getAttribute('y')) - r.width); const n = this.annoCtx.graphics.rotateAroundCenter(s); const o = n.x; const l = n.y; s.setAttribute('transform', 'rotate(-90 '.concat(o, ' ').concat(l, ')')); } } } }, { key: 'addBackgroundToAnno', value(t, e) { const i = this.w; if (!e.label.text || e.label.text && !e.label.text.trim()) return null; const a = i.globals.dom.baseEl.querySelector('.apexcharts-grid').getBoundingClientRect(); const s = t.getBoundingClientRect(); let r = e.label.style.padding.left; let n = e.label.style.padding.right; let o = e.label.style.padding.top; let l = e.label.style.padding.bottom; e.label.orientation === 'vertical' && (o = e.label.style.padding.left, l = e.label.style.padding.right, r = e.label.style.padding.top, n = e.label.style.padding.bottom); const h = s.left - a.left - r; const c = s.top - a.top - o; const d = this.annoCtx.graphics.drawRect(h, c, s.width + r + n, s.height + o + l, 0, e.label.style.background, 1, e.label.borderWidth, e.label.borderColor, 0); return e.id && d.node.classList.add(e.id), d; } }, { key: 'annotationsBackground', value() { const t = this; const e = this.w; const i = function (i, a, s) { const r = e.globals.dom.baseEl.querySelector('.apexcharts-'.concat(s, '-annotations .apexcharts-').concat(s, "-annotation-label[rel='").concat(a, "']")); if (r) { const n = r.parentNode; const o = t.addBackgroundToAnno(r, i); o && n.insertBefore(o.node, r); } }; e.config.annotations.xaxis.map(((t, e) => { i(t, e, 'xaxis'); })), e.config.annotations.yaxis.map(((t, e) => { i(t, e, 'yaxis'); })), e.config.annotations.points.map(((t, e) => { i(t, e, 'point'); })); } }, { key: 'getStringX', value(t) { const e = this.w; let i = t; e.config.xaxis.convertedCatToNumeric && e.globals.categoryLabels.length && (t = e.globals.categoryLabels.indexOf(t) + 1); const a = e.globals.labels.indexOf(t); const s = e.globals.dom.baseEl.querySelector(`.apexcharts-xaxis-texts-g text:nth-child(${a + 1})`); return s && (i = parseFloat(s.getAttribute('x'))), i; } }]), t; }()); const b = (function () {
    function t(i) { e(this, t), this.w = i.w, this.annoCtx = i, this.invertAxis = this.annoCtx.invertAxis; } return a(t, [{
      key: 'addXaxisAnnotation',
      value(t, e, i) {
        const a = this.w; const s = this.invertAxis ? a.globals.minY : a.globals.minX; const r = this.invertAxis ? a.globals.maxY : a.globals.maxX; const n = this.invertAxis ? a.globals.yRange[0] : a.globals.xRange; let o = (t.x - s) / (n / a.globals.gridWidth); this.annoCtx.inversedReversedAxis && (o = (r - t.x) / (n / a.globals.gridWidth)); const l = t.label.text; a.config.xaxis.type !== 'category' && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || a.globals.dataFormatXNumeric || (o = this.annoCtx.helpers.getStringX(t.x)); const h = t.strokeDashArray; if (g.isNumber(o)) {
          if (t.x2 === null) { const c = this.annoCtx.graphics.drawLine(o + t.offsetX, 0 + t.offsetY, o + t.offsetX, a.globals.gridHeight + t.offsetY, t.borderColor, h, t.borderWidth); e.appendChild(c.node), t.id && c.node.classList.add(t.id); } else { let d = (t.x2 - s) / (n / a.globals.gridWidth); if (this.annoCtx.inversedReversedAxis && (d = (r - t.x2) / (n / a.globals.gridWidth)), a.config.xaxis.type !== 'category' && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || a.globals.dataFormatXNumeric || (d = this.annoCtx.helpers.getStringX(t.x2)), d < o) { const u = o; o = d, d = u; } const f = this.annoCtx.graphics.drawRect(o + t.offsetX, 0 + t.offsetY, d - o, a.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, h); f.node.classList.add('apexcharts-annotation-rect'), f.attr('clip-path', 'url(#gridRectMask'.concat(a.globals.cuid, ')')), e.appendChild(f.node), t.id && f.node.classList.add(t.id); } const p = t.label.position === 'top' ? 4 : a.globals.gridHeight; const x = this.annoCtx.graphics.getTextRects(l, parseFloat(t.label.style.fontSize)); const b = this.annoCtx.graphics.drawText({
            x: o + t.label.offsetX, y: p + t.label.offsetY - (t.label.orientation === 'vertical' ? t.label.position === 'top' ? x.width / 2 - 12 : -x.width / 2 : 0), text: l, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, foreColor: t.label.style.color, cssClass: 'apexcharts-xaxis-annotation-label '.concat(t.label.style.cssClass, ' ').concat(t.id ? t.id : ''),
          }); b.attr({ rel: i }), e.appendChild(b.node), this.annoCtx.helpers.setOrientations(t, i);
        }
      },
    }, { key: 'drawXAxisAnnotations', value() { const t = this; const e = this.w; const i = this.annoCtx.graphics.group({ class: 'apexcharts-xaxis-annotations' }); return e.config.annotations.xaxis.map(((e, a) => { t.addXaxisAnnotation(e, i.node, a); })), i; } }]), t;
  }()); const m = (function () {
    function t(i) { e(this, t), this.w = i.w, this.annoCtx = i; } return a(t, [{
      key: 'addYaxisAnnotation',
      value(t, e, i) {
        let a; const s = this.w; const r = t.strokeDashArray; let n = this._getY1Y2('y1', t); const o = t.label.text; if (t.y2 === null) { const l = this.annoCtx.graphics.drawLine(0 + t.offsetX, n + t.offsetY, s.globals.gridWidth + t.offsetX, n + t.offsetY, t.borderColor, r, t.borderWidth); e.appendChild(l.node), t.id && l.node.classList.add(t.id); } else { if ((a = this._getY1Y2('y2', t)) > n) { const h = n; n = a, a = h; } const c = this.annoCtx.graphics.drawRect(0 + t.offsetX, a + t.offsetY, s.globals.gridWidth + t.offsetX, n - a, 0, t.fillColor, t.opacity, 1, t.borderColor, r); c.node.classList.add('apexcharts-annotation-rect'), c.attr('clip-path', 'url(#gridRectMask'.concat(s.globals.cuid, ')')), e.appendChild(c.node), t.id && c.node.classList.add(t.id); } const d = t.label.position === 'right' ? s.globals.gridWidth : 0; const g = this.annoCtx.graphics.drawText({
          x: d + t.label.offsetX, y: (a || n) + t.label.offsetY - 3, text: o, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, foreColor: t.label.style.color, cssClass: 'apexcharts-yaxis-annotation-label '.concat(t.label.style.cssClass, ' ').concat(t.id ? t.id : ''),
        }); g.attr({ rel: i }), e.appendChild(g.node);
      },
    }, { key: '_getY1Y2', value(t, e) { let i; const a = t === 'y1' ? e.y : e.y2; const s = this.w; if (this.annoCtx.invertAxis) { let r = s.globals.labels.indexOf(a); s.config.xaxis.convertedCatToNumeric && (r = s.globals.categoryLabels.indexOf(a)); const n = s.globals.dom.baseEl.querySelector(`.apexcharts-yaxis-texts-g text:nth-child(${r + 1})`); n && (i = parseFloat(n.getAttribute('y'))); } else i = s.globals.gridHeight - (a - s.globals.minYArr[e.yAxisIndex]) / (s.globals.yRange[e.yAxisIndex] / s.globals.gridHeight), s.config.yaxis[e.yAxisIndex] && s.config.yaxis[e.yAxisIndex].reversed && (i = (a - s.globals.minYArr[e.yAxisIndex]) / (s.globals.yRange[e.yAxisIndex] / s.globals.gridHeight)); return i; } }, { key: 'drawYAxisAnnotations', value() { const t = this; const e = this.w; const i = this.annoCtx.graphics.group({ class: 'apexcharts-yaxis-annotations' }); return e.config.annotations.yaxis.map(((e, a) => { t.addYaxisAnnotation(e, i.node, a); })), i; } }]), t;
  }()); const v = (function () {
    function t(i) { e(this, t), this.w = i.w, this.annoCtx = i; } return a(t, [{
      key: 'addPointAnnotation',
      value(t, e, i) {
        const a = this.w; let s = 0; let r = 0; let n = 0; if (this.annoCtx.invertAxis && console.warn('Point annotation is not supported in horizontal bar charts.'), typeof t.x === 'string') { let o = a.globals.labels.indexOf(t.x); a.config.xaxis.convertedCatToNumeric && (o = a.globals.categoryLabels.indexOf(t.x)), s = this.annoCtx.helpers.getStringX(t.x); let l = t.y; t.y === null && (l = a.globals.series[t.seriesIndex][o]), r = a.globals.gridHeight - (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight) - parseFloat(t.label.style.fontSize) - t.marker.size, n = a.globals.gridHeight - (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight), a.config.yaxis[t.yAxisIndex] && a.config.yaxis[t.yAxisIndex].reversed && (r = (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight) + parseFloat(t.label.style.fontSize) + t.marker.size, n = (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight)); } else s = (t.x - a.globals.minX) / (a.globals.xRange / a.globals.gridWidth), r = a.globals.gridHeight - (parseFloat(t.y) - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight) - parseFloat(t.label.style.fontSize) - t.marker.size, n = a.globals.gridHeight - (t.y - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight), a.config.yaxis[t.yAxisIndex] && a.config.yaxis[t.yAxisIndex].reversed && (r = (parseFloat(t.y) - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight) - parseFloat(t.label.style.fontSize) - t.marker.size, n = (t.y - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight)); if (g.isNumber(s)) {
          const h = {
            pSize: t.marker.size, pWidth: t.marker.strokeWidth, pointFillColor: t.marker.fillColor, pointStrokeColor: t.marker.strokeColor, shape: t.marker.shape, radius: t.marker.radius, class: 'apexcharts-point-annotation-marker '.concat(t.marker.cssClass, ' ').concat(t.id ? t.id : ''),
          }; const c = this.annoCtx.graphics.drawMarker(s + t.marker.offsetX, n + t.marker.offsetY, h); e.appendChild(c.node); const d = t.label.text ? t.label.text : ''; const
            u = this.annoCtx.graphics.drawText({
              x: s + t.label.offsetX, y: r + t.label.offsetY, text: d, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, foreColor: t.label.style.color, cssClass: 'apexcharts-point-annotation-label '.concat(t.label.style.cssClass, ' ').concat(t.id ? t.id : ''),
            }); if (u.attr({ rel: i }), e.appendChild(u.node), t.customSVG.SVG) { const f = this.annoCtx.graphics.group({ class: `apexcharts-point-annotations-custom-svg ${t.customSVG.cssClass}` }); f.attr({ transform: 'translate('.concat(s + t.customSVG.offsetX, ', ').concat(r + t.customSVG.offsetY, ')') }), f.node.innerHTML = t.customSVG.SVG, e.appendChild(f.node); } if (t.image.path) {
            const p = t.image.width ? t.image.width : 20; const x = t.image.height ? t.image.height : 20; this.annoCtx.addImage({
              x: s + t.image.offsetX - p / 2, y: r + t.image.offsetY - x / 2, width: p, height: x, path: t.image.path, appendTo: e,
            }, !1, this.annoCtx.ctx);
          }
        }
      },
    }, { key: 'drawPointAnnotations', value() { const t = this; const e = this.w; const i = this.annoCtx.graphics.group({ class: 'apexcharts-point-annotations' }); return e.config.annotations.points.map(((e, a) => { t.addPointAnnotation(e, i.node, a); })), i; } }]), t;
  }()); let y; let w; const k = {
    name: 'en',
    options: {
      months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      toolbar: {
        exportToSVG: 'Download SVG', exportToPNG: 'Download PNG', exportToCSV: 'Download CSV', menu: 'Menu', selection: 'Selection', selectionZoom: 'Selection Zoom', zoomIn: 'Zoom In', zoomOut: 'Zoom Out', pan: 'Panning', reset: 'Reset Zoom',
      },
    },
  }; const A = (function () {
    function t() {
      e(this, t), this.yAxis = {
        show: !0,
        showAlways: !1,
        seriesName: void 0,
        opposite: !1,
        reversed: !1,
        logarithmic: !1,
        tickAmount: void 0,
        forceNiceScale: !1,
        max: void 0,
        min: void 0,
        floating: !1,
        decimalsInFloat: void 0,
        labels: {
          show: !0,
          minWidth: 0,
          maxWidth: 160,
          offsetX: 0,
          offsetY: 0,
          align: void 0,
          rotate: 0,
          padding: 20,
          style: {
            colors: [], fontSize: '11px', fontWeight: 400, fontFamily: void 0, cssClass: '',
          },
          formatter: void 0,
        },
        axisBorder: {
          show: !1, color: '#e0e0e0', width: 1, offsetX: 0, offsetY: 0,
        },
        axisTicks: {
          show: !1, color: '#e0e0e0', width: 6, offsetX: 0, offsetY: 0,
        },
        title: {
          text: void 0,
          rotate: 90,
          offsetY: 0,
          offsetX: 0,
          style: {
            color: void 0, fontSize: '11px', fontWeight: 900, fontFamily: void 0, cssClass: '',
          },
        },
        tooltip: { enabled: !1, offsetX: 0 },
        crosshairs: { show: !0, position: 'front', stroke: { color: '#b6b6b6', width: 1, dashArray: 0 } },
      }, this.pointAnnotation = {
        x: 0,
        y: null,
        yAxisIndex: 0,
        seriesIndex: 0,
        marker: {
          size: 4, fillColor: '#fff', strokeWidth: 2, strokeColor: '#333', shape: 'circle', offsetX: 0, offsetY: 0, radius: 2, cssClass: '',
        },
        label: {
          borderColor: '#c2c2c2',
          borderWidth: 1,
          text: void 0,
          textAnchor: 'middle',
          offsetX: 0,
          offsetY: -15,
          style: {
            background: '#fff',
            color: void 0,
            fontSize: '11px',
            fontFamily: void 0,
            fontWeight: 400,
            cssClass: '',
            padding: {
              left: 5, right: 5, top: 2, bottom: 2,
            },
          },
        },
        customSVG: {
          SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0,
        },
        image: {
          path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0,
        },
      }, this.yAxisAnnotation = {
        y: 0,
        y2: null,
        strokeDashArray: 1,
        fillColor: '#c2c2c2',
        borderColor: '#c2c2c2',
        borderWidth: 1,
        opacity: 0.3,
        offsetX: 0,
        offsetY: 0,
        yAxisIndex: 0,
        label: {
          borderColor: '#c2c2c2',
          borderWidth: 1,
          text: void 0,
          textAnchor: 'end',
          position: 'right',
          offsetX: 0,
          offsetY: -3,
          style: {
            background: '#fff',
            color: void 0,
            fontSize: '11px',
            fontFamily: void 0,
            fontWeight: 400,
            cssClass: '',
            padding: {
              left: 5, right: 5, top: 2, bottom: 2,
            },
          },
        },
      }, this.xAxisAnnotation = {
        x: 0,
        x2: null,
        strokeDashArray: 1,
        fillColor: '#c2c2c2',
        borderColor: '#c2c2c2',
        borderWidth: 1,
        opacity: 0.3,
        offsetX: 0,
        offsetY: 0,
        label: {
          borderColor: '#c2c2c2',
          borderWidth: 1,
          text: void 0,
          textAnchor: 'middle',
          orientation: 'vertical',
          position: 'top',
          offsetX: 0,
          offsetY: 0,
          style: {
            background: '#fff',
            color: void 0,
            fontSize: '11px',
            fontFamily: void 0,
            fontWeight: 400,
            cssClass: '',
            padding: {
              left: 5, right: 5, top: 2, bottom: 2,
            },
          },
        },
      };
    } return a(t, [{
      key: 'init',
      value() {
        return {
          annotations: {
            position: 'front', yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation],
          },
          chart: {
            animations: {
              enabled: !0, easing: 'easeinout', speed: 800, animateGradually: { delay: 150, enabled: !0 }, dynamicAnimation: { enabled: !0, speed: 350 },
            },
            background: 'transparent',
            locales: [k],
            defaultLocale: 'en',
            dropShadow: {
              enabled: !1, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: '#000', opacity: 0.35,
            },
            events: {
              animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, zoomed: void 0, scrolled: void 0,
            },
            foreColor: '#373d3f',
            fontFamily: 'Helvetica, Arial, sans-serif',
            height: 'auto',
            parentHeightOffset: 15,
            redrawOnParentResize: !0,
            id: void 0,
            group: void 0,
            offsetX: 0,
            offsetY: 0,
            selection: {
              enabled: !1,
              type: 'x',
              fill: { color: '#24292e', opacity: 0.1 },
              stroke: {
                width: 1, color: '#24292e', opacity: 0.4, dashArray: 3,
              },
              xaxis: { min: void 0, max: void 0 },
              yaxis: { min: void 0, max: void 0 },
            },
            sparkline: { enabled: !1 },
            brush: { enabled: !1, autoScaleYaxis: !0, target: void 0 },
            stacked: !1,
            stackType: 'normal',
            toolbar: {
              show: !0,
              tools: {
                download: !0, selection: !0, zoom: !0, zoomin: !0, zoomout: !0, pan: !0, reset: !0, customIcons: [],
              },
              autoSelected: 'zoom',
            },
            type: 'line',
            width: '100%',
            zoom: {
              enabled: !0, type: 'x', autoScaleYaxis: !1, zoomedArea: { fill: { color: '#90CAF9', opacity: 0.4 }, stroke: { color: '#0D47A1', opacity: 0.4, width: 1 } },
            },
          },
          plotOptions: {
            bar: {
              horizontal: !1,
              columnWidth: '70%',
              barHeight: '70%',
              distributed: !1,
              endingShape: 'flat',
              colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1 },
              dataLabels: {
                position: 'top', maxItems: 100, hideOverflowingLabels: !0, orientation: 'horizontal',
              },
            },
            bubble: { minBubbleRadius: void 0, maxBubbleRadius: void 0 },
            candlestick: { colors: { upward: '#00B746', downward: '#EF403C' }, wick: { useFillColor: !0 } },
            heatmap: {
              radius: 2,
              enableShades: !0,
              shadeIntensity: 0.5,
              reverseNegativeShade: !1,
              distributed: !1,
              colorScale: {
                inverse: !1, ranges: [], min: void 0, max: void 0,
              },
            },
            radialBar: {
              inverseOrder: !1,
              startAngle: 0,
              endAngle: 360,
              offsetX: 0,
              offsetY: 0,
              hollow: {
                margin: 5,
                size: '50%',
                background: 'transparent',
                image: void 0,
                imageWidth: 150,
                imageHeight: 150,
                imageOffsetX: 0,
                imageOffsetY: 0,
                imageClipped: !0,
                position: 'front',
                dropShadow: {
                  enabled: !1, top: 0, left: 0, blur: 3, color: '#000', opacity: 0.5,
                },
              },
              track: {
                show: !0,
                startAngle: void 0,
                endAngle: void 0,
                background: '#f2f2f2',
                strokeWidth: '97%',
                opacity: 1,
                margin: 5,
                dropShadow: {
                  enabled: !1, top: 0, left: 0, blur: 3, color: '#000', opacity: 0.5,
                },
              },
              dataLabels: {
                show: !0,
                name: {
                  show: !0, fontSize: '16px', fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter(t) { return t; },
                },
                value: {
                  show: !0, fontSize: '14px', fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter(t) { return `${t}%`; },
                },
                total: {
                  show: !1, label: 'Total', fontSize: '16px', fontWeight: 600, fontFamily: void 0, color: void 0, formatter(t) { return `${t.globals.seriesTotals.reduce(((t, e) => t + e), 0) / t.globals.series.length}%`; },
                },
              },
            },
            pie: {
              customScale: 1,
              offsetX: 0,
              offsetY: 0,
              expandOnClick: !0,
              dataLabels: { offset: 0, minAngleToShowLabel: 10 },
              donut: {
                size: '65%',
                background: 'transparent',
                labels: {
                  show: !1,
                  name: {
                    show: !0, fontSize: '16px', fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter(t) { return t; },
                  },
                  value: {
                    show: !0, fontSize: '20px', fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter(t) { return t; },
                  },
                  total: {
                    show: !1, showAlways: !1, label: 'Total', fontSize: '16px', fontWeight: 400, fontFamily: void 0, color: void 0, formatter(t) { return t.globals.seriesTotals.reduce(((t, e) => t + e), 0); },
                  },
                },
              },
            },
            radar: {
              size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeColors: '#e8e8e8', connectorColors: '#e8e8e8', fill: { colors: void 0 } },
            },
          },
          colors: void 0,
          dataLabels: {
            enabled: !0,
            enabledOnSeries: void 0,
            formatter(t) { return t !== null ? t : ''; },
            textAnchor: 'middle',
            offsetX: 0,
            offsetY: 0,
            style: {
              fontSize: '12px', fontFamily: void 0, fontWeight: 600, colors: void 0,
            },
            background: {
              enabled: !0, foreColor: '#fff', borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: '#fff',
            },
            dropShadow: {
              enabled: !1, top: 1, left: 1, blur: 1, color: '#000', opacity: 0.45,
            },
          },
          fill: {
            type: 'solid',
            colors: void 0,
            opacity: 0.85,
            gradient: {
              shade: 'dark', type: 'horizontal', shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [],
            },
            image: { src: [], width: void 0, height: void 0 },
            pattern: {
              style: 'squares', width: 6, height: 6, strokeWidth: 2,
            },
          },
          grid: {
            show: !0,
            borderColor: '#e0e0e0',
            strokeDashArray: 0,
            position: 'back',
            xaxis: { lines: { show: !1 } },
            yaxis: { lines: { show: !0 } },
            row: { colors: void 0, opacity: 0.5 },
            column: { colors: void 0, opacity: 0.5 },
            padding: {
              top: 0, right: 10, bottom: 0, left: 12,
            },
          },
          labels: [],
          legend: {
            show: !0,
            showForSingleSeries: !1,
            showForNullSeries: !0,
            showForZeroSeries: !0,
            floating: !1,
            position: 'bottom',
            horizontalAlign: 'center',
            inverseOrder: !1,
            fontSize: '12px',
            fontFamily: void 0,
            fontWeight: 400,
            width: void 0,
            height: void 0,
            formatter: void 0,
            tooltipHoverFormatter: void 0,
            offsetX: -20,
            offsetY: 0,
            labels: { colors: void 0, useSeriesColors: !1 },
            markers: {
              width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: '#fff', radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0,
            },
            itemMargin: { horizontal: 5, vertical: 0 },
            onItemClick: { toggleDataSeries: !0 },
            onItemHover: { highlightDataSeries: !0 },
          },
          markers: {
            discrete: [], size: 0, colors: void 0, strokeColors: '#fff', strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: 'circle', radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, showNullDataPoints: !0, hover: { size: void 0, sizeOffset: 3 },
          },
          noData: {
            text: void 0, align: 'center', verticalAlign: 'middle', offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: '14px', fontFamily: void 0 },
          },
          responsive: [],
          series: void 0,
          states: { normal: { filter: { type: 'none', value: 0 } }, hover: { filter: { type: 'lighten', value: 0.15 } }, active: { allowMultipleDataPointsSelection: !1, filter: { type: 'darken', value: 0.65 } } },
          title: {
            text: void 0,
            align: 'left',
            margin: 5,
            offsetX: 0,
            offsetY: 0,
            floating: !1,
            style: {
              fontSize: '14px', fontWeight: 900, fontFamily: void 0, color: void 0,
            },
          },
          subtitle: {
            text: void 0,
            align: 'left',
            margin: 5,
            offsetX: 0,
            offsetY: 30,
            floating: !1,
            style: {
              fontSize: '12px', fontWeight: 400, fontFamily: void 0, color: void 0,
            },
          },
          stroke: {
            show: !0, curve: 'smooth', lineCap: 'butt', width: 2, colors: void 0, dashArray: 0,
          },
          tooltip: {
            enabled: !0,
            enabledOnSeries: void 0,
            shared: !0,
            followCursor: !1,
            intersect: !1,
            inverseOrder: !1,
            custom: void 0,
            fillSeriesColor: !1,
            theme: 'light',
            style: { fontSize: '12px', fontFamily: void 0 },
            onDatasetHover: { highlightDataSeries: !1 },
            x: { show: !0, format: 'dd MMM', formatter: void 0 },
            y: { formatter: void 0, title: { formatter(t) { return t; } } },
            z: { formatter: void 0, title: 'Size: ' },
            marker: { show: !0, fillColors: void 0 },
            items: { display: 'flex' },
            fixed: {
              enabled: !1, position: 'topRight', offsetX: 0, offsetY: 0,
            },
          },
          xaxis: {
            type: 'category',
            categories: [],
            convertedCatToNumeric: !1,
            offsetX: 0,
            offsetY: 0,
            labels: {
              show: !0,
              rotate: -45,
              rotateAlways: !1,
              hideOverlappingLabels: !0,
              trim: !0,
              minHeight: void 0,
              maxHeight: 120,
              showDuplicates: !0,
              style: {
                colors: [], fontSize: '12px', fontWeight: 400, fontFamily: void 0, cssClass: '',
              },
              offsetX: 0,
              offsetY: 0,
              format: void 0,
              formatter: void 0,
              datetimeUTC: !0,
              datetimeFormatter: {
                year: 'yyyy', month: "MMM 'yy", day: 'dd MMM', hour: 'HH:mm', minute: 'HH:mm:ss',
              },
            },
            axisBorder: {
              show: !0, color: '#e0e0e0', width: '100%', height: 1, offsetX: 0, offsetY: 0,
            },
            axisTicks: {
              show: !0, color: '#e0e0e0', height: 6, offsetX: 0, offsetY: 0,
            },
            tickAmount: void 0,
            tickPlacement: 'on',
            min: void 0,
            max: void 0,
            range: void 0,
            floating: !1,
            position: 'bottom',
            title: {
              text: void 0,
              offsetX: 0,
              offsetY: 0,
              style: {
                color: void 0, fontSize: '12px', fontWeight: 900, fontFamily: void 0, cssClass: '',
              },
            },
            crosshairs: {
              show: !0,
              width: 1,
              position: 'back',
              opacity: 0.9,
              stroke: { color: '#b6b6b6', width: 1, dashArray: 3 },
              fill: {
                type: 'solid',
                color: '#B1B9C4',
                gradient: {
                  colorFrom: '#D8E3F0', colorTo: '#BED1E6', stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5,
                },
              },
              dropShadow: {
                enabled: !1, left: 0, top: 0, blur: 1, opacity: 0.4,
              },
            },
            tooltip: {
              enabled: !0, offsetY: 0, formatter: void 0, style: { fontSize: '12px', fontFamily: void 0 },
            },
          },
          yaxis: this.yAxis,
          theme: {
            mode: 'light',
            palette: 'palette1',
            monochrome: {
              enabled: !1, color: '#008FFB', shadeTo: 'light', shadeIntensity: 0.65,
            },
          },
        };
      },
    }]), t;
  }()); const S = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.graphics = new p(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new x(this), this.xAxisAnnotations = new b(this), this.yAxisAnnotations = new m(this), this.pointsAnnotations = new v(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints; } return a(t, [{ key: 'drawAnnotations', value() { const t = this.w; if (t.globals.axisCharts) { for (let e = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), a = this.pointsAnnotations.drawPointAnnotations(), s = t.config.chart.animations.enabled, r = [e, i, a], n = [i.node, e.node, a.node], o = 0; o < 3; o++)t.globals.dom.elGraphical.add(r[o]), !s || t.globals.resized || t.globals.dataChanged || t.config.chart.type !== 'scatter' && t.config.chart.type !== 'bubble' && t.globals.dataPoints > 1 && n[o].classList.add('apexcharts-element-hidden'), t.globals.delayedElements.push({ el: n[o], index: 0 }); this.helpers.annotationsBackground(); } } }, { key: 'addXaxisAnnotation', value(t, e, i) { this.xAxisAnnotations.addXaxisAnnotation(t, e, i); } }, { key: 'addYaxisAnnotation', value(t, e, i) { this.yAxisAnnotations.addYaxisAnnotation(t, e, i); } }, { key: 'addPointAnnotation', value(t, e, i) { this.pointsAnnotations.addPointAnnotation(t, e, i); } }, { key: 'clearAnnotations', value(t) { const e = t.w; let i = e.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations'); e.globals.memory.methodsToExec.map(((t, i) => { t.label !== 'addText' && t.label !== 'addAnnotation' || e.globals.memory.methodsToExec.splice(i, 1); })), i = g.listToArray(i), Array.prototype.forEach.call(i, ((t) => { for (;t.firstChild;)t.removeChild(t.firstChild); })); } }, { key: 'removeAnnotation', value(t, e) { const i = t.w; const a = i.globals.dom.baseEl.querySelectorAll('.'.concat(e)); a && (i.globals.memory.methodsToExec.map(((t, a) => { t.id === e && i.globals.memory.methodsToExec.splice(a, 1); })), Array.prototype.forEach.call(a, ((t) => { t.parentElement.removeChild(t); }))); } }, {
      key: 'addText',
      value(t, e, i) {
        const a = t.x; const s = t.y; const r = t.text; const n = t.textAnchor; const o = t.appendTo; const l = void 0 === o ? '.apexcharts-inner' : o; const h = t.foreColor; const c = t.fontSize; const d = t.fontFamily; const g = t.cssClass; const u = t.backgroundColor; const f = t.borderWidth; const p = t.strokeDashArray; const x = t.radius; const b = t.borderColor; const m = t.paddingLeft; const v = void 0 === m ? 4 : m; const y = t.paddingRight; const w = void 0 === y ? 4 : y; const k = t.paddingBottom; const A = void 0 === k ? 2 : k; const S = t.paddingTop; const C = void 0 === S ? 2 : S; const L = i; const P = L.w; const T = P.globals.dom.baseEl.querySelector(l); const z = this.graphics.drawText({
          x: a, y: s, text: r, textAnchor: n || 'start', fontSize: c || '12px', fontFamily: d || P.config.chart.fontFamily, foreColor: h || P.config.chart.foreColor, cssClass: g,
        }); T.appendChild(z.node); const I = z.bbox(); if (r) { const M = this.graphics.drawRect(I.x - v, I.y - C, I.width + v + w, I.height + A + C, x, u, 1, f, b, p); T.insertBefore(M.node, z.node); } return e && P.globals.memory.methodsToExec.push({
          context: L, method: L.addText, label: 'addText', params: t,
        }), i;
      },
    }, {
      key: 'addImage',
      value(t, e, i) {
        const a = t.path; const s = t.x; const r = void 0 === s ? 0 : s; const n = t.y; const o = void 0 === n ? 0 : n; const l = t.width; const h = void 0 === l ? 20 : l; const c = t.height; const d = void 0 === c ? 20 : c; const g = t.appendTo; const u = void 0 === g ? i.w.globals.dom.Paper.node : g; const f = i; const p = f.w; const x = i.w.globals.dom.Paper.image(a); return x.size(h, d).move(r, o), u.appendChild(x.node), e && p.globals.memory.methodsToExec.push({
          context: f, method: f.addImage, label: 'addImage', params: t,
        }), i;
      },
    }, {
      key: 'addXaxisAnnotationExternal',
      value(t, e, i) {
        return this.addAnnotationExternal({
          params: t, pushToMemory: e, context: i, type: 'xaxis', contextMethod: i.addXaxisAnnotation,
        }), i;
      },
    }, {
      key: 'addYaxisAnnotationExternal',
      value(t, e, i) {
        return this.addAnnotationExternal({
          params: t, pushToMemory: e, context: i, type: 'yaxis', contextMethod: i.addYaxisAnnotation,
        }), i;
      },
    }, {
      key: 'addPointAnnotationExternal',
      value(t, e, i) {
        return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({
          params: t, pushToMemory: e, context: i, type: 'point', contextMethod: i.addPointAnnotation,
        }), i;
      },
    }, {
      key: 'addAnnotationExternal',
      value(t) {
        const e = t.params; const i = t.pushToMemory; const a = t.context; const s = t.type; const r = t.contextMethod; const n = a; const o = n.w; const l = o.globals.dom.baseEl.querySelector('.apexcharts-'.concat(s, '-annotations')); const h = l.childNodes.length + 1; const c = new A(); const d = { ...(s === 'xaxis' ? c.xAxisAnnotation : s === 'yaxis' ? c.yAxisAnnotation : c.pointAnnotation) }; const u = g.extend(d, e); switch (s) { case 'xaxis': this.addXaxisAnnotation(u, l, h); break; case 'yaxis': this.addYaxisAnnotation(u, l, h); break; case 'point': this.addPointAnnotation(u, l, h); } const f = o.globals.dom.baseEl.querySelector('.apexcharts-'.concat(s, '-annotations .apexcharts-').concat(s, "-annotation-label[rel='").concat(h, "']")); const p = this.helpers.addBackgroundToAnno(f, u); return p && l.insertBefore(p.node, f), i && o.globals.memory.methodsToExec.push({
          context: n, id: u.id ? u.id : g.randomId(), method: r, label: 'addAnnotation', params: e,
        }), a;
      },
    }]), t;
  }()); const C = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]; } return a(t, [{ key: 'isValidDate', value(t) { return !isNaN(this.parseDate(t)); } }, { key: 'getTimeStamp', value(t) { return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t; } }, { key: 'getDate', value(t) { return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t); } }, { key: 'parseDate', value(t) { const e = Date.parse(t); if (!isNaN(e)) return this.getTimeStamp(t); let i = Date.parse(t.replace(/-/g, '/').replace(/[a-z]+/gi, ' ')); return i = this.getTimeStamp(i); } }, { key: 'formatDate', value(t, e) { const i = this.w.globals.locale; const a = this.w.config.xaxis.labels.datetimeUTC; const s = ['\0'].concat(d(i.months)); const r = ['\x01'].concat(d(i.shortMonths)); const n = ['\x02'].concat(d(i.days)); const o = ['\x03'].concat(d(i.shortDays)); function l(t, e) { let i = `${t}`; for (e = e || 2; i.length < e;)i = `0${i}`; return i; } const h = a ? t.getUTCFullYear() : t.getFullYear(); e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, `$1${h}`)).replace(/(^|[^\\])yy/g, `$1${h.toString().substr(2, 2)}`)).replace(/(^|[^\\])y/g, `$1${h}`); const c = (a ? t.getUTCMonth() : t.getMonth()) + 1; e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, `$1${s[0]}`)).replace(/(^|[^\\])MMM/g, `$1${r[0]}`)).replace(/(^|[^\\])MM/g, `$1${l(c)}`)).replace(/(^|[^\\])M/g, `$1${c}`); const g = a ? t.getUTCDate() : t.getDate(); e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, `$1${n[0]}`)).replace(/(^|[^\\])ddd/g, `$1${o[0]}`)).replace(/(^|[^\\])dd/g, `$1${l(g)}`)).replace(/(^|[^\\])d/g, `$1${g}`); const u = a ? t.getUTCHours() : t.getHours(); const f = u > 12 ? u - 12 : u === 0 ? 12 : u; e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, `$1${l(u)}`)).replace(/(^|[^\\])H/g, `$1${u}`)).replace(/(^|[^\\])hh+/g, `$1${l(f)}`)).replace(/(^|[^\\])h/g, `$1${f}`); const p = a ? t.getUTCMinutes() : t.getMinutes(); e = (e = e.replace(/(^|[^\\])mm+/g, `$1${l(p)}`)).replace(/(^|[^\\])m/g, `$1${p}`); const x = a ? t.getUTCSeconds() : t.getSeconds(); e = (e = e.replace(/(^|[^\\])ss+/g, `$1${l(x)}`)).replace(/(^|[^\\])s/g, `$1${x}`); let b = a ? t.getUTCMilliseconds() : t.getMilliseconds(); e = e.replace(/(^|[^\\])fff+/g, `$1${l(b, 3)}`), b = Math.round(b / 10), e = e.replace(/(^|[^\\])ff/g, `$1${l(b)}`), b = Math.round(b / 10); const m = u < 12 ? 'AM' : 'PM'; e = (e = (e = e.replace(/(^|[^\\])f/g, `$1${b}`)).replace(/(^|[^\\])TT+/g, `$1${m}`)).replace(/(^|[^\\])T/g, `$1${m.charAt(0)}`); const v = m.toLowerCase(); e = (e = e.replace(/(^|[^\\])tt+/g, `$1${v}`)).replace(/(^|[^\\])t/g, `$1${v.charAt(0)}`); let y = -t.getTimezoneOffset(); let w = a || !y ? 'Z' : y > 0 ? '+' : '-'; if (!a) { const k = (y = Math.abs(y)) % 60; w += `${l(Math.floor(y / 60))}:${l(k)}`; }e = e.replace(/(^|[^\\])K/g, `$1${w}`); const A = (a ? t.getUTCDay() : t.getDay()) + 1; return e = (e = (e = (e = (e = e.replace(new RegExp(n[0], 'g'), n[A])).replace(new RegExp(o[0], 'g'), o[A])).replace(new RegExp(s[0], 'g'), s[c])).replace(new RegExp(r[0], 'g'), r[c])).replace(/\\(.)/g, '$1'); } }, {
      key: 'getTimeUnitsfromTimestamp',
      value(t, e, i) {
        const a = this.w; void 0 !== a.config.xaxis.min && (t = a.config.xaxis.min), void 0 !== a.config.xaxis.max && (e = a.config.xaxis.max); const s = this.getDate(t); const r = this.getDate(e); const n = this.formatDate(s, 'yyyy MM dd HH mm').split(' '); const o = this.formatDate(r, 'yyyy MM dd HH mm').split(' '); return {
          minMinute: parseInt(n[4], 10), maxMinute: parseInt(o[4], 10), minHour: parseInt(n[3], 10), maxHour: parseInt(o[3], 10), minDate: parseInt(n[2], 10), maxDate: parseInt(o[2], 10), minMonth: parseInt(n[1], 10) - 1, maxMonth: parseInt(o[1], 10) - 1, minYear: parseInt(n[0], 10), maxYear: parseInt(o[0], 10),
        };
      },
    }, { key: 'isLeapYear', value(t) { return t % 4 == 0 && t % 100 != 0 || t % 400 == 0; } }, { key: 'calculcateLastDaysOfMonth', value(t, e, i) { return this.determineDaysOfMonths(t, e) - i; } }, { key: 'determineDaysOfYear', value(t) { let e = 365; return this.isLeapYear(t) && (e = 366), e; } }, { key: 'determineRemainingDaysOfYear', value(t, e, i) { let a = this.daysCntOfYear[e] + i; return e > 1 && this.isLeapYear() && a++, a; } }, { key: 'determineDaysOfMonths', value(t, e) { let i = 30; switch (t = g.monthMod(t), !0) { case this.months30.indexOf(t) > -1: t === 2 && (i = this.isLeapYear(e) ? 29 : 28); break; case this.months31.indexOf(t) > -1: default: i = 31; } return i; } }]), t;
  }()); const L = (function () {
    function t(i) { e(this, t), this.opts = i; } return a(t, [{
      key: 'line',
      value() {
        return {
          chart: { animations: { easing: 'swing' } }, dataLabels: { enabled: !1 }, stroke: { width: 5, curve: 'straight' }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } },
        };
      },
    }, {
      key: 'sparkline',
      value(t) {
        this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = '', this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0; return g.extend(t, {
          grid: {
            show: !1,
            padding: {
              left: 0, right: 0, top: 0, bottom: 0,
            },
          },
          legend: { show: !1 },
          xaxis: {
            labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 },
          },
          chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } },
          dataLabels: { enabled: !1 },
        });
      },
    }, {
      key: 'bar',
      value() {
        return {
          chart: { stacked: !1, animations: { easing: 'swing' } },
          plotOptions: { bar: { dataLabels: { position: 'center' } } },
          dataLabels: { style: { colors: ['#fff'] } },
          stroke: { width: 0 },
          fill: { opacity: 0.85 },
          legend: { markers: { shape: 'square', radius: 2, size: 8 } },
          tooltip: { shared: !1 },
          xaxis: {
            tooltip: { enabled: !1 },
            tickPlacement: 'between',
            crosshairs: {
              width: 'barWidth', position: 'back', fill: { type: 'gradient' }, dropShadow: { enabled: !1 }, stroke: { width: 0 },
            },
          },
        };
      },
    }, {
      key: 'candlestick',
      value() {
        return {
          stroke: { width: 1, colors: ['#333'] }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom(t) { const e = t.seriesIndex; const i = t.dataPointIndex; const a = t.w; return `<div class="apexcharts-tooltip-candlestick"><div>Open: <span class="value">${a.globals.seriesCandleO[e][i]}</span></div><div>High: <span class="value">${a.globals.seriesCandleH[e][i]}</span></div><div>Low: <span class="value">${a.globals.seriesCandleL[e][i]}</span></div><div>Close: <span class="value">${a.globals.seriesCandleC[e][i]}</span></div></div>`; } }, states: { active: { filter: { type: 'none' } } }, xaxis: { crosshairs: { width: 1 } },
        };
      },
    }, {
      key: 'rangeBar',
      value() {
        return {
          stroke: { width: 0 }, plotOptions: { bar: { dataLabels: { position: 'center' } } }, dataLabels: { enabled: !1, formatter(t, e) { e.ctx; const i = e.seriesIndex; const a = e.dataPointIndex; const s = e.w; const r = s.globals.seriesRangeStart[i][a]; return s.globals.seriesRangeEnd[i][a] - r; }, style: { colors: ['#fff'] } }, tooltip: { shared: !1, followCursor: !0, custom(t) { const e = t.ctx; const i = t.seriesIndex; const a = t.dataPointIndex; const s = t.y1; const r = t.y2; const n = t.w; let o = n.globals.seriesRangeStart[i][a]; let l = n.globals.seriesRangeEnd[i][a]; let h = n.globals.labels[a]; let c = n.config.series[i].name; const d = n.config.tooltip.y.formatter; const g = n.config.tooltip.y.title.formatter; typeof g === 'function' && (c = g(c)), s && r && (o = s, l = r, n.config.series[i].data[a].x && (h = `${n.config.series[i].data[a].x}:`), typeof d === 'function' && (h = d(h))); let u = ''; let f = ''; const p = n.globals.colors[i]; if (void 0 === n.config.tooltip.x.formatter) if (n.config.xaxis.type === 'datetime') { const x = new C(e); u = x.formatDate(x.getDate(o), n.config.tooltip.x.format), f = x.formatDate(x.getDate(l), n.config.tooltip.x.format); } else u = o, f = l; else u = n.config.tooltip.x.formatter(o), f = n.config.tooltip.x.formatter(l); return `<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ${p}">${c || '' }</span></div><div> <span class="category">${h} </span> <span class="value start-value">${u}</span> <span class="separator">-</span> <span class="value end-value">${f}</span></div></div>`; } }, xaxis: { tickPlacement: 'between', tooltip: { enabled: !1 }, crosshairs: { stroke: { width: 0 } } },
        };
      },
    }, {
      key: 'area',
      value() {
        return {
          stroke: { width: 4 },
          fill: {
            type: 'gradient',
            gradient: {
              inverseColors: !1, shade: 'light', type: 'vertical', opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100],
            },
          },
          markers: { size: 0, hover: { sizeOffset: 6 } },
          tooltip: { followCursor: !1 },
        };
      },
    }, {
      key: 'brush',
      value(t) {
        return g.extend(t, {
          chart: { toolbar: { autoSelected: 'selection', show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 }, stroke: { width: 1 }, tooltip: { enabled: !1 }, xaxis: { tooltip: { enabled: !1 } },
        });
      },
    }, { key: 'stacked100', value(t) { t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0; const e = t.dataLabels.formatter; return t.yaxis.forEach(((e, i) => { t.yaxis[i].min = 0, t.yaxis[i].max = 100; })), t.chart.type === 'bar' && (t.dataLabels.formatter = e || function (t) { return typeof t === 'number' && t ? `${t.toFixed(0)}%` : t; }), t; } }, { key: 'convertCatToNumeric', value(t) { return t.xaxis.convertedCatToNumeric = !0, t; } }, { key: 'convertCatToNumericXaxis', value(t, e, i) { t.xaxis.type = 'numeric', t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function (t) { return g.isNumber(t) ? Math.floor(t) : t; }; const a = t.xaxis.labels.formatter; let s = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels; return i && i.length && (s = i.map(((t) => t.toString()))), s && s.length && (t.xaxis.labels.formatter = function (t) { return g.isNumber(t) ? a(s[Math.floor(t) - 1]) : a(t); }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || 'dataPoints', t; } }, {
      key: 'bubble',
      value() {
        return {
          dataLabels: { style: { colors: ['#fff'] } },
          tooltip: { shared: !1, intersect: !0 },
          xaxis: { crosshairs: { width: 0 } },
          fill: {
            type: 'solid',
            gradient: {
              shade: 'light', inverse: !0, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8,
            },
          },
        };
      },
    }, { key: 'scatter', value() { return { dataLabels: { enabled: !1 }, tooltip: { shared: !1, intersect: !0 }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } }; } }, {
      key: 'heatmap',
      value() {
        return {
          chart: { stacked: !1 }, fill: { opacity: 1 }, dataLabels: { style: { colors: ['#fff'] } }, stroke: { colors: ['#fff'] }, tooltip: { followCursor: !0, marker: { show: !1 }, x: { show: !1 } }, legend: { position: 'top', markers: { shape: 'square', size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } },
        };
      },
    }, {
      key: 'pie',
      value() {
        return {
          chart: { toolbar: { show: !1 } },
          plotOptions: { pie: { donut: { labels: { show: !1 } } } },
          dataLabels: { formatter(t) { return `${t.toFixed(1)}%`; }, style: { colors: ['#fff'] }, dropShadow: { enabled: !0 } },
          stroke: { colors: ['#fff'] },
          fill: {
            opacity: 1,
            gradient: {
              shade: 'dark', shadeIntensity: 0.35, inverseColors: !1, stops: [0, 100, 100],
            },
          },
          tooltip: { theme: 'dark', fillSeriesColor: !0 },
          legend: { position: 'right' },
        };
      },
    }, {
      key: 'donut',
      value() {
        return {
          chart: { toolbar: { show: !1 } },
          dataLabels: { formatter(t) { return `${t.toFixed(1)}%`; }, style: { colors: ['#fff'] }, dropShadow: { enabled: !0 } },
          stroke: { colors: ['#fff'] },
          fill: {
            opacity: 1,
            gradient: {
              shade: 'dark', shadeIntensity: 0.4, inverseColors: !1, type: 'vertical', opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100],
            },
          },
          tooltip: { theme: 'dark', fillSeriesColor: !0 },
          legend: { position: 'right' },
        };
      },
    }, {
      key: 'radar',
      value() {
        return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
          dataLabels: { enabled: !1, style: { fontSize: '11px' } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, grid: { show: !1 }, xaxis: { labels: { formatter(t) { return t; }, style: { colors: ['#a8a8a8'], fontSize: '11px' } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } },
        };
      },
    }, {
      key: 'radialBar',
      value() {
        return {
          chart: { animations: { dynamicAnimation: { enabled: !0, speed: 800 } }, toolbar: { show: !1 } },
          fill: {
            gradient: {
              shade: 'dark', shadeIntensity: 0.4, inverseColors: !1, type: 'diagonal2', opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100],
            },
          },
          legend: { show: !1, position: 'right' },
          tooltip: { enabled: !1, fillSeriesColor: !0 },
        };
      },
    }]), t;
  }()); const P = (function () { function i(t) { e(this, i), this.opts = t; } return a(i, [{ key: 'init', value(e) { const i = e.responsiveOverride; let a = this.opts; const s = new A(); const r = new L(a); this.chartType = a.chart.type, this.chartType === 'histogram' && (a.chart.type = 'bar', a = g.extend({ plotOptions: { bar: { columnWidth: '99.99%' } } }, a)), a = this.extendYAxis(a), a = this.extendAnnotations(a); let n = s.init(); let o = {}; if (a && t(a) === 'object') { let l = {}; l = ['line', 'area', 'bar', 'candlestick', 'rangeBar', 'histogram', 'bubble', 'scatter', 'heatmap', 'pie', 'donut', 'radar', 'radialBar'].indexOf(a.chart.type) !== -1 ? r[a.chart.type]() : r.line(), a.chart.brush && a.chart.brush.enabled && (l = r.brush(l)), a.chart.stacked && a.chart.stackType === '100%' && (a = r.stacked100(a)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a), a.xaxis = a.xaxis || window.Apex.xaxis || {}, i || (a.xaxis.convertedCatToNumeric = !1), ((a = this.checkForCatToNumericXAxis(this.chartType, l, a)).chart.sparkline && a.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (l = r.sparkline(l)), o = g.extend(n, l); } const h = g.extend(o, window.Apex); return n = g.extend(h, a), n = this.handleUserInputErrors(n); } }, { key: 'checkForCatToNumericXAxis', value(t, e, i) { const a = new L(i); const s = t === 'bar' && i.plotOptions && i.plotOptions.bar && i.plotOptions.bar.horizontal; const r = t === 'pie' || t === 'donut' || t === 'radar' || t === 'radialBar' || t === 'heatmap'; const n = i.xaxis.type !== 'datetime' && i.xaxis.type !== 'numeric'; const o = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : e.xaxis && e.xaxis.tickPlacement; return s || r || !n || o === 'between' || (i = a.convertCatToNumeric(i)), i; } }, { key: 'extendYAxis', value(t) { const e = new A(); (void 0 === t.yaxis || !t.yaxis || Array.isArray(t.yaxis) && t.yaxis.length === 0) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = g.extend(t.yaxis, window.Apex.yaxis)), t.yaxis.constructor !== Array ? t.yaxis = [g.extend(e.yAxis, t.yaxis)] : t.yaxis = g.extendArray(t.yaxis, e.yAxis); let i = !1; return t.yaxis.forEach(((t) => { t.logarithmic && (i = !0); })), i && t.series.length !== t.yaxis.length && t.series.length && (t.yaxis = t.series.map(((i, a) => { if (i.name || (t.series[a].name = 'series-'.concat(a + 1)), t.yaxis[a]) return t.yaxis[a].seriesName = t.series[a].name, t.yaxis[a]; const s = g.extend(e.yAxis, t.yaxis[0]); return s.show = !1, s; }))), i && t.series.length > 1 && t.series.length !== t.yaxis.length && console.warn('A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both.'), t; } }, { key: 'extendAnnotations', value(t) { return void 0 === t.annotations && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), t = this.extendPointAnnotations(t); } }, { key: 'extendYAxisAnnotations', value(t) { const e = new A(); return t.annotations.yaxis = g.extendArray(void 0 !== t.annotations.yaxis ? t.annotations.yaxis : [], e.yAxisAnnotation), t; } }, { key: 'extendXAxisAnnotations', value(t) { const e = new A(); return t.annotations.xaxis = g.extendArray(void 0 !== t.annotations.xaxis ? t.annotations.xaxis : [], e.xAxisAnnotation), t; } }, { key: 'extendPointAnnotations', value(t) { const e = new A(); return t.annotations.points = g.extendArray(void 0 !== t.annotations.points ? t.annotations.points : [], e.pointAnnotation), t; } }, { key: 'checkForDarkTheme', value(t) { t.theme && t.theme.mode === 'dark' && (t.tooltip || (t.tooltip = {}), t.tooltip.theme !== 'light' && (t.tooltip.theme = 'dark'), t.chart.foreColor || (t.chart.foreColor = '#f6f7f8'), t.theme.palette || (t.theme.palette = 'palette4')); } }, { key: 'handleUserInputErrors', value(t) { const e = t; if (e.tooltip.shared && e.tooltip.intersect) throw new Error('tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.'); if ((e.chart.type === 'bar' || e.chart.type === 'rangeBar') && e.plotOptions.bar.horizontal) { if (e.yaxis.length > 1) throw new Error('Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false'); e.yaxis[0].reversed && (e.yaxis[0].opposite = !0), e.xaxis.tooltip.enabled = !1, e.yaxis[0].tooltip.enabled = !1, e.chart.zoom.enabled = !1; } return e.chart.type !== 'bar' && e.chart.type !== 'rangeBar' || e.tooltip.shared && (e.xaxis.crosshairs.width === 'barWidth' && e.series.length > 1 && (console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.'), e.xaxis.crosshairs.width = 'tickWidth'), e.plotOptions.bar.horizontal && (e.states.hover.type = 'none', e.tooltip.shared = !1), e.tooltip.followCursor || (console.warn('followCursor option in shared columns cannot be turned off. Please set %ctooltip.followCursor: true', 'color: blue;'), e.tooltip.followCursor = !0)), e.chart.type === 'candlestick' && e.yaxis[0].reversed && (console.warn('Reversed y-axis in candlestick chart is not supported.'), e.yaxis[0].reversed = !1), e.chart.group && e.yaxis[0].labels.minWidth === 0 && console.warn('It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour.'), Array.isArray(e.stroke.width) && e.chart.type !== 'line' && e.chart.type !== 'area' && (console.warn('stroke.width option accepts array only for line and area charts. Reverted back to Number'), e.stroke.width = e.stroke.width[0]), e; } }]), i; }()); const T = (function () {
    function t() { e(this, t); } return a(t, [{ key: 'initGlobalVars', value(t) { t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRangeBarTimeline = [], t.seriesPercent = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.xaxisLabelsCount = 0, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.x2SpaceAvailable = 0, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0; } }, {
      key: 'globalVars',
      value(t) {
        return {
          chartID: null,
          cuid: null,
          events: {
            beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [],
          },
          colors: [],
          clientX: null,
          clientY: null,
          fill: { colors: [] },
          stroke: { colors: [] },
          dataLabels: { style: { colors: [] } },
          radarPolygons: { fill: { colors: [] } },
          markers: { colors: [], size: t.markers.size, largestSize: 0 },
          animationEnded: !1,
          isTouchDevice: 'ontouchstart' in window || navigator.msMaxTouchPoints,
          isDirty: !1,
          isExecCalled: !1,
          initialConfig: null,
          lastXAxis: [],
          lastYAxis: [],
          columnSeries: null,
          labels: [],
          timescaleLabels: [],
          noLabelsProvided: !1,
          allSeriesCollapsed: !1,
          collapsedSeries: [],
          collapsedSeriesIndices: [],
          ancillaryCollapsedSeries: [],
          ancillaryCollapsedSeriesIndices: [],
          risingSeries: [],
          dataFormatXNumeric: !1,
          capturedSeriesIndex: -1,
          capturedDataPointIndex: -1,
          selectedDataPoints: [],
          goldenPadding: 35,
          invalidLogScale: !1,
          ignoreYAxisIndexes: [],
          yAxisSameScaleIndices: [],
          maxValsInArrayIndex: 0,
          radialSize: 0,
          zoomEnabled: t.chart.toolbar.autoSelected === 'zoom' && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled,
          panEnabled: t.chart.toolbar.autoSelected === 'pan' && t.chart.toolbar.tools.pan,
          selectionEnabled: t.chart.toolbar.autoSelected === 'selection' && t.chart.toolbar.tools.selection,
          yaxis: null,
          mousedown: !1,
          lastClientPosition: {},
          visibleXRange: void 0,
          yValueDecimal: 0,
          total: 0,
          SVGNS: 'http://www.w3.org/2000/svg',
          svgWidth: 0,
          svgHeight: 0,
          noData: !1,
          locale: {},
          dom: {},
          memory: { methodsToExec: [] },
          shouldAnimate: !0,
          skipLastTimelinelabel: !1,
          skipFirstTimelinelabel: !1,
          delayedElements: [],
          axisCharts: !0,
          isDataXYZ: !1,
          resized: !1,
          resizeTimer: null,
          comboCharts: !1,
          dataChanged: !1,
          previousPaths: [],
          allSeriesHasEqualX: !0,
          pointsArray: [],
          dataLabelsRects: [],
          lastDrawnDataLabelsIndexes: [],
          x2SpaceAvailable: 0,
          hasNullValues: !1,
          easing: null,
          zoomed: !1,
          gridWidth: 0,
          gridHeight: 0,
          rotateXLabels: !1,
          defaultLabels: !1,
          xLabelFormatter: void 0,
          yLabelFormatters: [],
          xaxisTooltipFormatter: void 0,
          ttKeyFormatter: void 0,
          ttVal: void 0,
          ttZFormatter: void 0,
          LINE_HEIGHT_RATIO: 1.618,
          xAxisLabelsHeight: 0,
          yAxisLabelsWidth: 0,
          scaleX: 1,
          scaleY: 1,
          translateX: 0,
          translateY: 0,
          translateYAxisX: [],
          yAxisWidths: [],
          translateXAxisY: 0,
          translateXAxisX: 0,
          tooltip: null,
        };
      },
    }, { key: 'init', value(t) { const e = this.globalVars(t); return this.initGlobalVars(e), e.initialConfig = g.extend({}, t), e.initialSeries = JSON.parse(JSON.stringify(e.initialConfig.series)), e.lastXAxis = JSON.parse(JSON.stringify(e.initialConfig.xaxis)), e.lastYAxis = JSON.parse(JSON.stringify(e.initialConfig.yaxis)), e; } }]), t;
  }()); const z = (function () { function t(i) { e(this, t), this.opts = i; } return a(t, [{ key: 'init', value() { const t = new P(this.opts).init({ responsiveOverride: !1 }); return { config: t, globals: (new T()).init(t) }; } }]), t; }()); const I = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'getStackedSeriesTotals', value() { const t = this.w; const e = []; if (t.globals.series.length === 0) return e; for (let i = 0; i < t.globals.series[t.globals.maxValsInArrayIndex].length; i++) { for (var a = 0, s = 0; s < t.globals.series.length; s++) void 0 !== t.globals.series[s][i] && (a += t.globals.series[s][i]); e.push(a); } return t.globals.stackedSeriesTotals = e, e; } }, { key: 'getSeriesTotalByIndex', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; return t === null ? this.w.config.series.reduce(((t, e) => t + e), 0) : this.w.globals.series[t].reduce(((t, e) => t + e), 0); } }, { key: 'isSeriesNull', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; return (t === null ? this.w.config.series.filter(((t) => t !== null)) : this.w.globals.series[t].filter(((t) => t !== null))).length === 0; } }, { key: 'seriesHaveSameValues', value(t) { return this.w.globals.series[t].every(((t, e, i) => t === i[0])); } }, { key: 'getCategoryLabels', value(t) { const e = this.w; let i = t.slice(); return e.config.xaxis.convertedCatToNumeric && (i = t.map(((t) => e.config.xaxis.labels.formatter(t - e.globals.minX + 1)))), i; } }, { key: 'getLargestSeries', value() { const t = this.w; t.globals.maxValsInArrayIndex = t.globals.series.map(((t) => t.length)).indexOf(Math.max.apply(Math, t.globals.series.map(((t) => t.length)))); } }, { key: 'getLargestMarkerSize', value() { const t = this.w; let e = 0; return t.globals.markers.size.forEach(((t) => { e = Math.max(e, t); })), t.globals.markers.largestSize = e, e; } }, { key: 'getSeriesTotals', value() { const t = this.w; t.globals.seriesTotals = t.globals.series.map(((t, e) => { let i = 0; if (Array.isArray(t)) for (let a = 0; a < t.length; a++)i += t[a]; else i += t; return i; })); } }, { key: 'getSeriesTotalsXRange', value(t, e) { const i = this.w; return i.globals.series.map(((a, s) => { for (var r = 0, n = 0; n < a.length; n++)i.globals.seriesX[s][n] > t && i.globals.seriesX[s][n] < e && (r += a[n]); return r; })); } }, { key: 'getPercentSeries', value() { const t = this.w; t.globals.seriesPercent = t.globals.series.map(((e, i) => { const a = []; if (Array.isArray(e)) for (let s = 0; s < e.length; s++) { const r = t.globals.stackedSeriesTotals[s]; let n = 0; r && (n = 100 * e[s] / r), a.push(n); } else { const o = 100 * e / t.globals.seriesTotals.reduce(((t, e) => t + e), 0); a.push(o); } return a; })); } }, {
      key: 'getCalculatedRatios',
      value() {
        let t; let e; let i; let a; const s = this.w.globals; const r = []; let n = 0; let o = []; let l = 0.1; let h = 0; if (s.yRange = [], s.isMultipleYAxis) for (let c = 0; c < s.minYArr.length; c++)s.yRange.push(Math.abs(s.minYArr[c] - s.maxYArr[c])), o.push(0); else s.yRange.push(Math.abs(s.minY - s.maxY)); s.xRange = Math.abs(s.maxX - s.minX), s.zRange = Math.abs(s.maxZ - s.minZ); for (let d = 0; d < s.yRange.length; d++)r.push(s.yRange[d] / s.gridHeight); if (e = s.xRange / s.gridWidth, i = Math.abs(s.initialMaxX - s.initialMinX) / s.gridWidth, t = s.yRange / s.gridWidth, a = s.xRange / s.gridHeight, (n = s.zRange / s.gridHeight * 16) || (n = 1), s.minY !== Number.MIN_VALUE && Math.abs(s.minY) !== 0 && (s.hasNegs = !0), s.isMultipleYAxis) { o = []; for (let g = 0; g < r.length; g++)o.push(-s.minYArr[g] / r[g]); } else o.push(-s.minY / r[0]), s.minY !== Number.MIN_VALUE && Math.abs(s.minY) !== 0 && (l = -s.minY / t, h = s.minX / e); return {
          yRatio: r, invertedYRatio: t, zRatio: n, xRatio: e, initialXRatio: i, invertedXRatio: a, baseLineInvertedY: l, baseLineY: o, baseLineX: h,
        };
      },
    }, { key: 'getLogSeries', value(t) { const e = this.w; return e.globals.seriesLog = t.map(((t, i) => (e.config.yaxis[i] && e.config.yaxis[i].logarithmic ? t.map(((t) => null===t?null:(Math.log(t)-Math.log(e.globals.minYArr[i]))/(Math.log(e.globals.maxYArr[i])-Math.log(e.globals.minYArr[i])))) : t))), e.globals.invalidLogScale ? t : e.globals.seriesLog; } }, { key: 'getLogYRatios', value(t) { const e = this; const i = this.w; const a = this.w.globals; return a.yLogRatio = t.slice(), a.logYRange = a.yRange.map(((t, s) => { if (i.config.yaxis[s] && e.w.config.yaxis[s].logarithmic) { let r; let n = -Number.MAX_VALUE; let o = Number.MIN_VALUE; return a.seriesLog.forEach(((t, e) => { t.forEach(((t) => { i.config.yaxis[e] && i.config.yaxis[e].logarithmic && (n = Math.max(t, n), o = Math.min(t, o)); })); })), r = Math.pow(a.yRange[s], Math.abs(o - n) / a.yRange[s]), a.yLogRatio[s] = r / a.gridHeight, r; } })), a.invalidLogScale ? t.slice() : a.yLogRatio; } }], [{ key: 'checkComboSeries', value(t) { let e = !1; let i = 0; return t.length && void 0 !== t[0].type && (e = !0, t.forEach(((t) => { t.type !== 'bar' && t.type !== 'column' && t.type !== 'candlestick' || i++; }))), { comboBarCount: i, comboCharts: e }; } }, { key: 'extendArrayProps', value(t, e) { return e.yaxis && (e = t.extendYAxis(e)), e.annotations && (e.annotations.yaxis && (e = t.extendYAxisAnnotations(e)), e.annotations.xaxis && (e = t.extendXAxisAnnotations(e)), e.annotations.points && (e = t.extendPointAnnotations(e))), e; } }]), t;
  }()); const M = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.opts = null, this.seriesIndex = 0; } return a(t, [{
      key: 'clippedImgArea',
      value(t) {
        const e = this.w; const i = e.config; const a = parseInt(e.globals.gridWidth, 10); const s = parseInt(e.globals.gridHeight, 10); const r = a > s ? a : s; const n = t.image; let o = 0; let l = 0; void 0 === t.width && void 0 === t.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o = i.fill.image.width + 1, l = i.fill.image.height) : (o = r + 1, l = r) : (o = t.width, l = t.height); const h = document.createElementNS(e.globals.SVGNS, 'pattern'); p.setAttrs(h, {
          id: t.patternID, patternUnits: t.patternUnits ? t.patternUnits : 'userSpaceOnUse', width: `${o}px`, height: `${l}px`,
        }); const c = document.createElementNS(e.globals.SVGNS, 'image'); h.appendChild(c), c.setAttributeNS(window.SVG.xlink, 'href', n), p.setAttrs(c, {
          x: 0, y: 0, preserveAspectRatio: 'none', width: `${o}px`, height: `${l}px`,
        }), c.style.opacity = t.opacity, e.globals.dom.elDefs.node.appendChild(h);
      },
    }, { key: 'getSeriesIndex', value(t) { const e = this.w; return (e.config.chart.type === 'bar' || e.config.chart.type === 'rangeBar') && e.config.plotOptions.bar.distributed || e.config.chart.type === 'heatmap' ? this.seriesIndex = t.seriesNumber : this.seriesIndex = t.seriesNumber % e.globals.series.length, this.seriesIndex; } }, {
      key: 'fillPath',
      value(t) {
        const e = this.w; this.opts = t; let i; let a; let s; const r = this.w.config; this.seriesIndex = this.getSeriesIndex(t); let n = this.getFillColors()[this.seriesIndex]; typeof n === 'function' && (n = n({
          seriesIndex: this.seriesIndex, dataPointIndex: t.dataPointIndex, value: t.value, w: e,
        })); const o = this.getFillType(this.seriesIndex); let l = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity; let h = n; if (t.color && (n = t.color), n.indexOf('rgb') === -1 ? h = g.hexToRgba(n, l) : n.indexOf('rgba') > -1 && (l = `0.${g.getOpacityFromRGBA(n)}`), t.opacity && (l = t.opacity), o === 'pattern' && (a = this.handlePatternFill(a, n, l, h)), o === 'gradient' && (s = this.handleGradientFill(s, n, l, this.seriesIndex)), o === 'image') {
          const c = r.fill.image.src; const d = t.patternID ? t.patternID : ''; this.clippedImgArea({
            opacity: l, image: Array.isArray(c) ? t.seriesNumber < c.length ? c[t.seriesNumber] : c[0] : c, width: t.width ? t.width : void 0, height: t.height ? t.height : void 0, patternUnits: t.patternUnits, patternID: 'pattern'.concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d),
          }), i = 'url(#pattern'.concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d, ')');
        } else i = o === 'gradient' ? s : o === 'pattern' ? a : h; return t.solid && (i = h), i;
      },
    }, { key: 'getFillType', value(t) { const e = this.w; return Array.isArray(e.config.fill.type) ? e.config.fill.type[t] : e.config.fill.type; } }, { key: 'getFillColors', value() { const t = this.w; const e = t.config; const i = this.opts; let a = []; return t.globals.comboCharts ? t.config.series[this.seriesIndex].type === 'line' ? t.globals.stroke.colors instanceof Array ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : t.globals.fill.colors instanceof Array ? a = t.globals.fill.colors : a.push(t.globals.fill.colors) : e.chart.type === 'line' ? t.globals.stroke.colors instanceof Array ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : t.globals.fill.colors instanceof Array ? a = t.globals.fill.colors : a.push(t.globals.fill.colors), void 0 !== i.fillColors && (a = [], i.fillColors instanceof Array ? a = i.fillColors.slice() : a.push(i.fillColors)), a; } }, { key: 'handlePatternFill', value(t, e, i, a) { const s = this.w.config; const r = this.opts; const n = new p(this.ctx); const o = void 0 === s.fill.pattern.strokeWidth ? Array.isArray(s.stroke.width) ? s.stroke.width[this.seriesIndex] : s.stroke.width : Array.isArray(s.fill.pattern.strokeWidth) ? s.fill.pattern.strokeWidth[this.seriesIndex] : s.fill.pattern.strokeWidth; const l = e; s.fill.pattern.style instanceof Array ? t = void 0 !== s.fill.pattern.style[r.seriesNumber] ? n.drawPattern(s.fill.pattern.style[r.seriesNumber], s.fill.pattern.width, s.fill.pattern.height, l, o, i) : a : t = n.drawPattern(s.fill.pattern.style, s.fill.pattern.width, s.fill.pattern.height, l, o, i); return t; } }, { key: 'handleGradientFill', value(t, e, i, a) { let s; let r; const n = this.w.config; const o = this.opts; const l = new p(this.ctx); const h = new g(); const c = n.fill.gradient.type; const d = void 0 === n.fill.gradient.opacityFrom ? i : Array.isArray(n.fill.gradient.opacityFrom) ? n.fill.gradient.opacityFrom[a] : n.fill.gradient.opacityFrom; const u = void 0 === n.fill.gradient.opacityTo ? i : Array.isArray(n.fill.gradient.opacityTo) ? n.fill.gradient.opacityTo[a] : n.fill.gradient.opacityTo; if (s = e, r = void 0 === n.fill.gradient.gradientToColors || n.fill.gradient.gradientToColors.length === 0 ? n.fill.gradient.shade === 'dark' ? h.shadeColor(-1 * parseFloat(n.fill.gradient.shadeIntensity), e) : h.shadeColor(parseFloat(n.fill.gradient.shadeIntensity), e) : n.fill.gradient.gradientToColors[o.seriesNumber], n.fill.gradient.inverseColors) { const f = s; s = r, r = f; } return l.drawGradient(c, s, r, d, u, o.size, n.fill.gradient.stops, n.fill.gradient.colorStops, a); } }]), t;
  }()); const X = (function () {
    function t(i, a) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'setGlobalMarkerSize', value() { const t = this.w; if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) { if (t.globals.markers.size.length < t.globals.series.length + 1) for (let e = 0; e <= t.globals.series.length; e++) void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0]); } else t.globals.markers.size = t.config.series.map(((e) => t.config.markers.size)); } }, { key: 'plotChartMarkers', value(t, e, i, a) { let s; const r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; const n = this.w; const o = e; const l = t; let h = null; const c = new p(this.ctx); if ((n.globals.markers.size[e] > 0 || r) && (h = c.group({ class: r ? '' : 'apexcharts-series-markers' })).attr('clip-path', 'url(#gridRectMarkerMask'.concat(n.globals.cuid, ')')), l.x instanceof Array) for (let d = 0; d < l.x.length; d++) { let f = i; i === 1 && d === 0 && (f = 0), i === 1 && d === 1 && (f = 1); let x = 'apexcharts-marker'; n.config.chart.type !== 'line' && n.config.chart.type !== 'area' || n.globals.comboCharts || n.config.tooltip.intersect || (x += ' no-pointer-events'); const b = Array.isArray(n.config.markers.size) ? n.globals.markers.size[e] > 0 : n.config.markers.size > 0; if (b || r) { g.isNumber(l.y[d]) ? x += ' w'.concat(g.randomId()) : x = 'apexcharts-nullpoint'; const m = this.getMarkerConfig(x, e, f); n.config.series[o].data[i] && (n.config.series[o].data[i].fillColor && (m.pointFillColor = n.config.series[o].data[i].fillColor), n.config.series[o].data[i].strokeColor && (m.pointStrokeColor = n.config.series[o].data[i].strokeColor)), a && (m.pSize = a), (s = c.drawMarker(l.x[d], l.y[d], m)).attr('rel', f), s.attr('j', f), s.attr('index', e), s.node.setAttribute('default-marker-size', m.pSize); const v = new u(this.ctx); v.setSelectionFilter(s, e, f), this.addEvents(s), h && h.add(s); } else void 0 === n.globals.pointsArray[e] && (n.globals.pointsArray[e] = []), n.globals.pointsArray[e].push([l.x[d], l.y[d]]); } return h; } }, {
      key: 'getMarkerConfig',
      value(t, e) {
        const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const a = this.w; const s = this.getMarkerStyle(e); let r = a.globals.markers.size[e]; const n = a.config.markers; return i !== null && n.discrete.length && n.discrete.map(((t) => { t.seriesIndex === e && t.dataPointIndex === i && (s.pointStrokeColor = t.strokeColor, s.pointFillColor = t.fillColor, r = t.size); })), {
          pSize: r, pRadius: n.radius, pWidth: n.strokeWidth instanceof Array ? n.strokeWidth[e] : n.strokeWidth, pointStrokeColor: s.pointStrokeColor, pointFillColor: s.pointFillColor, shape: n.shape instanceof Array ? n.shape[e] : n.shape, class: t, pointStrokeOpacity: n.strokeOpacity instanceof Array ? n.strokeOpacity[e] : n.strokeOpacity, pointStrokeDashArray: n.strokeDashArray instanceof Array ? n.strokeDashArray[e] : n.strokeDashArray, pointFillOpacity: n.fillOpacity instanceof Array ? n.fillOpacity[e] : n.fillOpacity, seriesIndex: e,
        };
      },
    }, { key: 'addEvents', value(t) { const e = this.w; const i = new p(this.ctx); t.node.addEventListener('mouseenter', i.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener('mouseleave', i.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener('mousedown', i.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener('click', e.config.markers.onClick), t.node.addEventListener('dblclick', e.config.markers.onDblClick), t.node.addEventListener('touchstart', i.pathMouseDown.bind(this.ctx, t), { passive: !0 }); } }, { key: 'getMarkerStyle', value(t) { const e = this.w; const i = e.globals.markers.colors; const a = e.config.markers.strokeColor || e.config.markers.strokeColors; return { pointStrokeColor: a instanceof Array ? a[t] : a, pointFillColor: i instanceof Array ? i[t] : i }; } }]), t;
  }()); const E = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled; } return a(t, [{ key: 'draw', value(t, e, i) { const a = this.w; const s = new p(this.ctx); const r = i.realIndex; const n = i.pointsPos; const o = i.zRatio; const l = i.elParent; const h = s.group({ class: 'apexcharts-series-markers apexcharts-series-'.concat(a.config.chart.type) }); if (h.attr('clip-path', 'url(#gridRectMarkerMask'.concat(a.globals.cuid, ')')), n.x instanceof Array) for (let c = 0; c < n.x.length; c++) { let d = e + 1; let g = !0; e === 0 && c === 0 && (d = 0), e === 0 && c === 1 && (d = 1); let u = 0; let f = a.globals.markers.size[r]; if (o !== 1 / 0) { f = a.globals.seriesZ[r][d] / o; const x = a.config.plotOptions.bubble; x.minBubbleRadius && f < x.minBubbleRadius && (f = x.minBubbleRadius), x.maxBubbleRadius && f > x.maxBubbleRadius && (f = x.maxBubbleRadius); }a.config.chart.animations.enabled || (u = f); const b = n.x[c]; const m = n.y[c]; if (u = u || 0, m !== null && void 0 !== a.globals.series[r][d] || (g = !1), g) { const v = this.drawPoint(b, m, u, f, r, d, e); h.add(v); }l.add(h); } } }, {
      key: 'drawPoint',
      value(t, e, i, a, s, r, n) {
        const o = this.w; const l = s; const h = new f(this.ctx); const c = new u(this.ctx); const d = new M(this.ctx); const g = new X(this.ctx); const x = new p(this.ctx); const b = g.getMarkerConfig('apexcharts-marker', l); let m = d.fillPath({
          seriesNumber: s, dataPointIndex: r, patternUnits: 'objectBoundingBox', value: o.globals.series[s][n],
        }); const v = x.drawCircle(i); if (o.config.series[l].data[r] && o.config.series[l].data[r].fillColor && (m = o.config.series[l].data[r].fillColor), v.attr({
          cx: t, cy: e, fill: m, stroke: b.pointStrokeColor, 'stroke-width': b.pWidth, 'stroke-dasharray': b.pointStrokeDashArray, 'stroke-opacity': b.pointStrokeOpacity,
        }), o.config.chart.dropShadow.enabled) { const y = o.config.chart.dropShadow; c.dropShadow(v, y, s); } if (this.initialAnim && !o.globals.dataChanged) { let w = 1; o.globals.resized || (w = o.config.chart.animations.speed), h.animateCircleRadius(v, 0, a, w, o.globals.easing, (() => { window.setTimeout((() => { h.animationCompleted(v); }), 100); })); } if (o.globals.dataChanged) if (this.dynamicAnim) { let k; let A; let S; let C; let L = o.config.chart.animations.dynamicAnimation.speed; (C = o.globals.previousPaths[s] && o.globals.previousPaths[s][n]) != null && (k = C.x, A = C.y, S = void 0 !== C.r ? C.r : a); for (let P = 0; P < o.globals.collapsedSeries.length; P++)o.globals.collapsedSeries[P].index === s && (L = 1, a = 0); t === 0 && e === 0 && (a = 0), h.animateCircle(v, { cx: k, cy: A, r: S }, { cx: t, cy: e, r: a }, L, o.globals.easing); } else v.attr({ r: a }); return v.attr({
          rel: r, j: r, index: s, 'default-marker-size': a,
        }), c.setSelectionFilter(v, s, r), g.addEvents(v), v.node.classList.add('apexcharts-marker'), v;
      },
    }, { key: 'centerTextInBubble', value(t) { const e = this.w; return { y: t += parseInt(e.config.dataLabels.style.fontSize, 10) / 4 }; } }]), t;
  }()); const Y = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{
      key: 'dataLabelsCorrection',
      value(t, e, i, a, s, r, n) {
        const o = this.w; let l = !1; const h = new p(this.ctx).getTextRects(i, n); const c = h.width; const d = h.height; void 0 === o.globals.dataLabelsRects[a] && (o.globals.dataLabelsRects[a] = []), o.globals.dataLabelsRects[a].push({
          x: t, y: e, width: c, height: d,
        }); const g = o.globals.dataLabelsRects[a].length - 2; const u = void 0 !== o.globals.lastDrawnDataLabelsIndexes[a] ? o.globals.lastDrawnDataLabelsIndexes[a][o.globals.lastDrawnDataLabelsIndexes[a].length - 1] : 0; if (void 0 !== o.globals.dataLabelsRects[a][g]) { const f = o.globals.dataLabelsRects[a][u]; (t > f.x + f.width + 2 || e > f.y + f.height + 2 || t + c < f.x) && (l = !0); } return (s === 0 || r) && (l = !0), {
          x: t, y: e, textRects: h, drawnextLabel: l,
        };
      },
    }, {
      key: 'drawDataLabel',
      value(t, e, i) {
        const a = this; const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2; const r = this.w; const n = new p(this.ctx); const o = r.config.dataLabels; let l = 0; let h = 0; let c = i; let d = null; if (!o.enabled || t.x instanceof Array != !0) return d; d = n.group({ class: 'apexcharts-data-labels' }); for (let g = 0; g < t.x.length; g++) {
 if (l = t.x[g] + o.offsetX, h = t.y[g] + o.offsetY + s, !isNaN(l)) {
          i === 1 && g === 0 && (c = 0), i === 1 && g === 1 && (c = 1); let u = r.globals.series[e][c]; let f = ''; const x = function (t) {
            return r.config.dataLabels.formatter(t, {
              ctx: a.ctx, seriesIndex: e, dataPointIndex: c, w: r,
            });
          }; if (r.config.chart.type === 'bubble') { f = x(u = r.globals.seriesZ[e][c]), h = t.y[g]; const b = new E(this.ctx); const m = b.centerTextInBubble(h, e, c); h = m.y; } else void 0 !== u && (f = x(u)); this.plotDataLabelsText({
            x: l, y: h, text: f, i: e, j: c, parent: d, offsetCorrection: !0, dataLabelsConfig: r.config.dataLabels,
          });
        } 
} return d;
      },
    }, {
      key: 'plotDataLabelsText',
      value(t) {
        const e = this.w; const i = new p(this.ctx); let a = t.x; let s = t.y; const r = t.i; const n = t.j; let o = t.text; const l = t.textAnchor; const h = t.parent; const c = t.dataLabelsConfig; const d = t.color; const g = t.alwaysDrawDataLabel; const f = t.offsetCorrection; if (!(Array.isArray(e.config.dataLabels.enabledOnSeries) && e.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
          let x = { x: a, y: s, drawnextLabel: !0 }; f && (x = this.dataLabelsCorrection(a, s, o, r, n, g, parseInt(c.style.fontSize, 10))), e.globals.zoomed || (a = x.x, s = x.y), x.textRects && (a + x.textRects.width < 10 || a > e.globals.gridWidth + 10) && (o = ''); let b = e.globals.dataLabels.style.colors[r]; if (e.config.chart.type !== 'bar' && e.config.chart.type !== 'rangeBar' || !e.config.plotOptions.bar.distributed || (b = e.globals.dataLabels.style.colors[n]), d && (b = d), x.drawnextLabel) {
            const m = i.drawText({
              width: 100, height: parseInt(c.style.fontSize, 10), x: a + c.offsetX, y: s + c.offsetY, foreColor: b, textAnchor: l || c.textAnchor, text: o, fontSize: c.style.fontSize, fontFamily: c.style.fontFamily, fontWeight: c.style.fontWeight || 'normal',
            }); if (m.attr({ class: 'apexcharts-datalabel', cx: a, cy: s }), c.dropShadow.enabled) { const v = c.dropShadow; new u(this.ctx).dropShadow(m, v); }h.add(m), void 0 === e.globals.lastDrawnDataLabelsIndexes[r] && (e.globals.lastDrawnDataLabelsIndexes[r] = []), e.globals.lastDrawnDataLabelsIndexes[r].push(n);
          }
        }
      },
    }, { key: 'addBackgroundToDataLabel', value(t, e) { const i = this.w; const a = i.config.dataLabels.background; const s = a.padding; const r = a.padding / 2; const n = e.width; const o = e.height; return new p(this.ctx).drawRect(e.x - s, e.y - r / 2, n + 2 * s, o + r, a.borderRadius, i.config.chart.background === 'transparent' ? '#fff' : i.config.chart.background, a.opacity, a.borderWidth, a.borderColor); } }, { key: 'dataLabelsBackground', value() { const t = this.w; const e = t.config.chart.type; if (e !== 'bar' && e !== 'rangeBar' && e !== 'bubble') for (let i = t.globals.dom.baseEl.querySelectorAll('.apexcharts-datalabels text'), a = 0; a < i.length; a++) { const s = i[a]; const r = s.getBBox(); let n = null; if (r.width && r.height && (n = this.addBackgroundToDataLabel(s, r)), n) { s.parentNode.insertBefore(n.node, s); const o = s.getAttribute('fill'); t.config.chart.animations.enabled && !t.globals.resized && !t.globals.dataChanged ? n.animate().attr({ fill: o }) : n.attr({ fill: o }), s.setAttribute('fill', t.config.dataLabels.background.foreColor); } } } }, { key: 'bringForward', value() { for (let t = this.w, e = t.globals.dom.baseEl.querySelectorAll('.apexcharts-datalabels'), i = t.globals.dom.baseEl.querySelector('.apexcharts-plot-series:last-child'), a = 0; a < e.length; a++)i && i.insertBefore(e[a], i.nextSibling); } }]), t;
  }()); const F = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.legendInactiveClass = 'legend-mouseover-inactive'; } return a(t, [{ key: 'getAllSeriesEls', value() { return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series'); } }, { key: 'getSeriesByName', value(t) { return this.w.globals.dom.baseEl.querySelector("[seriesName='".concat(g.escapeString(t), "']")); } }, { key: 'isSeriesHidden', value(t) { const e = this.getSeriesByName(t); const i = parseInt(e.getAttribute('data:realIndex'), 10); return { isHidden: e.classList.contains('apexcharts-series-collapsed'), realIndex: i }; } }, { key: 'addCollapsedClassToSeries', value(t, e) { const i = this.w; function a(i) { for (let a = 0; a < i.length; a++)i[a].index === e && t.node.classList.add('apexcharts-series-collapsed'); }a(i.globals.collapsedSeries), a(i.globals.ancillaryCollapsedSeries); } }, { key: 'toggleSeries', value(t) { const e = this.isSeriesHidden(t); return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden; } }, { key: 'showSeries', value(t) { const e = this.isSeriesHidden(t); e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0); } }, { key: 'hideSeries', value(t) { const e = this.isSeriesHidden(t); e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1); } }, { key: 'resetSeries', value() { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = this.w; const a = i.globals.initialSeries.slice(); i.config.series = a, i.globals.collapsedSeries = [], i.globals.ancillaryCollapsedSeries = [], i.globals.collapsedSeriesIndices = [], i.globals.ancillaryCollapsedSeriesIndices = [], i.globals.previousPaths = [], t && (e && (i.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(a, i.config.chart.animations.dynamicAnimation.enabled)); } }, { key: 'toggleSeriesOnHover', value(t, e) { const i = this.w; const a = i.globals.dom.baseEl.querySelectorAll('.apexcharts-series, .apexcharts-datalabels'); if (t.type === 'mousemove') { const s = parseInt(e.getAttribute('rel'), 10) - 1; let r = null; let n = null; i.globals.axisCharts || i.config.chart.type === 'radialBar' ? i.globals.axisCharts ? (r = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s, "']")), n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s, "']"))) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "']")) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "'] path")); for (let o = 0; o < a.length; o++)a[o].classList.add(this.legendInactiveClass); r !== null && (i.globals.axisCharts || r.parentNode.classList.remove(this.legendInactiveClass), r.classList.remove(this.legendInactiveClass), n !== null && n.classList.remove(this.legendInactiveClass)); } else if (t.type === 'mouseout') for (let l = 0; l < a.length; l++)a[l].classList.remove(this.legendInactiveClass); } }, { key: 'highlightRangeInSeries', value(t, e) { const i = this; const a = this.w; const s = a.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap-rect'); const r = function (t) { for (let e = 0; e < s.length; e++)s[e].classList[t](i.legendInactiveClass); }; if (t.type === 'mousemove') { const n = parseInt(e.getAttribute('rel'), 10) - 1; r('add'), (function (t) { for (let e = 0; e < s.length; e++) { const a = parseInt(s[e].getAttribute('val'), 10); a >= t.from && a <= t.to && s[e].classList.remove(i.legendInactiveClass); } }(a.config.plotOptions.heatmap.colorScale.ranges[n])); } else t.type === 'mouseout' && r('remove'); } }, { key: 'getActiveConfigSeriesIndex', value() { const t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; const e = this.w; let i = 0; if (e.config.series.length > 1) for (let a = e.config.series.map(((i, a) => { let s = !1; return t && (s = e.config.series[a].type === 'bar' || e.config.series[a].type === 'column'), i.data && i.data.length > 0 && !s ? a : -1; })), s = 0; s < a.length; s++) if (a[s] !== -1) { i = a[s]; break; } return i; } }, { key: 'getPreviousPaths', value() { const t = this.w; function e(e, i, a) { for (var s = e[i].childNodes, r = { type: a, paths: [], realIndex: e[i].getAttribute('data:realIndex') }, n = 0; n < s.length; n++) if (s[n].hasAttribute('pathTo')) { const o = s[n].getAttribute('pathTo'); r.paths.push({ d: o }); }t.globals.previousPaths.push(r); }t.globals.previousPaths = []; ['line', 'area', 'bar', 'candlestick', 'radar'].forEach(((i) => { for (var a, s = (a = i, t.globals.dom.baseEl.querySelectorAll('.apexcharts-'.concat(a, '-series .apexcharts-series'))), r = 0; r < s.length; r++)e(s, r, i); })), this.handlePrevBubbleScatterPaths('bubble'), this.handlePrevBubbleScatterPaths('scatter'); const i = t.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap .apexcharts-series'); if (i.length > 0) for (let a = 0; a < i.length; a++) { for (var s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series[data\\:realIndex='".concat(a, "'] rect")), r = [], n = 0; n < s.length; n++)r.push({ color: s[n].getAttribute('color') }); t.globals.previousPaths.push(r); }t.globals.axisCharts || (t.globals.previousPaths = t.globals.series); } }, { key: 'handlePrevBubbleScatterPaths', value(t) { const e = this.w; const i = e.globals.dom.baseEl.querySelectorAll('.apexcharts-'.concat(t, '-series .apexcharts-series')); if (i.length > 0) for (let a = 0; a < i.length; a++) { for (var s = e.globals.dom.baseEl.querySelectorAll('.apexcharts-'.concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(a, "'] circle")), r = [], n = 0; n < s.length; n++)r.push({ x: s[n].getAttribute('cx'), y: s[n].getAttribute('cy'), r: s[n].getAttribute('r') }); e.globals.previousPaths.push(r); } } }, { key: 'clearPreviousPaths', value() { const t = this.w; t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1, t.globals.collapsedSeries = [], t.globals.collapsedSeriesIndices = []; } }, {
      key: 'handleNoData',
      value() {
        const t = this.w; const e = t.config.noData; const i = new p(this.ctx); let a = t.globals.svgWidth / 2; let s = t.globals.svgHeight / 2; let r = 'middle'; if (t.globals.noData = !0, t.globals.animationEnded = !0, e.align === 'left' ? (a = 10, r = 'start') : e.align === 'right' && (a = t.globals.svgWidth - 10, r = 'end'), e.verticalAlign === 'top' ? s = 50 : e.verticalAlign === 'bottom' && (s = t.globals.svgHeight - 50), a += e.offsetX, s = s + parseInt(e.style.fontSize, 10) + 2 + e.offsetY, void 0 !== e.text && e.text !== '') {
          const n = i.drawText({
            x: a, y: s, text: e.text, textAnchor: r, fontSize: e.style.fontSize, fontFamily: e.style.fontFamily, foreColor: e.style.color, opacity: 1, class: 'apexcharts-text-nodata',
          }); t.globals.dom.Paper.add(n);
        }
      },
    }, { key: 'setNullSeriesToZeroValues', value(t) { for (let e = this.w, i = 0; i < t.length; i++) if (t[i].length === 0) for (let a = 0; a < t[e.globals.maxValsInArrayIndex].length; a++)t[i].push(0); return t; } }, { key: 'hasAllSeriesEqualX', value() { for (var t = !0, e = this.w, i = this.filteredSeriesX(), a = 0; a < i.length - 1; a++) if (i[a][0] !== i[a + 1][0]) { t = !1; break; } return e.globals.allSeriesHasEqualX = t, t; } }, { key: 'filteredSeriesX', value() { const t = this.w.globals.seriesX.map(((t) => (t.length > 0 ? t : []))); return t; } }]), t;
  }()); const D = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.coreUtils = new I(this.ctx); } return a(t, [{ key: 'isMultiFormat', value() { return this.isFormatXY() || this.isFormat2DArray(); } }, { key: 'isFormatXY', value() { const t = this.w.config.series.slice(); const e = new F(this.ctx); if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && t[this.activeSeriesIndex].data[0] !== null && void 0 !== t[this.activeSeriesIndex].data[0].x && t[this.activeSeriesIndex].data[0] !== null) return !0; } }, { key: 'isFormat2DArray', value() { const t = this.w.config.series.slice(); const e = new F(this.ctx); if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && void 0 !== t[this.activeSeriesIndex].data[0] && t[this.activeSeriesIndex].data[0] !== null && t[this.activeSeriesIndex].data[0].constructor === Array) return !0; } }, { key: 'handleFormat2DArray', value(t, e) { for (var i = this.w.config, a = this.w.globals, s = 0; s < t[e].data.length; s++) if (void 0 !== t[e].data[s][1] && (Array.isArray(t[e].data[s][1]) && t[e].data[s][1].length === 4 ? this.twoDSeries.push(g.parseNumber(t[e].data[s][1][3])) : t[e].data[s].length === 5 ? this.twoDSeries.push(g.parseNumber(t[e].data[s][4])) : this.twoDSeries.push(g.parseNumber(t[e].data[s][1])), a.dataFormatXNumeric = !0), i.xaxis.type === 'datetime') { let r = new Date(t[e].data[s][0]); r = new Date(r).getTime(), this.twoDSeriesX.push(r); } else this.twoDSeriesX.push(t[e].data[s][0]); for (let n = 0; n < t[e].data.length; n++) void 0 !== t[e].data[n][2] && (this.threeDSeries.push(t[e].data[n][2]), a.isDataXYZ = !0); } }, { key: 'handleFormatXY', value(t, e) { const i = this.w.config; const a = this.w.globals; const s = new C(this.ctx); let r = e; a.collapsedSeriesIndices.indexOf(e) > -1 && (r = this.activeSeriesIndex); for (let n = 0; n < t[e].data.length; n++) void 0 !== t[e].data[n].y && (Array.isArray(t[e].data[n].y) ? this.twoDSeries.push(g.parseNumber(t[e].data[n].y[t[e].data[n].y.length - 1])) : this.twoDSeries.push(g.parseNumber(t[e].data[n].y))); for (let o = 0; o < t[r].data.length; o++) { const l = typeof t[r].data[o].x === 'string'; const h = Array.isArray(t[r].data[o].x); const c = !h && !!s.isValidDate(t[r].data[o].x.toString()); l || c ? l || i.xaxis.convertedCatToNumeric ? i.xaxis.type !== 'datetime' || a.isRangeData ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : this.twoDSeriesX.push(s.parseDate(t[r].data[o].x)) : i.xaxis.type === 'datetime' ? this.twoDSeriesX.push(s.parseDate(t[r].data[o].x.toString())) : (a.dataFormatXNumeric = !0, a.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[r].data[o].x))) : h ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : (a.isXNumeric = !0, a.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[r].data[o].x)); } if (t[e].data[0] && void 0 !== t[e].data[0].z) { for (let d = 0; d < t[e].data.length; d++) this.threeDSeries.push(t[e].data[d].z); a.isDataXYZ = !0; } } }, { key: 'handleRangeData', value(t, e) { const i = this.w.config; const a = this.w.globals; let s = {}; return this.isFormat2DArray() ? s = this.handleRangeDataFormat('array', t, e) : this.isFormatXY() && (s = this.handleRangeDataFormat('xy', t, e)), a.seriesRangeStart.push(s.start), a.seriesRangeEnd.push(s.end), i.xaxis.type === 'datetime' && a.seriesRangeBarTimeline.push(s.rangeUniques), a.seriesRangeBarTimeline.forEach(((t, e) => { t && t.forEach(((t, e) => { t.y.forEach(((e, i) => { for (let a = 0; a < t.y.length; a++) if (i !== a) { let s = e.y1; let r = e.y2; let n = t.y[a].y1; s <= t.y[a].y2 && n <= r && (t.overlaps.indexOf(e.rangeName) < 0 && t.overlaps.push(e.rangeName), t.overlaps.indexOf(t.y[a].rangeName) < 0 && t.overlaps.push(t.y[a].rangeName)); } })); })); })), s; } }, { key: 'handleCandleStickData', value(t, e) { const i = this.w.globals; let a = {}; return this.isFormat2DArray() ? a = this.handleCandleStickDataFormat('array', t, e) : this.isFormatXY() && (a = this.handleCandleStickDataFormat('xy', t, e)), i.seriesCandleO[e] = a.o, i.seriesCandleH[e] = a.h, i.seriesCandleL[e] = a.l, i.seriesCandleC[e] = a.c, a; } }, { key: 'handleRangeDataFormat', value(t, e, i) { const a = []; const s = []; const r = e[i].data.filter(((t, e, i) => e === i.findIndex(((e) => e.x===t.x)))).map(((t, e) => ({ x: t.x, overlaps: [], y: [] }))); const n = 'Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts'; const o = new F(this.ctx).getActiveConfigSeriesIndex(); if (t === 'array') { if (e[o].data[0][1].length !== 2) throw new Error(n); for (let l = 0; l < e[i].data.length; l++)a.push(e[i].data[l][1][0]), s.push(e[i].data[l][1][1]); } else if (t === 'xy') { if (e[o].data[0].y.length !== 2) throw new Error(n); for (let h = function (t) { const n = g.randomId(); const o = e[i].data[t].x; const l = { y1: e[i].data[t].y[0], y2: e[i].data[t].y[1], rangeName: n }; e[i].data[t].rangeName = n; const h = r.findIndex(((t) => t.x === o)); r[h].y.push(l), a.push(l.y1), s.push(l.y2); }, c = 0; c < e[i].data.length; c++)h(c); } return { start: a, end: s, rangeUniques: r }; } }, {
      key: 'handleCandleStickDataFormat',
      value(t, e, i) {
        const a = []; const s = []; const r = []; const n = []; const o = 'Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick'; if (t === 'array') { if (!Array.isArray(e[i].data[0][1]) && e[i].data[0].length !== 5 || Array.isArray(e[i].data[0][1]) && e[i].data[0][1].length !== 4) throw new Error(o); if (e[i].data[0].length === 5) for (let l = 0; l < e[i].data.length; l++)a.push(e[i].data[l][1]), s.push(e[i].data[l][2]), r.push(e[i].data[l][3]), n.push(e[i].data[l][4]); else for (let h = 0; h < e[i].data.length; h++)a.push(e[i].data[h][1][0]), s.push(e[i].data[h][1][1]), r.push(e[i].data[h][1][2]), n.push(e[i].data[h][1][3]); } else if (t === 'xy') { if (e[i].data[0].y.length !== 4) throw new Error(o); for (let c = 0; c < e[i].data.length; c++)a.push(e[i].data[c].y[0]), s.push(e[i].data[c].y[1]), r.push(e[i].data[c].y[2]), n.push(e[i].data[c].y[3]); } return {
          o: a, h: s, l: r, c: n,
        };
      },
    }, { key: 'parseDataAxisCharts', value(t) { for (var e = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a = this.w.config, s = this.w.globals, r = new C(i), n = a.labels.length > 0 ? a.labels.slice() : a.xaxis.categories.slice(), o = function () { for (let t = 0; t < n.length; t++) if (typeof n[t] === 'string') { if (!r.isValidDate(n[t])) throw new Error('You have provided invalid Date format. Please provide a valid JavaScript Date'); e.twoDSeriesX.push(r.parseDate(n[t])); } else { if (String(n[t]).length !== 13) throw new Error('Please provide a valid JavaScript timestamp'); e.twoDSeriesX.push(n[t]); } }, l = 0; l < t.length; l++) { if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t[l].data) return void console.error("It is a possibility that you may have not included 'data' property in series."); if (a.chart.type !== 'rangeBar' && a.chart.type !== 'rangeArea' && t[l].type !== 'rangeBar' && t[l].type !== 'rangeArea' || (s.isRangeData = !0, this.handleRangeData(t, l)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t, l) : this.isFormatXY() && this.handleFormatXY(t, l), a.chart.type !== 'candlestick' && t[l].type !== 'candlestick' || this.handleCandleStickData(t, l), s.series.push(this.twoDSeries), s.labels.push(this.twoDSeriesX), s.seriesX.push(this.twoDSeriesX), l !== this.activeSeriesIndex || this.fallbackToCategory || (s.isXNumeric = !0); else { a.xaxis.type === 'datetime' ? (s.isXNumeric = !0, o(), s.seriesX.push(this.twoDSeriesX)) : a.xaxis.type === 'numeric' && (s.isXNumeric = !0, n.length > 0 && (this.twoDSeriesX = n, s.seriesX.push(this.twoDSeriesX))), s.labels.push(this.twoDSeriesX); const h = t[l].data.map(((t) => g.parseNumber(t))); s.series.push(h); }s.seriesZ.push(this.threeDSeries), void 0 !== t[l].name ? s.seriesNames.push(t[l].name) : s.seriesNames.push(`series-${parseInt(l + 1, 10)}`); } return this.w; } }, { key: 'parseDataNonAxisCharts', value(t) { const e = this.w.globals; const i = this.w.config; e.series = t.slice(), e.seriesNames = i.labels.slice(); for (let a = 0; a < e.series.length; a++) void 0 === e.seriesNames[a] && e.seriesNames.push(`series-${a + 1}`); return this.w; } }, { key: 'handleExternalLabelsData', value(t) { const e = this.w.config; const i = this.w.globals; if (e.xaxis.categories.length > 0)i.labels = e.xaxis.categories; else if (e.labels.length > 0)i.labels = e.labels.slice(); else if (this.fallbackToCategory) { if (i.labels = i.labels[0], i.seriesRangeBarTimeline.length && (i.seriesRangeBarTimeline.map(((t) => { t.forEach(((t) => { i.labels.indexOf(t.x) < 0 && t.x && i.labels.push(t.x); })); })), i.labels = i.labels.filter(((t, e, i) => i.indexOf(t) === e))), e.xaxis.convertedCatToNumeric) new L(e).convertCatToNumericXaxis(e, this.ctx, i.seriesX[0]), this._generateExternalLabels(t); } else this._generateExternalLabels(t); } }, { key: '_generateExternalLabels', value(t) { const e = this.w.globals; const i = this.w.config; let a = []; if (e.axisCharts) { if (e.series.length > 0) for (let s = 0; s < e.series[e.maxValsInArrayIndex].length; s++)a.push(s + 1); e.seriesX = []; for (let r = 0; r < t.length; r++)e.seriesX.push(a); e.isXNumeric = !0; } if (a.length === 0) { a = e.axisCharts ? [0, 10] : e.series.map(((t, e) => e + 1)); for (let n = 0; n < t.length; n++)e.seriesX.push(a); }e.labels = a, i.xaxis.convertedCatToNumeric && (e.categoryLabels = a.map(((t) => i.xaxis.labels.formatter(t)))), e.noLabelsProvided = !0; } }, { key: 'parseData', value(t) { const e = this.w; const i = e.config; const a = e.globals; if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a.axisCharts ? this.parseDataAxisCharts(t) : this.parseDataNonAxisCharts(t), this.coreUtils.getLargestSeries(), i.chart.type === 'bar' && i.chart.stacked) { const s = new F(this.ctx); a.series = s.setNullSeriesToZeroValues(a.series); } this.coreUtils.getSeriesTotals(), a.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), a.dataFormatXNumeric || a.isXNumeric && (i.xaxis.type !== 'numeric' || i.labels.length !== 0 || i.xaxis.categories.length !== 0) || this.handleExternalLabelsData(t); for (let r = this.coreUtils.getCategoryLabels(a.labels), n = 0; n < r.length; n++) if (Array.isArray(r[n])) { a.isMultiLineX = !0; break; } } }, { key: 'excludeCollapsedSeriesInYAxis', value() { const t = this; const e = this.w; e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map(((i, a) => { if (t.w.globals.isMultipleYAxis && !e.config.chart.stacked) return i.index; })); } }]), t;
  }()); const R = (function () { function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.tooltipKeyFormat = 'dd MMM'; } return a(t, [{ key: 'xLabelFormat', value(t, e, i) { const a = this.w; if (a.config.xaxis.type === 'datetime' && void 0 === a.config.xaxis.labels.formatter && void 0 === a.config.tooltip.x.formatter) { const s = new C(this.ctx); return s.formatDate(s.getDate(e), a.config.tooltip.x.format); } return t(e, i); } }, { key: 'defaultGeneralFormatter', value(t) { return Array.isArray(t) ? t.map(((t) => t)) : t; } }, { key: 'defaultYFormatter', value(t, e, i) { const a = this.w; return g.isNumber(t) && (t = a.globals.yValueDecimal !== 0 ? t.toFixed(void 0 !== e.decimalsInFloat ? e.decimalsInFloat : a.globals.yValueDecimal) : a.globals.maxYArr[i] - a.globals.minYArr[i] < 10 ? t.toFixed(1) : t.toFixed(0)), t; } }, { key: 'setLabelFormatters', value() { const t = this; const e = this.w; return e.globals.xLabelFormatter = function (e) { return t.defaultGeneralFormatter(e); }, e.globals.xaxisTooltipFormatter = function (e) { return t.defaultGeneralFormatter(e); }, e.globals.ttKeyFormatter = function (e) { return t.defaultGeneralFormatter(e); }, e.globals.ttZFormatter = function (t) { return t; }, e.globals.legendFormatter = function (e) { return t.defaultGeneralFormatter(e); }, void 0 !== e.config.xaxis.labels.formatter ? e.globals.xLabelFormatter = e.config.xaxis.labels.formatter : e.globals.xLabelFormatter = function (t) { if (g.isNumber(t)) { if (!e.config.xaxis.convertedCatToNumeric && e.config.xaxis.type === 'numeric' && e.globals.dataPoints < 50) return t.toFixed(1); if (e.globals.isBarHorizontal) if (e.globals.maxY - e.globals.minYArr < 4) return t.toFixed(1); return t.toFixed(0); } return t; }, typeof e.config.tooltip.x.formatter === 'function' ? e.globals.ttKeyFormatter = e.config.tooltip.x.formatter : e.globals.ttKeyFormatter = e.globals.xLabelFormatter, typeof e.config.xaxis.tooltip.formatter === 'function' && (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter), Array.isArray(e.config.tooltip.y) ? e.globals.ttVal = e.config.tooltip.y : void 0 !== e.config.tooltip.y.formatter && (e.globals.ttVal = e.config.tooltip.y), void 0 !== e.config.tooltip.z.formatter && (e.globals.ttZFormatter = e.config.tooltip.z.formatter), void 0 !== e.config.legend.formatter && (e.globals.legendFormatter = e.config.legend.formatter), e.config.yaxis.forEach(((i, a) => { void 0 !== i.labels.formatter ? e.globals.yLabelFormatters[a] = i.labels.formatter : e.globals.yLabelFormatters[a] = function (s) { return e.globals.xyCharts ? Array.isArray(s) ? s.map(((e) => t.defaultYFormatter(e, i, a))) : t.defaultYFormatter(s, i, a) : s; }; })), e.globals; } }, { key: 'heatmapLabelFormatters', value() { const t = this.w; if (t.config.chart.type === 'heatmap') { t.globals.yAxisScale[0].result = t.globals.seriesNames.slice(); const e = t.globals.seriesNames.reduce(((t, e) => (t.length > e.length ? t : e)), 0); t.globals.yAxisScale[0].niceMax = e, t.globals.yAxisScale[0].niceMin = e; } } }]), t; }()); const H = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{
      key: 'getLabel',
      value(t, e, i, a) {
        const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : []; const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : '12px'; const n = this.w; const o = void 0 === t[a] ? '' : t[a]; let l = o; const h = n.globals.xLabelFormatter; const c = n.config.xaxis.labels.formatter; let d = !1; const g = new R(this.ctx); const u = o; l = g.xLabelFormat(h, o, u), void 0 !== c && (l = c(o, t[a], a)); const f = function (t) { let i = null; return e.forEach(((t) => { t.unit === 'month' ? i = 'year' : t.unit === 'day' ? i = 'month' : t.unit === 'hour' ? i = 'day' : t.unit === 'minute' && (i = 'hour'); })), i === t; }; e.length > 0 ? (d = f(e[a].unit), i = e[a].position, l = e[a].value) : n.config.xaxis.type === 'datetime' && void 0 === c && (l = ''), void 0 === l && (l = ''), l = Array.isArray(l) ? l : l.toString(); const x = new p(this.ctx); let b = {}; return b = n.globals.rotateXLabels ? x.getTextRects(l, parseInt(r, 10), null, 'rotate('.concat(n.config.xaxis.labels.rotate, ' 0 0)'), !1) : x.getTextRects(l, parseInt(r, 10)), !Array.isArray(l) && (l.indexOf('NaN') === 0 || l.toLowerCase().indexOf('invalid') === 0 || l.toLowerCase().indexOf('infinity') >= 0 || s.indexOf(l) >= 0 && !n.config.xaxis.labels.showDuplicates) && (l = ''), {
          x: i, text: l, textRect: b, isBold: d,
        };
      },
    }, { key: 'checkForOverflowingLabels', value(t, e, i, a, s) { const r = this.w; if (t === 0 && r.globals.skipFirstTimelinelabel && (e.text = ''), t === i - 1 && r.globals.skipLastTimelinelabel && (e.text = ''), r.config.xaxis.labels.hideOverlappingLabels && a.length > 0) { const n = s[s.length - 1]; e.x < n.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 20 : 1.01) + n.x && (e.text = ''); } return e; } }, { key: 'checkForReversedLabels', value(t, e) { const i = this.w; return i.config.yaxis[t] && i.config.yaxis[t].reversed && e.reverse(), e; } }, { key: 'drawYAxisTicks', value(t, e, i, a, s, r, n) { const o = this.w; const l = new p(this.ctx); let h = o.globals.translateY; if (a.show && e > 0) { !0 === o.config.yaxis[s].opposite && (t += a.width); for (let c = e; c >= 0; c--) { let d = h + e / 10 + o.config.yaxis[s].labels.offsetY - 1; o.globals.isBarHorizontal && (d = r * c), o.config.chart.type === 'heatmap' && (d += r / 2); const g = l.drawLine(t + i.offsetX - a.width + a.offsetX, d + a.offsetY, t + i.offsetX + a.offsetX, d + a.offsetY, a.color); n.add(g), h += r; } } } }]), t;
  }()); const N = (function () { function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'fixSvgStringForIe11', value(t) { if (!g.isIE11()) return t; let e = 0; let i = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, ((t) => (++e === 2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"':t))); return i = (i = i.replace(/xmlns:NS\d+=""/g, '')).replace(/NS\d+:(\w+:\w+=")/g, '$1'); } }, { key: 'getSvgString', value() { const t = this.w.globals.dom.Paper.svg(); return this.fixSvgStringForIe11(t); } }, { key: 'cleanup', value() { const t = this.w; const e = t.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs'); const i = t.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs'); const a = t.globals.dom.baseEl.querySelectorAll('.apexcharts-zoom-rect, .apexcharts-selection-rect'); Array.prototype.forEach.call(a, ((t) => { t.setAttribute('width', 0); })), e && (e.setAttribute('x', -500), e.setAttribute('x1', -500), e.setAttribute('x2', -500)), i && (i.setAttribute('y', -100), i.setAttribute('y1', -100), i.setAttribute('y2', -100)); } }, { key: 'svgUrl', value() { this.cleanup(); const t = this.getSvgString(); const e = new Blob([t], { type: 'image/svg+xml;charset=utf-8' }); return URL.createObjectURL(e); } }, { key: 'dataURI', value() { const t = this; return new Promise((((e) => { const i = t.w; t.cleanup(); const a = document.createElement('canvas'); a.width = i.globals.svgWidth, a.height = parseInt(i.globals.dom.elWrap.style.height, 10); const s = i.config.chart.background === 'transparent' ? '#fff' : i.config.chart.background; const r = a.getContext('2d'); r.fillStyle = s, r.fillRect(0, 0, a.width, a.height); const n = t.getSvgString(); if (window.canvg && g.isIE11()) { const o = window.canvg.Canvg.fromString(r, n, { ignoreClear: !0, ignoreDimensions: !0 }); o.start(); const l = a.msToBlob(); o.stop(), e({ blob: l }); } else { const h = `data:image/svg+xml,${encodeURIComponent(n)}`; const c = new Image(); c.crossOrigin = 'anonymous', c.onload = function () { if (r.drawImage(c, 0, 0), a.msToBlob) { const t = a.msToBlob(); e({ blob: t }); } else { const i = a.toDataURL('image/png'); e({ imgURI: i }); } }, c.src = h; } }))); } }, { key: 'exportToSVG', value() { this.triggerDownload(this.svgUrl(), '.svg'); } }, { key: 'exportToPng', value() { const t = this; this.dataURI().then(((e) => { const i = e.imgURI; const a = e.blob; a ? navigator.msSaveOrOpenBlob(a, `${t.w.globals.chartID}.png`) : t.triggerDownload(i, '.png'); })); } }, { key: 'exportToCSV', value(t) { const e = this; const i = t.series; const a = t.columnDelimiter; const s = void 0 === a ? ',' : a; const r = t.lineDelimiter; const n = void 0 === r ? '\n' : r; const o = this.w; let l = []; const h = []; let c = 'data:text/csv;charset=utf-8,'; const d = new D(this.ctx); const g = new H(this.ctx); const u = function (t) { let i = ''; if (o.globals.axisCharts) { if (o.config.xaxis.type === 'category' || o.config.xaxis.convertedCatToNumeric) if (o.globals.isBarHorizontal) { const a = o.globals.yLabelFormatters[0]; const s = new F(e.ctx).getActiveConfigSeriesIndex(); i = a(o.globals.labels[t], { seriesIndex: s, dataPointIndex: t, w: o }); } else i = g.getLabel(o.globals.labels, o.globals.timescaleLabels, 0, t).text; o.config.xaxis.type === 'datetime' && (o.config.xaxis.categories.length ? i = o.config.xaxis.categories[t] : o.config.labels.length && (i = o.config.labels[t])); } else i = o.config.labels[t]; return i; }; l.push('category'), i.map(((t, e) => { o.globals.axisCharts && l.push(t.name ? t.name : 'series-'.concat(e)); })), o.globals.axisCharts || (l.push('value'), h.push(l.join(s))), i.map(((t, e) => { o.globals.axisCharts ? (function (t, e) { if (l.length && h.push(l.join(s)), t.data && t.data.length) for (let a = 0; a < t.data.length; a++) { l = []; let r = u(a); if (r || (d.isFormatXY() ? r = i[e].data[a].x : d.isFormat2DArray() && (r = i[e].data[a] ? i[e].data[a][0] : '')), e === 0) { l.push(r); for (let n = 0; n < o.globals.series.length; n++)l.push(o.globals.series[n][a]); }(o.config.chart.type === 'candlestick' || t.type && t.type === 'candlestick') && (l.pop(), l.push(o.globals.seriesCandleO[e][a]), l.push(o.globals.seriesCandleH[e][a]), l.push(o.globals.seriesCandleL[e][a]), l.push(o.globals.seriesCandleC[e][a])), o.config.chart.type === 'rangeBar' && (l.pop(), l.push(o.globals.seriesRangeStart[e][a]), l.push(o.globals.seriesRangeEnd[e][a])), l.length && h.push(l.join(s)); } }(t, e)) : ((l = []).push(o.globals.labels[e]), l.push(o.globals.series[e]), h.push(l.join(s))); })), c += h.join(n), this.triggerDownload(encodeURI(c), '.csv'); } }, { key: 'triggerDownload', value(t, e) { const i = document.createElement('a'); i.href = t, i.download = this.w.globals.chartID + e, document.body.appendChild(i), i.click(), document.body.removeChild(i); } }]), t; }()); const O = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; const a = this.w; this.axesUtils = new H(i), this.xaxisLabels = a.globals.labels.slice(), a.globals.timescaleLabels.length > 0 && !a.globals.isBarHorizontal && (this.xaxisLabels = a.globals.timescaleLabels.slice()), this.drawnLabels = [], this.drawnLabelsRects = [], a.config.xaxis.position === 'top' ? this.offY = 0 : this.offY = a.globals.gridHeight + 1, this.offY += a.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = a.config.chart.type === 'bar' && a.config.plotOptions.bar.horizontal, this.xaxisFontSize = a.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = a.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = a.config.xaxis.labels.style.colors, this.xaxisBorderWidth = a.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = a.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf('%') > -1 ? this.xaxisBorderWidth = a.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = a.config.xaxis.axisBorder.height, this.yaxis = a.config.yaxis[0]; } return a(t, [{
      key: 'drawXaxis',
      value() {
        let t; const e = this; const i = this.w; const a = new p(this.ctx); const s = a.group({ class: 'apexcharts-xaxis', transform: 'translate('.concat(i.config.xaxis.offsetX, ', ').concat(i.config.xaxis.offsetY, ')') }); const r = a.group({ class: 'apexcharts-xaxis-texts-g', transform: 'translate('.concat(i.globals.translateXAxisX, ', ').concat(i.globals.translateXAxisY, ')') }); s.add(r); for (var n = i.globals.padHorizontal, o = [], l = 0; l < this.xaxisLabels.length; l++)o.push(this.xaxisLabels[l]); if (i.globals.isXNumeric) { const h = o.length > 1 ? o.length - 1 : o.length; t = i.globals.gridWidth / h, n = n + t / 2 + i.config.xaxis.labels.offsetX; } else t = i.globals.gridWidth / o.length, n = n + t + i.config.xaxis.labels.offsetX; const c = o.length; if (i.config.xaxis.labels.show) {
 for (let d = function (s) {
            let l = n - t / 2 + i.config.xaxis.labels.offsetX; s === 0 && c === 1 && t / 2 === n && i.globals.dataPoints === 1 && (l = i.globals.gridWidth / 2); let h = e.axesUtils.getLabel(o, i.globals.timescaleLabels, l, s, e.drawnLabels, e.xaxisFontSize); let d = 28; i.globals.rotateXLabels && (d = 22); (h = e.axesUtils.checkForOverflowingLabels(s, h, c, e.drawnLabels, e.drawnLabelsRects)).text && i.globals.xaxisLabelsCount++; const g = a.drawText({
              x: h.x, y: e.offY + i.config.xaxis.labels.offsetY + d, text: h.text, textAnchor: 'middle', fontWeight: h.isBold ? 600 : 400, fontSize: e.xaxisFontSize, fontFamily: e.xaxisFontFamily, foreColor: Array.isArray(e.xaxisForeColors) ? i.config.xaxis.convertedCatToNumeric ? e.xaxisForeColors[i.globals.minX + s - 1] : e.xaxisForeColors[s] : e.xaxisForeColors, isPlainText: !1, cssClass: `apexcharts-xaxis-label ${i.config.xaxis.labels.style.cssClass}`, 
            }); r.add(g); const u = document.createElementNS(i.globals.SVGNS, 'title'); u.textContent = h.text, g.node.appendChild(u), h.text !== '' && (e.drawnLabels.push(h.text), e.drawnLabelsRects.push(h)), n += t;
          }, g = 0; g <= c - 1; g++)d(g); 
} if (void 0 !== i.config.xaxis.title.text) {
          const u = a.group({ class: 'apexcharts-xaxis-title' }); const f = a.drawText({
            x: i.globals.gridWidth / 2 + i.config.xaxis.title.offsetX, y: this.offY - parseFloat(this.xaxisFontSize) + i.globals.xAxisLabelsHeight + i.config.xaxis.title.offsetY, text: i.config.xaxis.title.text, textAnchor: 'middle', fontSize: i.config.xaxis.title.style.fontSize, fontFamily: i.config.xaxis.title.style.fontFamily, fontWeight: i.config.xaxis.title.style.fontWeight, foreColor: i.config.xaxis.title.style.color, cssClass: `apexcharts-xaxis-title-text ${i.config.xaxis.title.style.cssClass}`,
          }); u.add(f), s.add(u);
        } if (i.config.xaxis.axisBorder.show) { let x = 0; i.config.chart.type === 'bar' && i.globals.isXNumeric && (x -= 15); const b = a.drawLine(i.globals.padHorizontal + x + i.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, i.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight); s.add(b); } return s;
      },
    }, {
      key: 'drawXaxisInversed',
      value(t) {
        let e; let i; const a = this.w; const s = new p(this.ctx); const r = a.config.yaxis[0].opposite ? a.globals.translateYAxisX[t] : 0; const n = s.group({ class: 'apexcharts-yaxis apexcharts-xaxis-inversed', rel: t }); const o = s.group({ class: 'apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g', transform: `translate(${r}, 0)` }); n.add(o); const l = []; if (a.config.yaxis[t].show) for (let h = 0; h < this.xaxisLabels.length; h++)l.push(this.xaxisLabels[h]); i = -(e = a.globals.gridHeight / l.length) / 2.2; const c = a.globals.yLabelFormatters[0]; const d = a.config.yaxis[0].labels; if (d.show) {
 for (let g = 0; g <= l.length - 1; g++) {
          let u = void 0 === l[g] ? '' : l[g]; u = c(u, { seriesIndex: t, dataPointIndex: g, w: a }); let f = 0; Array.isArray(u) && (f = u.length / 2 * parseInt(d.style.fontSize, 10)); const x = s.drawText({
            x: d.offsetX - 15, y: i + e + d.offsetY - f, text: u, textAnchor: this.yaxis.opposite ? 'start' : 'end', foreColor: Array.isArray(d.style.colors) ? d.style.colors[g] : d.style.colors, fontSize: d.style.fontSize, fontFamily: d.style.fontFamily, isPlainText: !1, cssClass: `apexcharts-yaxis-label ${d.style.cssClass}`, 
          }); o.add(x); const b = document.createElementNS(a.globals.SVGNS, 'title'); if (b.textContent = u.text, x.node.appendChild(b), a.config.yaxis[t].labels.rotate !== 0) { const m = s.rotateAroundCenter(x.node); x.node.setAttribute('transform', 'rotate('.concat(a.config.yaxis[t].labels.rotate, ' 0 ').concat(m.y, ')')); }i += e;
        } 
} if (void 0 !== a.config.yaxis[0].title.text) {
          const v = s.group({ class: 'apexcharts-yaxis-title apexcharts-xaxis-title-inversed', transform: `translate(${r}, 0)` }); const y = s.drawText({
            x: 0, y: a.globals.gridHeight / 2, text: a.config.yaxis[0].title.text, textAnchor: 'middle', foreColor: a.config.yaxis[0].title.style.color, fontSize: a.config.yaxis[0].title.style.fontSize, fontWeight: a.config.yaxis[0].title.style.fontWeight, fontFamily: a.config.yaxis[0].title.style.fontFamily, cssClass: `apexcharts-yaxis-title-text ${a.config.yaxis[0].title.style.cssClass}`,
          }); v.add(y), n.add(v);
        } let w = 0; this.isCategoryBarHorizontal && a.config.yaxis[0].opposite && (w = a.globals.gridWidth); const k = a.config.xaxis.axisBorder; if (k.show) { const A = s.drawLine(a.globals.padHorizontal + k.offsetX + w, 1 + k.offsetY, a.globals.padHorizontal + k.offsetX + w, a.globals.gridHeight + k.offsetY, k.color, 0); n.add(A); } return a.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(w, l.length, a.config.yaxis[0].axisBorder, a.config.yaxis[0].axisTicks, 0, e, n), n;
      },
    }, { key: 'drawXaxisTicks', value(t, e) { const i = this.w; const a = t; if (!(t < 0 || t - 2 > i.globals.gridWidth)) { const s = this.offY + i.config.xaxis.axisTicks.offsetY; const r = s + i.config.xaxis.axisTicks.height; if (i.config.xaxis.axisTicks.show) { const n = new p(this.ctx).drawLine(t + i.config.xaxis.axisTicks.offsetX, s + i.config.xaxis.offsetY, a + i.config.xaxis.axisTicks.offsetX, r + i.config.xaxis.offsetY, i.config.xaxis.axisTicks.color); e.add(n), n.node.classList.add('apexcharts-xaxis-tick'); } } } }, { key: 'getXAxisTicksPositions', value() { const t = this.w; const e = []; const i = this.xaxisLabels.length; let a = t.globals.padHorizontal; if (t.globals.timescaleLabels.length > 0) for (let s = 0; s < i; s++)a = this.xaxisLabels[s].position, e.push(a); else for (let r = i, n = 0; n < r; n++) { let o = r; t.globals.isXNumeric && t.config.chart.type !== 'bar' && (o -= 1), a += t.globals.gridWidth / o, e.push(a); } return e; } }, { key: 'xAxisLabelCorrections', value() { const t = this.w; const e = new p(this.ctx); const i = t.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g'); const a = t.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-texts-g text'); const s = t.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-inversed text'); const r = t.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-inversed-texts-g text tspan'); if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways) for (let n = 0; n < a.length; n++) { const o = e.rotateAroundCenter(a[n]); o.y -= 1, o.x += 1, a[n].setAttribute('transform', 'rotate('.concat(t.config.xaxis.labels.rotate, ' ').concat(o.x, ' ').concat(o.y, ')')), a[n].setAttribute('text-anchor', 'end'); i.setAttribute('transform', 'translate(0, '.concat(-10, ')')); const l = a[n].childNodes; t.config.xaxis.labels.trim && Array.prototype.forEach.call(l, ((i) => { e.placeTextWithEllipsis(i, i.textContent, t.config.xaxis.labels.maxHeight - (t.config.legend.position === 'bottom' ? 20 : 10)); })); } else !(function () { for (var i = t.globals.gridWidth / (t.globals.labels.length + 1), s = 0; s < a.length; s++) { const r = a[s].childNodes; t.config.xaxis.labels.trim && t.config.xaxis.type !== 'datetime' && Array.prototype.forEach.call(r, ((t) => { e.placeTextWithEllipsis(t, t.textContent, i); })); } }()); if (s.length > 0) { const h = s[s.length - 1].getBBox(); const c = s[0].getBBox(); h.x < -20 && s[s.length - 1].parentNode.removeChild(s[s.length - 1]), c.x + c.width > t.globals.gridWidth && !t.globals.isBarHorizontal && s[0].parentNode.removeChild(s[0]); for (let d = 0; d < r.length; d++)e.placeTextWithEllipsis(r[d], r[d].textContent, t.config.yaxis[0].labels.maxWidth - 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) - 20); } } }]), t;
  }()); const W = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; const a = this.w; this.xaxisLabels = a.globals.labels.slice(), this.axesUtils = new H(i), this.isTimelineBar = a.config.xaxis.type === 'datetime' && a.globals.seriesRangeBarTimeline.length, a.globals.timescaleLabels.length > 0 && (this.xaxisLabels = a.globals.timescaleLabels.slice()); } return a(t, [{ key: 'drawGridArea', value() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; const e = this.w; const i = new p(this.ctx); t === null && (t = i.group({ class: 'apexcharts-grid' })); const a = i.drawLine(e.globals.padHorizontal, 1, e.globals.padHorizontal, e.globals.gridHeight, 'transparent'); const s = i.drawLine(e.globals.padHorizontal, e.globals.gridHeight, e.globals.gridWidth, e.globals.gridHeight, 'transparent'); return t.add(s), t.add(a), t; } }, { key: 'drawGrid', value() { const t = this.w.globals; let e = null; return t.axisCharts && (e = this.renderGrid(), t.dom.elGraphical.add(e.el), this.drawGridArea(e.el)), e; } }, { key: 'createGridMask', value() { const t = this.w; const e = t.globals; const i = new p(this.ctx); let a = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width; if (Array.isArray(t.config.stroke.width)) { let s = 0; t.config.stroke.width.forEach(((t) => { s = Math.max(s, t); })), a = s; }e.dom.elGridRectMask = document.createElementNS(e.SVGNS, 'clipPath'), e.dom.elGridRectMask.setAttribute('id', 'gridRectMask'.concat(e.cuid)), e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, 'clipPath'), e.dom.elGridRectMarkerMask.setAttribute('id', 'gridRectMarkerMask'.concat(e.cuid)); const r = t.config.chart.type; let n = 0; let o = 0; (r === 'bar' || r === 'rangeBar' || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (n = t.config.grid.padding.left, o = t.config.grid.padding.right, e.barPadForNumericAxis > n && (n = e.barPadForNumericAxis, o = e.barPadForNumericAxis)), e.dom.elGridRect = i.drawRect(-a / 2 - n - 2, -a / 2, e.gridWidth + a + o + n + 4, e.gridHeight + a, 0, '#fff'), new I(this).getLargestMarkerSize(); const l = t.globals.markers.largestSize + 1; e.dom.elGridRectMarker = i.drawRect(-l, -l, e.gridWidth + 2 * l, e.gridHeight + 2 * l, 0, '#fff'), e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node), e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node); const h = e.dom.baseEl.querySelector('defs'); h.appendChild(e.dom.elGridRectMask), h.appendChild(e.dom.elGridRectMarkerMask); } }, {
      key: '_drawGridLines',
      value(t) {
        const e = t.i; const i = t.x1; const a = t.y1; const s = t.x2; const r = t.y2; const n = t.xCount; const o = t.parent; const l = this.w; e === 0 && l.globals.skipFirstTimelinelabel || e === n - 1 && l.globals.skipLastTimelinelabel || l.config.chart.type === 'radar' || (l.config.grid.xaxis.lines.show && this._drawGridLine({
          x1: i, y1: a, x2: s, y2: r, parent: o,
        }), new O(this.ctx).drawXaxisTicks(i, this.elg));
      },
    }, { key: '_drawGridLine', value(t) { const e = t.x1; const i = t.y1; const a = t.x2; const s = t.y2; const r = t.parent; const n = this.w; const o = n.config.grid.strokeDashArray; const l = new p(this).drawLine(e, i, a, s, n.config.grid.borderColor, o); l.node.classList.add('apexcharts-gridline'), r.add(l); } }, { key: '_drawGridBandRect', value(t) { const e = t.c; const i = t.x1; const a = t.y1; const s = t.x2; const r = t.y2; const n = t.type; const o = this.w; const l = new p(this.ctx); if (n !== 'column' || o.config.xaxis.type !== 'datetime') { const h = o.config.grid[n].colors[e]; const c = l.drawRect(i, a, s, r, 0, h, o.config.grid[n].opacity); this.elg.add(c), c.node.classList.add('apexcharts-grid-'.concat(n)); } } }, {
      key: '_drawXYLines',
      value(t) {
        const e = this; let i = t.xCount; const a = t.tickAmount; const s = this.w; if (s.config.grid.xaxis.lines.show || s.config.xaxis.axisTicks.show) {
          const r = s.globals.padHorizontal; const n = s.globals.gridHeight; s.globals.timescaleLabels.length ? (function (t) {
            for (let a = t.xC, s = t.x1, r = t.y1, n = t.x2, o = t.y2, l = 0; l < a; l++) { s = e.xaxisLabels[l].position, n = e.xaxisLabels[l].position, e._drawGridLines({
              i: l, x1: s, y1: r, x2: n, y2: o, xCount: i, parent: e.elgridLinesV, 
            }); }
          }({
            xC: i, x1: r, y1: 0, x2: void 0, y2: n,
          })) : (s.globals.isXNumeric && (i = s.globals.xAxisScale.result.length), s.config.xaxis.convertedCatToNumeric && (i = s.globals.xaxisLabelsCount), (function (t) {
            for (let a = t.xC, r = t.x1, n = t.y1, o = t.x2, l = t.y2, h = 0; h < a + (s.globals.isXNumeric ? 0 : 1); h++) { h === 0 && a === 1 && s.globals.dataPoints === 1 && (r = s.globals.gridWidth / 2), e._drawGridLines({
              i: h, x1: r, y1: n, x2: o, y2: l, xCount: i, parent: e.elgridLinesV, 
            }), o = r += s.globals.gridWidth / (s.globals.isXNumeric ? a - 1 : a); }
          }({
            xC: i, x1: r, y1: 0, x2: void 0, y2: n,
          })));
        } if (s.config.grid.yaxis.lines.show) {
          let o = 0; let l = 0; const h = s.globals.gridWidth; let c = a + 1; this.isTimelineBar && (c = s.globals.labels.length); for (let d = 0; d < c + (this.isTimelineBar ? 1 : 0); d++) {
 this._drawGridLine({
            x1: 0, y1: o, x2: h, y2: l, parent: this.elgridLinesH,
          }), l = o += s.globals.gridHeight / (this.isTimelineBar ? c : a); 
}
        }
      },
    }, {
      key: '_drawInvertedXYLines',
      value(t) {
        const e = t.xCount; const i = this.w; if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) {
 for (var a, s = i.globals.padHorizontal, r = i.globals.gridHeight, n = 0; n < e + 1; n++) {
          i.config.grid.xaxis.lines.show && this._drawGridLine({
            x1: s, y1: 0, x2: a, y2: r, parent: this.elgridLinesV,
          }), new O(this.ctx).drawXaxisTicks(s, this.elg), a = s = s + i.globals.gridWidth / e + 0.3;
        } 
} if (i.config.grid.yaxis.lines.show) {
 for (let o = 0, l = 0, h = i.globals.gridWidth, c = 0; c < i.globals.dataPoints + 1; c++) { this._drawGridLine({
          x1: 0, y1: o, x2: h, y2: l, parent: this.elgridLinesH, 
        }), l = o += i.globals.gridHeight / i.globals.dataPoints; } }
      },
    }, { key: 'renderGrid', value() { const t = this.w; const e = new p(this.ctx); this.elg = e.group({ class: 'apexcharts-grid' }), this.elgridLinesH = e.group({ class: 'apexcharts-gridlines-horizontal' }), this.elgridLinesV = e.group({ class: 'apexcharts-gridlines-vertical' }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide()); for (var i, a = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, s = 0; s < t.globals.series.length && (void 0 !== t.globals.yAxisScale[s] && (a = t.globals.yAxisScale[s].result.length - 1), !(a > 2)); s++);return !t.globals.isBarHorizontal || this.isTimelineBar ? (i = this.xaxisLabels.length, this.isTimelineBar && (a = t.globals.labels.length), this._drawXYLines({ xCount: i, tickAmount: a })) : (i = a, this._drawInvertedXYLines({ xCount: i, tickAmount: a })), this.drawGridBands(i, a), { el: this.elg, xAxisTickWidth: t.globals.gridWidth / i }; } }, {
      key: 'drawGridBands',
      value(t, e) {
        const i = this.w; if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0) {
 for (let a = 0, s = i.globals.gridHeight / e, r = i.globals.gridWidth, n = 0, o = 0; n < e; n++, o++) { o >= i.config.grid.row.colors.length && (o = 0), this._drawGridBandRect({
          c: o, x1: 0, y1: a, x2: r, y2: s, type: 'row', 
        }), a += i.globals.gridHeight / e; } } if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0) {
 for (let l = i.config.xaxis.type === 'category' || i.config.xaxis.convertedCatToNumeric ? t - 1 : t, h = i.globals.padHorizontal, c = i.globals.padHorizontal + i.globals.gridWidth / l, d = i.globals.gridHeight, g = 0, u = 0; g < t; g++, u++) { u >= i.config.grid.column.colors.length && (u = 0), this._drawGridBandRect({
          c: u, x1: h, y1: 0, x2: c, y2: d, type: 'column', 
        }), h += i.globals.gridWidth / l; } }
      },
    }]), t;
  }()); const B = (function () { function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'niceScale', value(t, e, i) { const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0; let s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 10; const r = arguments.length > 5 ? arguments[5] : void 0; const n = this.w; if (s === 'dataPoints' && (s = n.globals.dataPoints - 1), t === Number.MIN_VALUE && e === 0 || !g.isNumber(t) && !g.isNumber(e) || t === Number.MIN_VALUE && e === -Number.MAX_VALUE) { t = 0, e = s; const o = this.linearScale(t, e, s); return o; }t > e ? (console.warn('axis.min cannot be greater than axis.max'), e = t + 0.1) : t === e && (t = t === 0 ? 0 : t - 0.5, e = e === 0 ? 2 : e + 0.5); let l = []; const h = Math.abs(e - t); h < 1 && r && (n.config.chart.type === 'candlestick' || n.config.series[a].type === 'candlestick' || n.globals.isRangeData) && (e *= 1.01); let c = s + 1; c < 2 ? c = 2 : c > 2 && (c -= 2); const d = h / c; const u = Math.floor(g.log10(d)); const f = Math.pow(10, u); let p = Math.round(d / f); p < 1 && (p = 1); const x = p * f; const b = x * Math.floor(t / x); const m = x * Math.ceil(e / x); let v = b; if (r && h > 2) { for (;l.push(v), !((v += x) > m););return { result: l, niceMin: l[0], niceMax: l[l.length - 1] }; } let y = t; (l = []).push(y); for (let w = Math.abs(e - t) / s, k = 0; k <= s; k++)y += w, l.push(y); return l[l.length - 2] >= e && l.pop(), { result: l, niceMin: l[0], niceMax: l[l.length - 1] }; } }, { key: 'linearScale', value(t, e) { let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10; const a = Math.abs(e - t); let s = a / i; i === Number.MAX_VALUE && (i = 10, s = 1); for (var r = [], n = t; i >= 0;)r.push(n), n += s, i -= 1; return { result: r, niceMin: r[0], niceMax: r[r.length - 1] }; } }, { key: 'logarithmicScale', value(t, e, i, a) { (e < 0 || e === Number.MIN_VALUE) && (e = 0.01); for (var s = Math.log(e) / Math.log(10), r = Math.log(i) / Math.log(10), n = Math.abs(i - e) / a, o = [], l = e; a >= 0;)o.push(l), l += n, a -= 1; const h = o.map(((t, a) => { t <= 0 && (t = 0.01); const n = (r - s) / (i - e); const o = Math.pow(10, s + n * (t - s)); return Math.round(o / g.roundToBase(o, 10)) * g.roundToBase(o, 10); })); return h[0] === 0 && (h[0] = 1), { result: h, niceMin: h[0], niceMax: h[h.length - 1] }; } }, { key: 'setYScaleForIndex', value(t, e, i) { const a = this.w.globals; const s = this.w.config; const r = a.isBarHorizontal ? s.xaxis : s.yaxis[t]; void 0 === a.yAxisScale[t] && (a.yAxisScale[t] = []); const n = Math.abs(i - e); if (r.logarithmic && n <= 5 && (a.invalidLogScale = !0), r.logarithmic && n > 5)a.allSeriesCollapsed = !1, a.yAxisScale[t] = this.logarithmicScale(t, e, i, r.tickAmount ? r.tickAmount : Math.floor(Math.log10(i))); else if (i !== -Number.MAX_VALUE && g.isNumber(i)) if (a.allSeriesCollapsed = !1, void 0 === r.min && void 0 === r.max || r.forceNiceScale) { const o = void 0 === s.yaxis[t].max && void 0 === s.yaxis[t].min || s.yaxis[t].forceNiceScale; a.yAxisScale[t] = this.niceScale(e, i, n, t, r.tickAmount ? r.tickAmount : n < 5 && n > 1 ? n + 1 : 5, o); } else a.yAxisScale[t] = this.linearScale(e, i, r.tickAmount); else a.yAxisScale[t] = this.linearScale(0, 5, 5); } }, { key: 'setXScale', value(t, e) { const i = this.w; const a = i.globals; const s = i.config.xaxis; const r = Math.abs(e - t); return e !== -Number.MAX_VALUE && g.isNumber(e) ? a.xAxisScale = this.niceScale(t, e, r, 0, s.tickAmount ? s.tickAmount : r < 5 && r > 1 ? r + 1 : 5) : a.xAxisScale = this.linearScale(0, 5, 5), a.xAxisScale; } }, { key: 'setMultipleYScales', value() { const t = this; const e = this.w.globals; const i = this.w.config; const a = e.minYArr.concat([]); const s = e.maxYArr.concat([]); const r = []; i.yaxis.forEach(((e, n) => { let o = n; i.series.forEach(((t, i) => { t.name === e.seriesName && (o = i, n !== i ? r.push({ index: i, similarIndex: n, alreadyExists: !0 }) : r.push({ index: i })); })); const l = a[o]; const h = s[o]; t.setYScaleForIndex(n, l, h); })), this.sameScaleInMultipleAxes(a, s, r); } }, { key: 'sameScaleInMultipleAxes', value(t, e, i) { const a = this; const s = this.w.config; const r = this.w.globals; let n = []; i.forEach(((t) => { t.alreadyExists && (void 0 === n[t.index] && (n[t.index] = []), n[t.index].push(t.index), n[t.index].push(t.similarIndex)); })), r.yAxisSameScaleIndices = n, n.forEach(((t, e) => { n.forEach(((i, a) => { let s; let r; e !== a && (s = t, r = i, s.filter(((t) => r.indexOf(t)!==-1))).length > 0 && (n[e] = n[e].concat(n[a])); })); })); const o = n.map(((t) => t.filter(((e, i) => t.indexOf(e) === i)))).map(((t) => t.sort())); n = n.filter(((t) => !!t)); let l = o.slice(); const h = l.map(((t) => JSON.stringify(t))); l = l.filter(((t, e) => h.indexOf(JSON.stringify(t)) === e)); const c = []; const d = []; t.forEach(((t, i) => { l.forEach(((a, s) => { a.indexOf(i) > -1 && (void 0 === c[s] && (c[s] = [], d[s] = []), c[s].push({ key: i, value: t }), d[s].push({ key: i, value: e[i] })); })); })); const g = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE); const u = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE); c.forEach(((t, e) => { t.forEach(((t, i) => { g[e] = Math.min(t.value, g[e]); })); })), d.forEach(((t, e) => { t.forEach(((t, i) => { u[e] = Math.max(t.value, u[e]); })); })), t.forEach(((t, e) => { d.forEach(((t, i) => { let n = g[i]; let o = u[i]; s.chart.stacked && (o = 0, t.forEach(((t, e) => { t.value !== -Number.MAX_VALUE && (o += t.value), n !== Number.MIN_VALUE && (n += c[i][e].value); }))), t.forEach(((i, l) => { t[l].key === e && (void 0 !== s.yaxis[e].min && (n = 'function' === typeof s.yaxis[e].min ? s.yaxis[e].min(r.minY) : s.yaxis[e].min), void 0 !== s.yaxis[e].max && (o = 'function' === typeof s.yaxis[e].max ? s.yaxis[e].max(r.maxY) : s.yaxis[e].max), a.setYScaleForIndex(e, n, o)); })); })); })); } }, { key: 'autoScaleY', value(t, e, i) { t || (t = this); const a = t.w; if (a.globals.isMultipleYAxis || a.globals.collapsedSeries.length) return console.warn('autoScaleYaxis is not supported in a multi-yaxis chart.'), e; const s = a.globals.seriesX[0]; const r = a.config.chart.stacked; return e.forEach(((t, n) => { for (var o = 0, l = 0; l < s.length; l++) if (s[l] >= i.xaxis.min) { o = l; break; } let h; let c; const d = a.globals.minYArr[n]; const g = a.globals.maxYArr[n]; const u = a.globals.stackedSeriesTotals; a.globals.series.forEach(((n, l) => { let f = n[o]; r ? (f = u[o], h = c = f, u.forEach(((t, e) => { s[e] <= i.xaxis.max && s[e] >= i.xaxis.min && (t > c && t !== null && (c = t), n[e] < h && n[e] !== null && (h = n[e])); }))) : (h = c = f, n.forEach(((t, e) => { if (s[e] <= i.xaxis.max && s[e] >= i.xaxis.min) { let r = t; let n = t; a.globals.series.forEach(((i, a) => { null !== t && (r = Math.min(i[e], r), n = Math.max(i[e], n)) })), n > c && n !== null && (c = n), r < h && r !== null && (h = r); } }))), void 0 === h && void 0 === c && (h = d, c = g), (c *= c < 0 ? 0.9 : 1.1) < 0 && c < g && (c = g), (h *= h < 0 ? 1.1 : 0.9) < 0 && h > d && (h = d), e.length > 1 ? (e[l].min = void 0 === t.min ? h : t.min, e[l].max = void 0 === t.max ? c : t.max) : (e[0].min = void 0 === t.min ? h : t.min, e[0].max = void 0 === t.max ? c : t.max); })); })), e; } }]), t; }()); const V = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.scales = new B(i); } return a(t, [{ key: 'init', value() { this.setYRange(), this.setXRange(), this.setZRange(); } }, {
      key: 'getMinYMaxY',
      value(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE; let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE; let a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; const s = this.w.config; const r = this.w.globals; let n = -Number.MAX_VALUE; let o = Number.MIN_VALUE; a === null && (a = t + 1); const l = r.series; let h = l; let c = l; s.chart.type === 'candlestick' ? (h = r.seriesCandleL, c = r.seriesCandleH) : r.isRangeData && (h = r.seriesRangeStart, c = r.seriesRangeEnd); for (let d = t; d < a; d++) { r.dataPoints = Math.max(r.dataPoints, l[d].length); for (let u = 0; u < r.series[d].length; u++) { let f = l[d][u]; f !== null && g.isNumber(f) ? (n = Math.max(n, c[d][u]), e = Math.min(e, h[d][u]), i = Math.max(i, h[d][u]), this.w.config.chart.type === 'candlestick' && (n = Math.max(n, r.seriesCandleO[d][u]), n = Math.max(n, r.seriesCandleH[d][u]), n = Math.max(n, r.seriesCandleL[d][u]), i = n = Math.max(n, r.seriesCandleC[d][u])), g.isFloat(f) && (f = g.noExponents(f), r.yValueDecimal = Math.max(r.yValueDecimal, f.toString().split('.')[1].length)), o > h[d][u] && h[d][u] < 0 && (o = h[d][u])) : r.hasNullValues = !0; } } return s.chart.type === 'rangeBar' && r.seriesRangeStart.length && s.xaxis.type === 'datetime' && (o = e), s.chart.type === 'bar' && (o < 0 && n < 0 && (n = 0), o === Number.MIN_VALUE && (o = 0)), {
          minY: o, maxY: n, lowestY: e, highestY: i,
        };
      },
    }, {
      key: 'setYRange',
      value() {
        const t = this.w.globals; const e = this.w.config; t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE; let i = Number.MAX_VALUE; if (t.isMultipleYAxis) for (let a = 0; a < t.series.length; a++) { const s = this.getMinYMaxY(a, i, null, a + 1); t.minYArr.push(s.minY), t.maxYArr.push(s.maxY), i = s.lowestY; } const r = this.getMinYMaxY(0, i, null, t.series.length); if (t.minY = r.minY, t.maxY = r.maxY, i = r.lowestY, e.chart.stacked && this._setStackedMinMax(), (e.chart.type === 'line' || e.chart.type === 'area' || e.chart.type === 'candlestick') && t.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t.maxY) { let n = t.maxY - i; i >= 0 && i <= 10 && (n = 0), t.minY = i - 5 * n / 100, i > 0 && t.minY < 0 && (t.minY = 0), t.maxY += 5 * n / 100; } if (e.yaxis.forEach(((e, i) => { void 0 !== e.max && (typeof e.max === 'number' ? t.maxYArr[i] = e.max : typeof e.max === 'function' && (t.maxYArr[i] = e.max(t.maxY)), t.maxY = t.maxYArr[i]), void 0 !== e.min && (typeof e.min === 'number' ? t.minYArr[i] = e.min : typeof e.min === 'function' && (t.minYArr[i] = e.min(t.minY)), t.minY = t.minYArr[i]); })), t.isBarHorizontal) { ['min', 'max'].forEach(((i) => { void 0 !== e.xaxis[i] && typeof e.xaxis[i] === 'number' && (i === 'min' ? t.minY = e.xaxis[i] : t.maxY = e.xaxis[i]); })); } return t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = i, t.yAxisScale.forEach(((e, i) => { t.minYArr[i] = e.niceMin, t.maxYArr[i] = e.niceMax; }))) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), {
          minY: t.minY, maxY: t.maxY, minYArr: t.minYArr, maxYArr: t.maxYArr,
        };
      },
    }, { key: 'setXRange', value() { const t = this.w.globals; const e = this.w.config; const i = e.xaxis.type === 'numeric' || e.xaxis.type === 'datetime' || e.xaxis.type === 'category' && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric; if (t.isXNumeric && (function () { for (let e = 0; e < t.series.length; e++) if (t.labels[e]) for (let i = 0; i < t.labels[e].length; i++)t.labels[e][i] !== null && g.isNumber(t.labels[e][i]) && (t.maxX = Math.max(t.maxX, t.labels[e][i]), t.initialMaxX = Math.max(t.maxX, t.labels[e][i]), t.minX = Math.min(t.minX, t.labels[e][i]), t.initialMinX = Math.min(t.minX, t.labels[e][i])); }()), t.noLabelsProvided && e.xaxis.categories.length === 0 && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) { let a; if (void 0 === e.xaxis.tickAmount ? (a = Math.round(t.svgWidth / 150), e.xaxis.type === 'numeric' && t.dataPoints < 30 && (a = t.dataPoints - 1), a > t.dataPoints && t.dataPoints !== 0 && (a = t.dataPoints - 1)) : e.xaxis.tickAmount === 'dataPoints' ? (t.series.length > 1 && (a = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (a = t.maxX - t.minX - 1)) : a = e.xaxis.tickAmount, t.xTickAmount = a, void 0 !== e.xaxis.max && typeof e.xaxis.max === 'number' && (t.maxX = e.xaxis.max), void 0 !== e.xaxis.min && typeof e.xaxis.min === 'number' && (t.minX = e.xaxis.min), void 0 !== e.xaxis.range && (t.minX = t.maxX - e.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE) if (e.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) { for (var s = [], r = t.minX - 1; r < t.maxX; r++)s.push(r + 1); t.xAxisScale = { result: s, niceMin: s[0], niceMax: s[s.length - 1] }; } else t.xAxisScale = this.scales.setXScale(t.minX, t.maxX); else t.xAxisScale = this.scales.linearScale(1, a, a), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, a - 1), t.seriesX = t.labels.slice()); i && (t.labels = t.xAxisScale.result.slice()); } return this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t.minX, maxX: t.maxX }; } }, { key: 'setZRange', value() { const t = this.w.globals; if (t.isDataXYZ) for (let e = 0; e < t.series.length; e++) if (void 0 !== t.seriesZ[e]) for (let i = 0; i < t.seriesZ[e].length; i++)t.seriesZ[e][i] !== null && g.isNumber(t.seriesZ[e][i]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[e][i]), t.minZ = Math.min(t.minZ, t.seriesZ[e][i])); } }, { key: '_handleSingleDataPoint', value() { const t = this.w.globals; const e = this.w.config; if (t.minX === t.maxX) { const i = new C(this.ctx); if (e.xaxis.type === 'datetime') { const a = i.getDate(t.minX); a.setUTCDate(a.getDate() - 2), t.minX = new Date(a).getTime(); const s = i.getDate(t.maxX); s.setUTCDate(s.getDate() + 2), t.maxX = new Date(s).getTime(); } else (e.xaxis.type === 'numeric' || e.xaxis.type === 'category' && !t.noLabelsProvided) && (t.minX -= 2, t.initialMinX = t.minX, t.maxX += 2, t.initialMaxX = t.maxX); } } }, { key: '_getMinXDiff', value() { const t = this.w.globals; t.isXNumeric && t.seriesX.forEach(((e, i) => { e.length === 1 && e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]); const a = e.slice(); a.sort(((t, e) => t - e)), a.forEach(((e, a) => { if (a > 0) { const s = e - t.seriesX[i][a - 1]; s > 0 && (t.minXDiff = Math.min(s, t.minXDiff)); } })), t.dataPoints === 1 && t.minXDiff === Number.MAX_VALUE && (t.minXDiff = 0.5); })); } }, { key: '_setStackedMinMax', value() { const t = this.w.globals; const e = []; const i = []; if (t.series.length) for (let a = 0; a < t.series[t.maxValsInArrayIndex].length; a++) for (let s = 0, r = 0, n = 0; n < t.series.length; n++)t.series[n][a] !== null && g.isNumber(t.series[n][a]) && (t.series[n][a] > 0 ? s = s + parseFloat(t.series[n][a]) + 1e-4 : r += parseFloat(t.series[n][a])), n === t.series.length - 1 && (e.push(s), i.push(r)); for (let o = 0; o < e.length; o++)t.maxY = Math.max(t.maxY, e[o]), t.minY = Math.min(t.minY, i[o]); } }]), t;
  }()); const G = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; const a = this.w; this.xaxisFontSize = a.config.xaxis.labels.style.fontSize, this.axisFontFamily = a.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = a.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = a.config.chart.type === 'bar' && a.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, a.config.xaxis.position === 'bottom' && (this.xAxisoffX = a.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new H(i); } return a(t, [{
      key: 'drawYaxis',
      value(t) {
        const e = this.w; const i = new p(this.ctx); const a = e.config.yaxis[t].labels.style; const s = a.fontSize; const r = a.fontFamily; const n = i.group({ class: 'apexcharts-yaxis', rel: t, transform: `translate(${e.globals.translateYAxisX[t]}, 0)` }); if (!e.config.yaxis[t].show) return n; const o = i.group({ class: 'apexcharts-yaxis-texts-g' }); n.add(o); const l = e.globals.yAxisScale[t].result.length - 1; const h = e.globals.gridHeight / l; let c = e.globals.translateY; const d = e.globals.yLabelFormatters[t]; let g = e.globals.yAxisScale[t].result.slice(); g = this.axesUtils.checkForReversedLabels(t, g); let u = ''; if (e.config.yaxis[t].labels.show) {
 for (let f = function (n) {
            let f = g[n]; f = d(f, n); let p = e.config.yaxis[t].labels.padding; e.config.yaxis[t].opposite && e.config.yaxis.length !== 0 && (p *= -1); const x = i.drawText({
              x: p, y: c + l / 10 + e.config.yaxis[t].labels.offsetY + 1, text: f, textAnchor: e.config.yaxis[t].opposite ? 'start' : 'end', fontSize: s, fontFamily: r, foreColor: Array.isArray(a.colors) ? a.colors[n] : a.colors, isPlainText: !1, cssClass: `apexcharts-yaxis-label ${a.cssClass}`, 
            }); if (n === l && (u = x), o.add(x), e.config.yaxis[t].labels.rotate !== 0) { const b = i.rotateAroundCenter(u.node); const m = i.rotateAroundCenter(x.node); x.node.setAttribute('transform', 'rotate('.concat(e.config.yaxis[t].labels.rotate, ' ').concat(b.x, ' ').concat(m.y, ')')); }c += h;
          }, x = l; x >= 0; x--)f(x); 
} if (void 0 !== e.config.yaxis[t].title.text) {
          const b = i.group({ class: 'apexcharts-yaxis-title' }); let m = 0; e.config.yaxis[t].opposite && (m = e.globals.translateYAxisX[t]); const v = i.drawText({
            x: m, y: e.globals.gridHeight / 2 + e.globals.translateY + e.config.yaxis[t].title.offsetY, text: e.config.yaxis[t].title.text, textAnchor: 'end', foreColor: e.config.yaxis[t].title.style.color, fontSize: e.config.yaxis[t].title.style.fontSize, fontWeight: e.config.yaxis[t].title.style.fontWeight, fontFamily: e.config.yaxis[t].title.style.fontFamily, cssClass: `apexcharts-yaxis-title-text ${e.config.yaxis[t].title.style.cssClass}`,
          }); b.add(v), n.add(b);
        } const y = e.config.yaxis[t].axisBorder; let w = 31 + y.offsetX; if (e.config.yaxis[t].opposite && (w = -31 - y.offsetX), y.show) { const k = i.drawLine(w, e.globals.translateY + y.offsetY - 2, w, e.globals.gridHeight + e.globals.translateY + y.offsetY + 2, y.color, 0, y.width); n.add(k); } return e.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(w, l, y, e.config.yaxis[t].axisTicks, t, h, n), n;
      },
    }, {
      key: 'drawYaxisInversed',
      value(t) {
        const e = this.w; const i = new p(this.ctx); const a = i.group({ class: 'apexcharts-xaxis apexcharts-yaxis-inversed' }); const s = i.group({ class: 'apexcharts-xaxis-texts-g', transform: 'translate('.concat(e.globals.translateXAxisX, ', ').concat(e.globals.translateXAxisY, ')') }); a.add(s); let r = e.globals.yAxisScale[t].result.length - 1; const n = e.globals.gridWidth / r + 0.1; let o = n + e.config.xaxis.labels.offsetX; const l = e.globals.xLabelFormatter; let h = e.globals.yAxisScale[t].result.slice(); const c = e.globals.timescaleLabels; c.length > 0 && (this.xaxisLabels = c.slice(), r = (h = c.slice()).length), h = this.axesUtils.checkForReversedLabels(t, h); const d = c.length; if (e.config.xaxis.labels.show) {
 for (let g = d ? 0 : r; d ? g < d : g >= 0; d ? g++ : g--) {
          let u = h[g]; u = l(u, g); let f = e.globals.gridWidth + e.globals.padHorizontal - (o - n + e.config.xaxis.labels.offsetX); if (c.length) { const x = this.axesUtils.getLabel(h, c, f, g, this.drawnLabels, this.xaxisFontSize); f = x.x, u = x.text, this.drawnLabels.push(x.text), g === 0 && e.globals.skipFirstTimelinelabel && (u = ''), g === h.length - 1 && e.globals.skipLastTimelinelabel && (u = ''); } const b = i.drawText({
            x: f, y: this.xAxisoffX + e.config.xaxis.labels.offsetY + 30, text: u, textAnchor: 'middle', foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, isPlainText: !1, cssClass: `apexcharts-xaxis-label ${e.config.xaxis.labels.style.cssClass}`, 
          }); s.add(b), b.tspan(u); const m = document.createElementNS(e.globals.SVGNS, 'title'); m.textContent = u, b.node.appendChild(m), o += n;
        } 
} return this.inversedYAxisTitleText(a), this.inversedYAxisBorder(a), a;
      },
    }, { key: 'inversedYAxisBorder', value(t) { const e = this.w; const i = new p(this.ctx); const a = e.config.xaxis.axisBorder; if (a.show) { let s = 0; e.config.chart.type === 'bar' && e.globals.isXNumeric && (s -= 15); const r = i.drawLine(e.globals.padHorizontal + s + a.offsetX, this.xAxisoffX, e.globals.gridWidth, this.xAxisoffX, a.color, 0, a.height); t.add(r); } } }, {
      key: 'inversedYAxisTitleText',
      value(t) {
        const e = this.w; const i = new p(this.ctx); if (void 0 !== e.config.xaxis.title.text) {
          const a = i.group({ class: 'apexcharts-xaxis-title apexcharts-yaxis-title-inversed' }); const s = i.drawText({
            x: e.globals.gridWidth / 2, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e.config.xaxis.title.style.fontSize) + 20, text: e.config.xaxis.title.text, textAnchor: 'middle', fontSize: e.config.xaxis.title.style.fontSize, fontFamily: e.config.xaxis.title.style.fontFamily, fontWeight: e.config.xaxis.title.style.fontWeight, cssClass: `apexcharts-xaxis-title-text ${e.config.xaxis.title.style.cssClass}`,
          }); a.add(s), t.add(a);
        }
      },
    }, { key: 'yAxisTitleRotate', value(t, e) { const i = this.w; const a = new p(this.ctx); let s = { width: 0, height: 0 }; let r = { width: 0, height: 0 }; const n = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g")); n !== null && (s = n.getBoundingClientRect()); const o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text")); if (o !== null && (r = o.getBoundingClientRect()), o !== null) { const l = this.xPaddingForYAxisTitle(t, s, r, e); o.setAttribute('x', l.xPos - (e ? 10 : 0)); } if (o !== null) { const h = a.rotateAroundCenter(o); o.setAttribute('transform', 'rotate('.concat(e ? '' : '-').concat(i.config.yaxis[t].title.rotate, ' ').concat(h.x, ' ').concat(h.y, ')')); } } }, { key: 'xPaddingForYAxisTitle', value(t, e, i, a) { const s = this.w; let r = 0; let n = 0; let o = 10; return void 0 === s.config.yaxis[t].title.text || t < 0 ? { xPos: n, padd: 0 } : (a ? (n = e.width + s.config.yaxis[t].title.offsetX + i.width / 2 + o / 2, (r += 1) === 0 && (n -= o / 2)) : (n = -1 * e.width + s.config.yaxis[t].title.offsetX + o / 2 + i.width / 2, s.globals.isBarHorizontal && (o = 25, n = -1 * e.width - s.config.yaxis[t].title.offsetX - o)), { xPos: n, padd: o }); } }, { key: 'setYAxisXPosition', value(t, e) { const i = this.w; let a = 0; let s = 0; let r = 18; let n = 1; i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map(((o, l) => { const h = i.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !o.show || o.floating || t[l].width === 0; const c = t[l].width + e[l].width; o.opposite ? i.globals.isBarHorizontal ? (s = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[l] = s - o.labels.offsetX) : (s = i.globals.gridWidth + i.globals.translateX + n, h || (n = n + c + 20), i.globals.translateYAxisX[l] = s - o.labels.offsetX + 20) : (a = i.globals.translateX - r, h || (r = r + c + 20), i.globals.translateYAxisX[l] = a + o.labels.offsetX); })); } }, { key: 'setYAxisTextAlignments', value() { const t = this.w; let e = t.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis'); (e = g.listToArray(e)).forEach(((e, i) => { const a = t.config.yaxis[i]; if (void 0 !== a.labels.align) { const s = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")); let r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label")); r = g.listToArray(r); const n = s.getBoundingClientRect(); a.labels.align === 'left' ? (r.forEach(((t, e) => { t.setAttribute('text-anchor', 'start'); })), a.opposite || s.setAttribute('transform', 'translate(-'.concat(n.width, ', 0)'))) : a.labels.align === 'center' ? (r.forEach(((t, e) => { t.setAttribute('text-anchor', 'middle'); })), s.setAttribute('transform', 'translate('.concat(n.width / 2 * (a.opposite ? 1 : -1), ', 0)'))) : a.labels.align === 'right' && (r.forEach(((t, e) => { t.setAttribute('text-anchor', 'end'); })), a.opposite && s.setAttribute('transform', 'translate('.concat(n.width, ', 0)'))); } })); } }]), t;
  }()); const _ = (function () { function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.documentEvent = g.bind(this.documentEvent, this); } return a(t, [{ key: 'addEventListener', value(t, e) { const i = this.w; i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(e) : i.globals.events[t] = [e]; } }, { key: 'removeEventListener', value(t, e) { const i = this.w; if (i.globals.events.hasOwnProperty(t)) { const a = i.globals.events[t].indexOf(e); a !== -1 && i.globals.events[t].splice(a, 1); } } }, { key: 'fireEvent', value(t, e) { const i = this.w; if (i.globals.events.hasOwnProperty(t)) { e && e.length || (e = []); for (let a = i.globals.events[t], s = a.length, r = 0; r < s; r++)a[r].apply(null, e); } } }, { key: 'setupEventHandlers', value() { const t = this; const e = this.w; const i = this.ctx; const a = e.globals.dom.baseEl.querySelector(e.globals.chartClass); this.ctx.eventList.forEach(((t) => { a.addEventListener(t, ((t) => { const a = { ...e, seriesIndex: e.globals.capturedSeriesIndex, dataPointIndex: e.globals.capturedDataPointIndex }; t.type === 'mousemove' || t.type === 'touchmove' ? typeof e.config.chart.events.mouseMove === 'function' && e.config.chart.events.mouseMove(t, i, a) : (t.type === 'mouseup' && t.which === 1 || t.type === 'touchend') && (typeof e.config.chart.events.click == 'function' && e.config.chart.events.click(t, i, a), i.ctx.events.fireEvent('click', [t, i, a])); }), { capture: !1, passive: !0 }); })), this.ctx.eventList.forEach(((e) => { document.addEventListener(e, t.documentEvent); })), this.ctx.core.setupBrushHandler(); } }, { key: 'documentEvent', value(t) { const e = this.w; if (t.type === 'click') { const i = t.target.className; const a = e.globals.dom.baseEl.querySelector('.apexcharts-menu'); a && a.classList.contains('apexcharts-menu-open') && i !== 'apexcharts-menu-icon' && a.classList.remove('apexcharts-menu-open'); }e.globals.clientX = t.type === 'touchmove' ? t.touches[0].clientX : t.clientX, e.globals.clientY = t.type === 'touchmove' ? t.touches[0].clientY : t.clientY; } }]), t; }()); const j = (function () { function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'setCurrentLocaleValues', value(t) { let e = this.w.config.chart.locales; window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e = this.w.config.chart.locales.concat(window.Apex.chart.locales)); const i = e.filter(((e) => e.name === t))[0]; if (!i) throw new Error('Wrong locale name provided. Please make sure you set the correct locale name in options'); const a = g.extend(k, i); this.w.globals.locale = a.options; } }]), t; }()); const U = (function () { function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'drawAxis', value(t, e) { let i; let a; const s = this.w.globals; const r = this.w.config; const n = new O(this.ctx); const o = new G(this.ctx); s.axisCharts && t !== 'radar' && (s.isBarHorizontal ? (a = o.drawYaxisInversed(0), i = n.drawXaxisInversed(0), s.dom.elGraphical.add(i), s.dom.elGraphical.add(a)) : (i = n.drawXaxis(), s.dom.elGraphical.add(i), r.yaxis.map(((t, e) => { s.ignoreYAxisIndexes.indexOf(e) === -1 && (a = o.drawYaxis(e), s.dom.Paper.add(a)); })))); r.yaxis.map(((t, e) => { s.ignoreYAxisIndexes.indexOf(e) === -1 && o.yAxisTitleRotate(e, t.opposite); })); } }]), t; }()); const q = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{
      key: 'drawXCrosshairs',
      value() {
        const t = this.w; const e = new p(this.ctx); const i = new u(this.ctx); const a = t.config.xaxis.crosshairs.fill.gradient; const s = t.config.xaxis.crosshairs.dropShadow; const r = t.config.xaxis.crosshairs.fill.type; const n = a.colorFrom; const o = a.colorTo; const l = a.opacityFrom; const h = a.opacityTo; const c = a.stops; const d = s.enabled; const f = s.left; const x = s.top; const b = s.blur; const m = s.color; const v = s.opacity; let y = t.config.xaxis.crosshairs.fill.color; if (t.config.xaxis.crosshairs.show) {
          r === 'gradient' && (y = e.drawGradient('vertical', n, o, l, h, null, c, null)); let w = e.drawRect(); t.config.xaxis.crosshairs.width === 1 && (w = e.drawLine()), w.attr({
            class: 'apexcharts-xcrosshairs', x: 0, y: 0, y2: t.globals.gridHeight, width: g.isNumber(t.config.xaxis.crosshairs.width) ? t.config.xaxis.crosshairs.width : 0, height: t.globals.gridHeight, fill: y, filter: 'none', 'fill-opacity': t.config.xaxis.crosshairs.opacity, stroke: t.config.xaxis.crosshairs.stroke.color, 'stroke-width': t.config.xaxis.crosshairs.stroke.width, 'stroke-dasharray': t.config.xaxis.crosshairs.stroke.dashArray,
          }), d && (w = i.dropShadow(w, {
            left: f, top: x, blur: b, color: m, opacity: v,
          })), t.globals.dom.elGraphical.add(w);
        }
      },
    }, { key: 'drawYCrosshairs', value() { const t = this.w; const e = new p(this.ctx); const i = t.config.yaxis[0].crosshairs; if (t.config.yaxis[0].crosshairs.show) { const a = e.drawLine(0, 0, t.globals.gridWidth, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width); a.attr({ class: 'apexcharts-ycrosshairs' }), t.globals.dom.elGraphical.add(a); } const s = e.drawLine(0, 0, t.globals.gridWidth, 0, i.stroke.color, 0, 0); s.attr({ class: 'apexcharts-ycrosshairs-hidden' }), t.globals.dom.elGraphical.add(s); } }]), t;
  }()); const Z = (function () { function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'checkResponsiveConfig', value(t) { const e = this; const i = this.w; const a = i.config; if (a.responsive.length !== 0) { const s = a.responsive.slice(); s.sort(((t, e) => (t.breakpoint > e.breakpoint ? 1 : e.breakpoint > t.breakpoint ? -1 : 0))).reverse(); const r = new P({}); const n = function () { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const a = s[0].breakpoint; const n = window.innerWidth > 0 ? window.innerWidth : screen.width; if (n > a) { const o = I.extendArrayProps(r, i.globals.initialConfig); t = g.extend(o, t), t = g.extend(i.config, t), e.overrideResponsiveOptions(t); } else for (let l = 0; l < s.length; l++)n < s[l].breakpoint && (t = I.extendArrayProps(r, s[l].options), t = g.extend(i.config, t), e.overrideResponsiveOptions(t)); }; if (t) { let o = I.extendArrayProps(r, t); o = g.extend(i.config, o), n(o = g.extend(o, t)); } else n({}); } } }, { key: 'overrideResponsiveOptions', value(t) { const e = new P(t).init({ responsiveOverride: !0 }); this.w.config = e; } }]), t; }()); const $ = (function () {
 function t(i) { e(this, t), this.ctx = i, this.colors = [], this.w = i.w; const a = this.w; this.isColorFn = !1, this.isBarDistributed = a.config.plotOptions.bar.distributed && (a.config.chart.type === 'bar' || a.config.chart.type === 'rangeBar'); } return a(t, [{ key: 'init', value() { this.setDefaultColors(); } }, {
 key: 'setDefaultColors',
value() {
 const t = this; const e = this.w; const i = new g(); if (e.globals.dom.elWrap.classList.add('apexcharts-theme-'.concat(e.config.theme.mode)), void 0 === e.config.colors ? e.globals.colors = this.predefined() : (e.globals.colors = e.config.colors, e.globals.axisCharts && e.config.chart.type !== 'bar' && Array.isArray(e.config.colors) && e.config.colors.length > 0 && e.config.colors.length === e.config.series.length && (e.globals.colors = e.config.colors.map(((i, a) => (typeof i=='function' ? (t.isColorFn = !0, i({
 value: e.globals.axisCharts ? e.globals.series[a][0] ? e.globals.series[a][0] : 0 : e.globals.series[a], seriesIndex: a, dataPointIndex: a, w: e 
})) : i))))), e.config.theme.monochrome.enabled) { const a = []; let s = e.globals.series.length; this.isBarDistributed && (s = e.globals.series[0].length * e.globals.series.length); for (let r = e.config.theme.monochrome.color, n = 1 / (s / e.config.theme.monochrome.shadeIntensity), o = e.config.theme.monochrome.shadeTo, l = 0, h = 0; h < s; h++) { let c = void 0; o === 'dark' ? (c = i.shadeColor(-1 * l, r), l += n) : (c = i.shadeColor(l, r), l += n), a.push(c); }e.globals.colors = a.slice(); } const d = e.globals.colors.slice(); this.pushExtraColors(e.globals.colors); ['fill', 'stroke'].forEach(((i) => { void 0 === e.config[i].colors ? e.globals[i].colors = t.isColorFn ? e.config.colors : d : e.globals[i].colors = e.config[i].colors.slice(), t.pushExtraColors(e.globals[i].colors); })), void 0 === e.config.dataLabels.style.colors ? e.globals.dataLabels.style.colors = d : e.globals.dataLabels.style.colors = e.config.dataLabels.style.colors.slice(), this.pushExtraColors(e.globals.dataLabels.style.colors, 50), void 0 === e.config.plotOptions.radar.polygons.fill.colors ? e.globals.radarPolygons.fill.colors = [e.config.theme.mode === 'dark' ? '#202D48' : '#fff'] : e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors, this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20), void 0 === e.config.markers.colors ? e.globals.markers.colors = d : e.globals.markers.colors = e.config.markers.colors, this.pushExtraColors(e.globals.markers.colors); 
} 
}, { key: 'pushExtraColors', value(t, e) { let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const a = this.w; let s = e || a.globals.series.length; if (i === null && (i = this.isBarDistributed || a.config.chart.type === 'heatmap' && a.config.plotOptions.heatmap.colorScale.inverse), i && (s = a.globals.series[0].length * a.globals.series.length), t.length < s) for (let r = s - t.length, n = 0; n < r; n++)t.push(t[n]); } }, { key: 'updateThemeOptions', value(t) { t.chart = t.chart || {}, t.tooltip = t.tooltip || {}; const e = t.theme.mode || 'light'; const i = t.theme.palette ? t.theme.palette : e === 'dark' ? 'palette4' : 'palette1'; const a = t.chart.foreColor ? t.chart.foreColor : e === 'dark' ? '#f6f7f8' : '#373d3f'; return t.tooltip.theme = e, t.chart.foreColor = a, t.theme.palette = i, t; } }, { key: 'predefined', value() { switch (this.w.config.theme.palette) { case 'palette1': this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0']; break; case 'palette2': this.colors = ['#3f51b5', '#03a9f4', '#4caf50', '#f9ce1d', '#FF9800']; break; case 'palette3': this.colors = ['#33b2df', '#546E7A', '#d4526e', '#13d8aa', '#A5978B']; break; case 'palette4': this.colors = ['#4ecdc4', '#c7f464', '#81D4FA', '#fd6a6a', '#546E7A']; break; case 'palette5': this.colors = ['#2b908f', '#f9a3a4', '#90ee7e', '#fa4443', '#69d2e7']; break; case 'palette6': this.colors = ['#449DD1', '#F86624', '#EA3546', '#662E9B', '#C5D86D']; break; case 'palette7': this.colors = ['#D7263D', '#1B998B', '#2E294E', '#F46036', '#E2C044']; break; case 'palette8': this.colors = ['#662E9B', '#F86624', '#F9C80E', '#EA3546', '#43BCCD']; break; case 'palette9': this.colors = ['#5C4742', '#A5978B', '#8D5B4C', '#5A2A27', '#C4BBAF']; break; case 'palette10': this.colors = ['#A300D6', '#7D02EB', '#5653FE', '#2983FF', '#00B1F2']; break; default: this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0']; } return this.colors; } }]), t; 
}()); const J = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'draw', value() { this.drawTitleSubtitle('title'), this.drawTitleSubtitle('subtitle'); } }, {
      key: 'drawTitleSubtitle',
      value(t) {
        const e = this.w; const i = t === 'title' ? e.config.title : e.config.subtitle; let a = e.globals.svgWidth / 2; let s = i.offsetY; let r = 'middle'; if (i.align === 'left' ? (a = 10, r = 'start') : i.align === 'right' && (a = e.globals.svgWidth - 10, r = 'end'), a += i.offsetX, s = s + parseInt(i.style.fontSize, 10) + i.margin / 2, void 0 !== i.text) {
          const n = new p(this.ctx).drawText({
            x: a, y: s, text: i.text, textAnchor: r, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, fontWeight: i.style.fontWeight, foreColor: i.style.color, opacity: 1,
          }); n.node.setAttribute('class', 'apexcharts-'.concat(t, '-text')), e.globals.dom.Paper.add(n);
        }
      },
    }]), t;
  }()); const Q = (function () {
    function t(i) { e(this, t), this.w = i.w, this.dCtx = i; } return a(t, [{ key: 'getTitleSubtitleCoords', value(t) { const e = this.w; let i = 0; let a = 0; const s = t === 'title' ? e.config.title.floating : e.config.subtitle.floating; const r = e.globals.dom.baseEl.querySelector('.apexcharts-'.concat(t, '-text')); if (r !== null && !s) { const n = r.getBoundingClientRect(); i = n.width, a = e.globals.axisCharts ? n.height + 5 : n.height; } return { width: i, height: a }; } }, {
      key: 'getLegendsRect',
      value() {
        const t = this.w; const e = t.globals.dom.baseEl.querySelector('.apexcharts-legend'); const i = { ...g.getBoundingClientRect(e) }; return e !== null && !t.config.legend.floating && t.config.legend.show ? this.dCtx.lgRect = {
          x: i.x, y: i.y, height: i.height, width: i.height === 0 ? 0 : i.width,
        } : this.dCtx.lgRect = {
          x: 0, y: 0, height: 0, width: 0,
        }, t.config.legend.position !== 'left' && t.config.legend.position !== 'right' || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect;
      },
    }, { key: 'getLargestStringFromMultiArr', value(t, e) { let i = t; if (this.w.globals.isMultiLineX) { const a = e.map(((t, e) => (Array.isArray(t) ? t.length : 1))); const s = Math.max.apply(Math, d(a)); i = e[a.indexOf(s)]; } return i; } }]), t;
  }()); const K = (function () { function t(i) { e(this, t), this.w = i.w, this.dCtx = i; } return a(t, [{ key: 'getxAxisLabelsCoords', value() { let t; const e = this.w; let i = e.globals.labels.slice(); if (e.config.xaxis.convertedCatToNumeric && i.length === 0 && (i = e.globals.categoryLabels), e.globals.timescaleLabels.length > 0) { const a = this.getxAxisTimeScaleLabelsCoords(); t = { width: a.width, height: a.height }, e.globals.rotateXLabels = !1; } else { this.dCtx.lgWidthForSideLegends = e.config.legend.position !== 'left' && e.config.legend.position !== 'right' || e.config.legend.floating ? 0 : this.dCtx.lgRect.width; const s = e.globals.xLabelFormatter; let r = g.getLargestStringFromArr(i); let n = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, i); e.globals.isBarHorizontal && (n = r = e.globals.yAxisScale[0].result.reduce(((t, e) => (t.length > e.length ? t : e)), 0)); const o = new R(this.dCtx.ctx); const l = r; r = o.xLabelFormat(s, r, l), n = o.xLabelFormat(s, n, l), e.config.xaxis.convertedCatToNumeric && void 0 === r && (n = r = '1'); const h = new p(this.dCtx.ctx); let c = h.getTextRects(r, e.config.xaxis.labels.style.fontSize); let d = c; if (r !== n && (d = h.getTextRects(n, e.config.xaxis.labels.style.fontSize)), (t = { width: c.width >= d.width ? c.width : d.width, height: c.height >= d.height ? c.height : d.height }).width * i.length > e.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && e.config.xaxis.labels.rotate !== 0 || e.config.xaxis.labels.rotateAlways) { if (!e.globals.isBarHorizontal) { e.globals.rotateXLabels = !0; const u = function (t) { return h.getTextRects(t, e.config.xaxis.labels.style.fontSize, e.config.xaxis.labels.style.fontFamily, 'rotate('.concat(e.config.xaxis.labels.rotate, ' 0 0)'), !1); }; c = u(r), r !== n && (d = u(n)), t.height = (c.height > d.height ? c.height : d.height) / 1.5, t.width = c.width > d.width ? c.width : d.width; } } else e.globals.rotateXLabels = !1; } return e.config.xaxis.labels.show || (t = { width: 0, height: 0 }), { width: t.width, height: t.height }; } }, { key: 'getxAxisTitleCoords', value() { const t = this.w; let e = 0; let i = 0; if (void 0 !== t.config.xaxis.title.text) { const a = new p(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize); e = a.width, i = a.height; } return { width: e, height: i }; } }, { key: 'getxAxisTimeScaleLabelsCoords', value() { let t; const e = this.w; this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice(); const i = this.dCtx.timescaleLabels.map(((t) => t.value)); const a = i.reduce(((t, e) => (void 0 === t ? (console.error('You have possibly supplied invalid Date format. Please supply a valid JavaScript Date'), 0) : t.length > e.length ? t : e)), 0); return 1.05 * (t = new p(this.dCtx.ctx).getTextRects(a, e.config.xaxis.labels.style.fontSize)).width * i.length > e.globals.gridWidth && e.config.xaxis.labels.rotate !== 0 && (e.globals.overlappingXLabels = !0), t; } }, { key: 'additionalPaddingXLabels', value(t) { const e = this; const i = this.w; const a = i.globals; const s = i.config; const r = s.xaxis.type; const n = t.width; a.skipLastTimelinelabel = !1, a.skipFirstTimelinelabel = !1; const o = i.config.yaxis[0].opposite && i.globals.isBarHorizontal; const l = function (t, o) { (function (t) { return a.collapsedSeriesIndices.indexOf(t) !== -1; }(o)) || (r !== 'datetime' && e.dCtx.gridPad.left < n / 2 - e.dCtx.yAxisWidthLeft && !a.rotateXLabels && !s.xaxis.labels.trim && (e.dCtx.xPadLeft = n / 2 + 1), (function (t) { if (e.dCtx.timescaleLabels && e.dCtx.timescaleLabels.length) { const s = e.dCtx.timescaleLabels[0]; const o = e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length - 1].position + n / 1.75 + e.dCtx.yAxisWidthRight; const l = s.position - n / 1.75 + (t.opposite ? 0 : e.dCtx.yAxisWidthLeft); o > a.gridWidth && (a.skipLastTimelinelabel = !0), l < 0 && (a.skipFirstTimelinelabel = !0); } else r === 'datetime' ? e.dCtx.gridPad.right < n && !a.rotateXLabels && (a.skipLastTimelinelabel = !0) : r !== 'datetime' && e.dCtx.gridPad.right < n / 2 - e.dCtx.yAxisWidthRight && !a.rotateXLabels && (i.config.xaxis.tickPlacement !== 'between' || i.globals.isBarHorizontal) && (e.dCtx.xPadRight = n / 2 + 1); }(t))); }; s.yaxis.forEach(((t, i) => { o ? (e.dCtx.gridPad.left < n && (e.dCtx.xPadLeft = n / 2 + 1), e.dCtx.xPadRight = n / 2 + 1) : l(t, i); })); } }]), t; }()); const tt = (function () { function t(i) { e(this, t), this.w = i.w, this.dCtx = i; } return a(t, [{ key: 'getyAxisLabelsCoords', value() { const t = this; const e = this.w; const i = []; let a = 10; return e.config.yaxis.map(((s, r) => { if (s.show && s.labels.show && e.globals.yAxisScale[r].result.length) { const n = e.globals.yLabelFormatters[r]; let o = n(e.globals.yAxisScale[r].niceMax, { seriesIndex: r, dataPointIndex: -1, w: e }); let l = o; if (void 0 !== o && o.length !== 0 || (o = e.globals.yAxisScale[r].niceMax), e.globals.isBarHorizontal) { a = 0; const h = e.globals.labels.slice(); o = n(o = g.getLargestStringFromArr(h), { seriesIndex: r, dataPointIndex: -1, w: e }), l = t.dCtx.dimHelpers.getLargestStringFromMultiArr(o, h); } const c = new p(t.dCtx.ctx); const d = c.getTextRects(o, s.labels.style.fontSize); let u = d; o !== l && (u = c.getTextRects(l, s.labels.style.fontSize)), i.push({ width: (u.width > d.width ? u.width : d.width) + a, height: u.height > d.height ? u.height : d.height }); } else i.push({ width: 0, height: 0 }); })), i; } }, { key: 'getyAxisTitleCoords', value() { const t = this; const e = this.w; const i = []; return e.config.yaxis.map(((e, a) => { if (e.show && void 0 !== e.title.text) { const s = new p(t.dCtx.ctx).getTextRects(e.title.text, e.title.style.fontSize, e.title.style.fontFamily, 'rotate(-90 0 0)', !1); i.push({ width: s.width, height: s.height }); } else i.push({ width: 0, height: 0 }); })), i; } }, { key: 'getTotalYAxisWidth', value() { const t = this.w; let e = 0; let i = 0; let a = 0; const s = t.globals.yAxisScale.length > 1 ? 10 : 0; const r = function (r, n) { const o = t.config.yaxis[n].floating; let l = 0; r.width > 0 && !o ? (l = r.width + s, (function (e) { return t.globals.ignoreYAxisIndexes.indexOf(e) > -1; }(n)) && (l = l - r.width - s)) : l = o || !t.config.yaxis[n].show ? 0 : 5, t.config.yaxis[n].opposite ? a += l : i += l, e += l; }; return t.globals.yLabelsCoords.map(((t, e) => { r(t, e); })), t.globals.yTitleCoords.map(((t, e) => { r(t, e); })), t.globals.isBarHorizontal && (e = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = a, e; } }]), t; }()); const et = (function () { function t(i) { e(this, t), this.w = i.w, this.dCtx = i; } return a(t, [{ key: 'gridPadForColumnsInNumericAxis', value(t) { const e = this.w; if (e.globals.noData) return 0; const i = e.config.chart.type; let a = 0; let s = i === 'bar' || i === 'rangeBar' ? e.config.series.length : 1; if (e.globals.comboBarCount > 0 && (s = e.globals.comboBarCount), e.globals.collapsedSeries.forEach(((t) => { t.type !== 'bar' && t.type !== 'rangeBar' || (s -= 1); })), e.config.chart.stacked && (s = 1), (i === 'bar' || i === 'rangeBar' || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && s > 0) { let r; let n; let o = Math.abs(e.globals.initialMaxX - e.globals.initialMinX); o <= 3 && (o = e.globals.dataPoints), r = o / t, e.globals.minXDiff && e.globals.minXDiff / r > 0 && (n = e.globals.minXDiff / r), (a = n / s * parseInt(e.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (a = 1), a = a / (s > 1 ? 1 : 1.5) + 5, e.globals.barPadForNumericAxis = a; } return a; } }, { key: 'gridPadFortitleSubtitle', value() { const t = this; const e = this.w; const i = e.globals; let a = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10; ['title', 'subtitle'].forEach(((i) => { void 0 !== e.config[i].text ? a += e.config[i].margin : a += t.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5; })); const s = e.config.series.length > 1 || !e.globals.axisCharts || e.config.legend.showForSingleSeries; e.config.legend.show && e.config.legend.position === 'bottom' && !e.config.legend.floating && s && (a += 10); const r = this.dCtx.dimHelpers.getTitleSubtitleCoords('title'); const n = this.dCtx.dimHelpers.getTitleSubtitleCoords('subtitle'); i.gridHeight = i.gridHeight - r.height - n.height - a, i.translateY = i.translateY + r.height + n.height + a; } }, { key: 'setGridXPosForDualYAxis', value(t, e) { const i = this.w; i.config.yaxis.map(((a, s) => { i.globals.ignoreYAxisIndexes.indexOf(s) === -1 && !i.config.yaxis[s].floating && i.config.yaxis[s].show && a.opposite && (i.globals.translateX = i.globals.translateX - (e[s].width + t[s].width) - parseInt(i.config.yaxis[s].labels.style.fontSize, 10) / 1.2 - 12); })); } }]), t; }()); const it = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new Q(this), this.dimYAxis = new tt(this), this.dimXAxis = new K(this), this.dimGrid = new et(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0; } return a(t, [{ key: 'plotCoords', value() { const t = this.w.globals; this.lgRect = this.dimHelpers.getLegendsRect(), t.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), t.gridHeight = t.gridHeight - this.gridPad.top - this.gridPad.bottom, t.gridWidth = t.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft; const e = this.dimGrid.gridPadForColumnsInNumericAxis(t.gridWidth); t.gridWidth -= 2 * e, t.translateX = t.translateX + this.gridPad.left + this.xPadLeft + (e > 0 ? e + 4 : 0), t.translateY += this.gridPad.top; } }, { key: 'setDimensionsForAxisCharts', value() { const t = this; const e = this.w; const i = e.globals; const a = this.dimYAxis.getyAxisLabelsCoords(); const s = this.dimYAxis.getyAxisTitleCoords(); e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map(((t, i) => { e.globals.yLabelsCoords.push({ width: a[i].width, index: i }), e.globals.yTitleCoords.push({ width: s[i].width, index: i }); })), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth(); const r = this.dimXAxis.getxAxisLabelsCoords(); const n = this.dimXAxis.getxAxisTitleCoords(); this.conditionalChecksForAxisCoords(r, n), i.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY += e.config.xaxis.labels.offsetY, i.translateXAxisX += e.config.xaxis.labels.offsetX; let o = this.yAxisWidth; let l = this.xAxisHeight; i.xAxisLabelsHeight = this.xAxisHeight, i.xAxisHeight = this.xAxisHeight; let h = 10; (e.config.chart.type === 'radar' || this.isSparkline) && (o = 0, l = i.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }, l = 0, o = 0, h = 0), this.dimXAxis.additionalPaddingXLabels(r); const c = function () { i.translateX = o, i.gridHeight = i.svgHeight - t.lgRect.height - l - (t.isSparkline ? 0 : e.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - o; }; switch (e.config.legend.position) { case 'bottom': i.translateY = h, c(); break; case 'top': i.translateY = this.lgRect.height + h, c(); break; case 'left': i.translateY = h, i.translateX = this.lgRect.width + o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o; break; case 'right': i.translateY = h, i.translateX = o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o - 5; break; default: throw new Error('Legend position not supported'); } this.dimGrid.setGridXPosForDualYAxis(s, a), new G(this.ctx).setYAxisXPosition(a, s); } }, {
      key: 'setDimensionsForNonAxisCharts',
      value() {
        const t = this.w; const e = t.globals; const i = t.config; let a = 0; t.config.legend.show && !t.config.legend.floating && (a = 20); const s = i.chart.type === 'pie' || i.chart.type === 'donut' ? 'pie' : 'radialBar'; const r = i.plotOptions[s].offsetY; const
          n = i.plotOptions[s].offsetX; if (!i.legend.show || i.legend.floating) return e.gridHeight = e.svgHeight - i.grid.padding.left + i.grid.padding.right, e.gridWidth = e.gridHeight, e.translateY = r, void (e.translateX = n + (e.svgWidth - e.gridWidth) / 2); switch (i.legend.position) { case 'bottom': e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.gridHeight, e.translateY = r - 10, e.translateX = n + (e.svgWidth - e.gridWidth) / 2; break; case 'top': e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.gridHeight, e.translateY = this.lgRect.height + r + 10, e.translateX = n + (e.svgWidth - e.gridWidth) / 2; break; case 'left': e.gridWidth = e.svgWidth - this.lgRect.width - a, e.gridHeight = i.chart.height !== 'auto' ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = n + this.lgRect.width + a; break; case 'right': e.gridWidth = e.svgWidth - this.lgRect.width - a - 5, e.gridHeight = i.chart.height !== 'auto' ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = n + 10; break; default: throw new Error('Legend position not supported'); }
      },
    }, { key: 'conditionalChecksForAxisCoords', value(t, e) { const i = this.w; this.xAxisHeight = (t.height + e.height) * (i.globals.isMultiLineX ? 1.2 : i.globals.LINE_HEIGHT_RATIO) + (i.globals.rotateXLabels ? 22 : 10), this.xAxisWidth = t.width, this.xAxisHeight - e.height > i.config.xaxis.labels.maxHeight && (this.xAxisHeight = i.config.xaxis.labels.maxHeight), i.config.xaxis.labels.minHeight && this.xAxisHeight < i.config.xaxis.labels.minHeight && (this.xAxisHeight = i.config.xaxis.labels.minHeight), i.config.xaxis.floating && (this.xAxisHeight = 0); let a = 0; let s = 0; i.config.yaxis.forEach(((t) => { a += t.labels.minWidth, s += t.labels.maxWidth; })), this.yAxisWidth < a && (this.yAxisWidth = a), this.yAxisWidth > s && (this.yAxisWidth = s); } }]), t;
  }()); const at = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels; const a = this.w; this.lineColorArr = void 0 !== a.globals.stroke.colors ? a.globals.stroke.colors : a.globals.colors, this.defaultSize = a.globals.svgHeight < a.globals.svgWidth ? a.globals.gridHeight : a.globals.gridWidth, this.centerY = this.defaultSize / 2, this.centerX = a.globals.gridWidth / 2, this.fullAngle = 360, a.globals.radialSize = this.defaultSize / 2.05 - a.config.stroke.width - (a.config.chart.sparkline.enabled ? 0 : a.config.chart.dropShadow.blur), this.donutSize = a.globals.radialSize * parseInt(a.config.plotOptions.pie.donut.size, 10) / 100, this.sliceLabels = [], this.prevSectorAngleArr = []; } return a(t, [{
      key: 'draw',
      value(t) {
        const e = this.w; const i = new p(this.ctx); const a = i.group({ class: 'apexcharts-pie' }); if (e.globals.noData) return a; for (var s = 0, r = 0; r < t.length; r++)s += g.negToZero(t[r]); const n = []; const o = i.group(); s === 0 && (s = 1e-5); for (let l = 0; l < t.length; l++) { const h = this.fullAngle * g.negToZero(t[l]) / s; n.push(h); } if (e.globals.dataChanged) { for (var c, d = 0, u = 0; u < e.globals.previousPaths.length; u++)d += g.negToZero(e.globals.previousPaths[u]); for (let f = 0; f < e.globals.previousPaths.length; f++)c = this.fullAngle * g.negToZero(e.globals.previousPaths[f]) / d, this.prevSectorAngleArr.push(c); } this.donutSize < 0 && (this.donutSize = 0); const x = e.config.plotOptions.pie.customScale; const b = e.globals.gridWidth / 2; const m = e.globals.gridHeight / 2; const v = b - e.globals.gridWidth / 2 * x; const y = m - e.globals.gridHeight / 2 * x; if (e.config.chart.type === 'donut') { const w = i.drawCircle(this.donutSize); w.attr({ cx: this.centerX, cy: this.centerY, fill: e.config.plotOptions.pie.donut.background ? e.config.plotOptions.pie.donut.background : 'transparent' }), o.add(w); } const k = this.drawArcs(n, t); if (this.sliceLabels.forEach(((t) => { k.add(t); })), o.attr({ transform: 'translate('.concat(v, ', ').concat(y, ') scale(').concat(x, ')') }), o.add(k), a.add(o), this.donutDataLabels.show) {
          const A = this.renderInnerDataLabels(this.donutDataLabels, {
            hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: v, translateY: y,
          }); a.add(A);
        } return a;
      },
    }, {
      key: 'drawArcs',
      value(t, e) {
        const i = this.w; const a = new u(this.ctx); const s = new p(this.ctx); const r = new M(this.ctx); const n = s.group({ class: 'apexcharts-slices' }); let o = 0; let l = 0; let h = 0; let c = 0; this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0; for (let d = 0; d < t.length; d++) {
          const f = s.group({
            class: 'apexcharts-series apexcharts-pie-series', seriesName: g.escapeString(i.globals.seriesNames[d]), rel: d + 1, 'data:realIndex': d,
          }); n.add(f), l = c, h = (o = h) + t[d], c = l + this.prevSectorAngleArr[d]; const x = h - o; const b = r.fillPath({ seriesNumber: d, size: i.globals.radialSize, value: e[d] }); const m = this.getChangedPath(l, c); const v = s.drawPath({
            d: m, stroke: this.lineColorArr instanceof Array ? this.lineColorArr[d] : this.lineColorArr, strokeWidth: 0, fill: b, fillOpacity: i.config.fill.opacity, classes: 'apexcharts-pie-area apexcharts-'.concat(i.config.chart.type, '-slice-').concat(d),
          }); if (v.attr({ index: 0, j: d }), i.config.chart.dropShadow.enabled) { const y = i.config.chart.dropShadow; a.dropShadow(v, y, d); } this.addListeners(v, this.donutDataLabels), p.setAttrs(v.node, {
            'data:angle': x, 'data:startAngle': o, 'data:strokeWidth': this.strokeWidth, 'data:value': e[d],
          }); let w = { x: 0, y: 0 }; i.config.chart.type === 'pie' ? w = g.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, o + (h - o) / 2) : i.config.chart.type === 'donut' && (w = g.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, o + (h - o) / 2)), f.add(v); let k = 0; if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : ((k = (h - o) / this.fullAngle * i.config.chart.animations.speed) === 0 && (k = 1), this.animDur = k + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(v, {
            size: i.globals.radialSize, endAngle: h, startAngle: o, prevStartAngle: l, prevEndAngle: c, animateStartingPos: !0, i: d, animBeginArr: this.animBeginArr, shouldSetPrevPaths: !0, dur: i.config.chart.animations.dynamicAnimation.speed,
          }) : this.animatePaths(v, {
            size: i.globals.radialSize, endAngle: h, startAngle: o, i: d, totalItems: t.length - 1, animBeginArr: this.animBeginArr, dur: k,
          }), i.config.plotOptions.pie.expandOnClick && v.click(this.pieClicked.bind(this, d)), i.config.dataLabels.enabled) {
            const A = w.x; const S = w.y; let C = `${100 * (h - o) / 360}%`; if (x !== 0 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[d]) {
              const L = i.config.dataLabels.formatter; void 0 !== L && (C = L(i.globals.seriesPercent[d][0], { seriesIndex: d, w: i })); const P = i.globals.dataLabels.style.colors[d]; const T = s.drawText({
                x: A, y: S, text: C, textAnchor: 'middle', fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, fontWeight: i.config.dataLabels.style.fontWeight, foreColor: P,
              }); if (i.config.dataLabels.dropShadow.enabled) { const z = i.config.dataLabels.dropShadow; a.dropShadow(T, z); }T.node.classList.add('apexcharts-pie-label'), i.config.chart.animations.animate && !1 === i.globals.resized && (T.node.classList.add('apexcharts-pie-label-delay'), T.node.style.animationDelay = `${i.config.chart.animations.speed / 940}s`), this.sliceLabels.push(T);
            }
          }
        } return n;
      },
    }, { key: 'addListeners', value(t, e) { const i = new p(this.ctx); t.node.addEventListener('mouseenter', i.pathMouseEnter.bind(this, t)), t.node.addEventListener('mouseleave', i.pathMouseLeave.bind(this, t)), t.node.addEventListener('mouseleave', this.revertDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener('mousedown', i.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener('mouseenter', this.printDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener('mousedown', this.printDataLabelsInner.bind(this, t.node, e))); } }, { key: 'animatePaths', value(t, e) { const i = this.w; let a = e.endAngle - e.startAngle; let s = a; let r = e.startAngle; const n = e.startAngle; void 0 !== e.prevStartAngle && void 0 !== e.prevEndAngle && (r = e.prevEndAngle, s = e.prevEndAngle - e.prevStartAngle), e.i === i.config.series.length - 1 && (a + n > this.fullAngle ? e.endAngle -= (a + n) : a + n < this.fullAngle && (e.endAngle += (this.fullAngle - (a + n)))), a === this.fullAngle && (a = this.fullAngle - 0.01), this.animateArc(t, r, n, a, s, e); } }, {
      key: 'animateArc',
      value(t, e, i, a, s, r) {
        let n; const o = this; const l = this.w; const h = new f(this.ctx); const c = r.size; (isNaN(e) || isNaN(s)) && (e = i, s = a, r.dur = 0); let d = a; let g = i; const u = e - i; l.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (n = o.getPiePath({
          me: o, startAngle: r.prevStartAngle, angle: r.prevEndAngle - r.prevStartAngle, size: c,
        }), t.attr({ d: n })), r.dur !== 0 ? t.animate(r.dur, l.globals.easing, r.animBeginArr[r.i]).afterAll((function () { l.config.chart.type !== 'pie' && l.config.chart.type !== 'donut' || this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({ 'stroke-width': o.strokeWidth }), r.i === l.config.series.length - 1 && h.animationCompleted(t); })).during(((l) => {
          d = u + (a - u) * l, r.animateStartingPos && (d = s + (a - s) * l, g = e - s + (i - (e - s)) * l), n = o.getPiePath({
            me: o, startAngle: g, angle: d, size: c,
          }), t.node.setAttribute('data:pathOrig', n), t.attr({ d: n });
        })) : (n = o.getPiePath({
          me: o, startAngle: g, angle: a, size: c,
        }), r.isTrack || (l.globals.animationEnded = !0), t.node.setAttribute('data:pathOrig', n), t.attr({ d: n, 'stroke-width': o.strokeWidth }));
      },
    }, {
      key: 'pieClicked',
      value(t) {
        let e; const i = this.w; const a = this.w.globals.radialSize + (i.config.plotOptions.pie.expandOnClick ? 4 : 0); const s = i.globals.dom.Paper.select('.apexcharts-'.concat(i.config.chart.type.toLowerCase(), '-slice-').concat(t)).members[0]; if (s.attr('data:pieClicked') !== 'true') {
          const r = i.globals.dom.baseEl.querySelectorAll('.apexcharts-pie-area'); Array.prototype.forEach.call(r, ((t) => { t.setAttribute('data:pieClicked', 'false'); const e = t.getAttribute('data:pathOrig'); t.setAttribute('d', e); })), s.attr('data:pieClicked', 'true'); const n = parseInt(s.attr('data:startAngle'), 10); const o = parseInt(s.attr('data:angle'), 10); e = this.getPiePath({
            me: this, startAngle: n, angle: o, size: a,
          }), o !== 360 && s.plot(e);
        } else { s.attr({ 'data:pieClicked': 'false' }), this.revertDataLabelsInner(s.node, this.donutDataLabels); const l = s.attr('data:pathOrig'); s.attr({ d: l }); }
      },
    }, {
      key: 'getChangedPath',
      value(t, e) {
        let i = ''; return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
          me: this, startAngle: t, angle: e - t, size: this.size,
        })), i;
      },
    }, { key: 'getPiePath', value(t) { const e = t.me; const i = t.startAngle; const a = t.angle; const s = t.size; const r = this.w; const n = i; const o = Math.PI * (n - 90) / 180; let l = a + i; Math.ceil(l) >= 360 && (l = 359.99); const h = Math.PI * (l - 90) / 180; const c = e.centerX + s * Math.cos(o); const d = e.centerY + s * Math.sin(o); const u = e.centerX + s * Math.cos(h); const f = e.centerY + s * Math.sin(h); const p = g.polarToCartesian(e.centerX, e.centerY, e.donutSize, l); const x = g.polarToCartesian(e.centerX, e.centerY, e.donutSize, n); const b = a > 180 ? 1 : 0; const m = ['M', c, d, 'A', s, s, 0, b, 1, u, f]; return r.config.chart.type === 'donut' ? [].concat(m, ['L', p.x, p.y, 'A', e.donutSize, e.donutSize, 0, b, 0, x.x, x.y, 'L', c, d, 'z']).join(' ') : r.config.chart.type === 'pie' ? [].concat(m, ['L', e.centerX, e.centerY, 'L', c, d]).join(' ') : [].concat(m).join(' '); } }, {
      key: 'renderInnerDataLabels',
      value(t, e) {
        const i = this.w; const a = new p(this.ctx); const s = a.group({ class: 'apexcharts-datalabels-group', transform: 'translate('.concat(e.translateX ? e.translateX : 0, ', ').concat(e.translateY ? e.translateY : 0, ') scale(').concat(i.config.plotOptions.pie.customScale, ')') }); const r = t.total.show; s.node.style.opacity = e.opacity; let n; let o; const l = e.centerX; const h = e.centerY; n = void 0 === t.name.color ? i.globals.colors[0] : t.name.color; let c = t.name.fontSize; let d = t.name.fontFamily; let g = t.value.fontWeight; o = void 0 === t.value.color ? i.config.chart.foreColor : t.value.color; const u = t.value.formatter; let f = ''; let x = ''; if (r ? (n = t.total.color, c = t.total.fontSize, d = t.total.fontFamily, g = t.total.fontWeight, x = t.total.label, f = t.total.formatter(i)) : i.globals.series.length === 1 && (f = u(i.globals.series[0], i), x = i.globals.seriesNames[0]), x && (x = t.name.formatter(x, t.total.show, i)), t.name.show) {
          const b = a.drawText({
            x: l, y: h + parseFloat(t.name.offsetY), text: x, textAnchor: 'middle', foreColor: n, fontSize: c, fontWeight: g, fontFamily: d,
          }); b.node.classList.add('apexcharts-datalabel-label'), s.add(b);
        } if (t.value.show) {
          const m = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY; const v = a.drawText({
            x: l, y: h + m, text: f, textAnchor: 'middle', foreColor: o, fontWeight: t.value.fontWeight, fontSize: t.value.fontSize, fontFamily: t.value.fontFamily,
          }); v.node.classList.add('apexcharts-datalabel-value'), s.add(v);
        } return s;
      },
    }, { key: 'printInnerLabels', value(t, e, i, a) { let s; const r = this.w; a ? s = void 0 === t.name.color ? r.globals.colors[parseInt(a.parentNode.getAttribute('rel'), 10) - 1] : t.name.color : r.globals.series.length > 1 && t.total.show && (s = t.total.color); const n = r.globals.dom.baseEl.querySelector('.apexcharts-datalabel-label'); const o = r.globals.dom.baseEl.querySelector('.apexcharts-datalabel-value'); i = (0, t.value.formatter)(i, r), a || typeof t.total.formatter !== 'function' || (i = t.total.formatter(r)); const l = e === t.total.label; e = t.name.formatter(e, l, r), n !== null && (n.textContent = e), o !== null && (o.textContent = i), n !== null && (n.style.fill = s); } }, { key: 'printDataLabelsInner', value(t, e) { const i = this.w; const a = t.getAttribute('data:value'); const s = i.globals.seriesNames[parseInt(t.parentNode.getAttribute('rel'), 10) - 1]; i.globals.series.length > 1 && this.printInnerLabels(e, s, a, t); const r = i.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group'); r !== null && (r.style.opacity = 1); } }, { key: 'revertDataLabelsInner', value(t, e, i) { const a = this; const s = this.w; const r = s.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group'); let n = !1; const o = s.globals.dom.baseEl.querySelectorAll('.apexcharts-pie-area'); const l = function (t) { const i = t.makeSliceOut; const s = t.printLabel; Array.prototype.forEach.call(o, ((t) => { t.getAttribute('data:pieClicked') === 'true' && (i && (n = !0), s && a.printDataLabelsInner(t, e)); })); }; if (l({ makeSliceOut: !0, printLabel: !1 }), e.total.show && s.globals.series.length > 1)n && !e.total.showAlways ? l({ makeSliceOut: !1, printLabel: !0 }) : this.printInnerLabels(e, e.total.label, e.total.formatter(s)); else if (l({ makeSliceOut: !1, printLabel: !0 }), !n) if (s.globals.selectedDataPoints.length && s.globals.series.length > 1) if (s.globals.selectedDataPoints[0].length > 0) { const h = s.globals.selectedDataPoints[0]; const c = s.globals.dom.baseEl.querySelector('.apexcharts-'.concat(s.config.chart.type.toLowerCase(), '-slice-').concat(h)); this.printDataLabelsInner(c, e); } else r && s.globals.selectedDataPoints.length && s.globals.selectedDataPoints[0].length === 0 && (r.style.opacity = 0); else r && s.globals.series.length > 1 && (r.style.opacity = 0); } }]), t;
  }()); const st = (function () { function t(i) { e(this, t), this.w = i.w, this.lgCtx = i; } return a(t, [{ key: 'getLegendStyles', value() { const t = document.createElement('style'); t.setAttribute('type', 'text/css'); const e = document.createTextNode('\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-left, .apexcharts-legend.position-top.apexcharts-align-left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-center, .apexcharts-legend.position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-right, .apexcharts-legend.position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }'); return t.appendChild(e), t; } }, { key: 'getLegendBBox', value() { const t = this.w.globals.dom.baseEl.querySelector('.apexcharts-legend').getBoundingClientRect(); const e = t.width; return { clwh: t.height, clww: e }; } }, { key: 'appendToForeignObject', value() { const t = this.w.globals; t.dom.elLegendForeign = document.createElementNS(t.SVGNS, 'foreignObject'); const e = t.dom.elLegendForeign; e.setAttribute('x', 0), e.setAttribute('y', 0), e.setAttribute('width', t.svgWidth), e.setAttribute('height', t.svgHeight), t.dom.elLegendWrap.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml'), e.appendChild(t.dom.elLegendWrap), e.appendChild(this.getLegendStyles()), t.dom.Paper.node.insertBefore(e, t.dom.elGraphical.node); } }, { key: 'toggleDataSeries', value(t, e) { const i = this; const a = this.w; if (a.globals.axisCharts || a.config.chart.type === 'radialBar') { a.globals.resized = !0; let s = null; let r = null; if (a.globals.risingSeries = [], a.globals.axisCharts ? (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), r = parseInt(s.getAttribute('data:realIndex'), 10)) : (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), r = parseInt(s.getAttribute('rel'), 10) - 1), e)[{ cs: a.globals.collapsedSeries, csi: a.globals.collapsedSeriesIndices }, { cs: a.globals.ancillaryCollapsedSeries, csi: a.globals.ancillaryCollapsedSeriesIndices }].forEach(((t) => { i.riseCollapsedSeries(t.cs, t.csi, r); })); else this.hideSeries({ seriesEl: s, realIndex: r }); } else { const n = a.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")); const o = a.config.chart.type; if (o === 'pie' || o === 'donut') { const l = a.config.plotOptions.pie.donut.labels; const h = new p(this.lgCtx.ctx); const c = new at(this.lgCtx.ctx); h.pathMouseDown(n.members[0], null), c.printDataLabelsInner(n.members[0].node, l); }n.fire('click'); } } }, { key: 'hideSeries', value(t) { const e = t.seriesEl; const i = t.realIndex; const a = this.w; if (a.globals.axisCharts) { let s = !1; if (a.config.yaxis[i] && a.config.yaxis[i].show && a.config.yaxis[i].showAlways && (s = !0, a.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (a.globals.ancillaryCollapsedSeries.push({ index: i, data: a.config.series[i].data.slice(), type: e.parentNode.className.baseVal.split('-')[1] }), a.globals.ancillaryCollapsedSeriesIndices.push(i))), !s) { a.globals.collapsedSeries.push({ index: i, data: a.config.series[i].data.slice(), type: e.parentNode.className.baseVal.split('-')[1] }), a.globals.collapsedSeriesIndices.push(i); const r = a.globals.risingSeries.indexOf(i); a.globals.risingSeries.splice(r, 1); }a.config.series[i].data = []; } else a.globals.collapsedSeries.push({ index: i, data: a.config.series[i] }), a.globals.collapsedSeriesIndices.push(i), a.config.series[i] = 0; for (let n = e.childNodes, o = 0; o < n.length; o++)n[o].classList.contains('apexcharts-series-markers-wrap') && (n[o].classList.contains('apexcharts-hide') ? n[o].classList.remove('apexcharts-hide') : n[o].classList.add('apexcharts-hide')); a.globals.allSeriesCollapsed = a.globals.collapsedSeries.length === a.config.series.length, this.lgCtx.ctx.updateHelpers._updateSeries(a.config.series, a.config.chart.animations.dynamicAnimation.enabled); } }, { key: 'riseCollapsedSeries', value(t, e, i) { const a = this.w; if (t.length > 0) for (let s = 0; s < t.length; s++)t[s].index === i && (a.globals.axisCharts ? (a.config.series[i].data = t[s].data.slice(), t.splice(s, 1), e.splice(s, 1), a.globals.risingSeries.push(i)) : (a.config.series[i] = t[s].data, t.splice(s, 1), e.splice(s, 1), a.globals.risingSeries.push(i)), this.lgCtx.ctx.updateHelpers._updateSeries(a.config.series, a.config.chart.animations.dynamicAnimation.enabled)); } }]), t; }()); const rt = (function () {
    function t(i, a) { e(this, t), this.ctx = i, this.w = i.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new st(this); } return a(t, [{ key: 'init', value() { const t = this.w; const e = t.globals; const i = t.config; if ((i.legend.showForSingleSeries && e.series.length === 1 || this.isBarsDistributed || e.series.length > 1 || !e.axisCharts) && i.legend.show) { for (;e.dom.elLegendWrap.firstChild;)e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild); this.drawLegends(), g.isIE11() ? document.getElementsByTagName('head')[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), i.legend.position === 'bottom' || i.legend.position === 'top' ? this.legendAlignHorizontal() : i.legend.position !== 'right' && i.legend.position !== 'left' || this.legendAlignVertical(); } } }, {
      key: 'drawLegends',
      value() {
        const t = this.w; const e = t.config.legend.fontFamily; let i = t.globals.seriesNames; let a = t.globals.colors.slice(); if (t.config.chart.type === 'heatmap') { const s = t.config.plotOptions.heatmap.colorScale.ranges; i = s.map(((t) => (t.name ? t.name : `${t.from} - ${t.to}`))), a = s.map(((t) => t.color)); } else this.isBarsDistributed && (i = t.globals.labels.slice()); for (let r = t.globals.legendFormatter, n = t.config.legend.inverseOrder, o = n ? i.length - 1 : 0; n ? o >= 0 : o <= i.length - 1; n ? o-- : o++) {
          const l = r(i[o], { seriesIndex: o, w: t }); let h = !1; let c = !1; if (t.globals.collapsedSeries.length > 0) for (let d = 0; d < t.globals.collapsedSeries.length; d++)t.globals.collapsedSeries[d].index === o && (h = !0); if (t.globals.ancillaryCollapsedSeriesIndices.length > 0) for (let g = 0; g < t.globals.ancillaryCollapsedSeriesIndices.length; g++)t.globals.ancillaryCollapsedSeriesIndices[g] === o && (c = !0); const u = document.createElement('span'); u.classList.add('apexcharts-legend-marker'); const f = t.config.legend.markers.offsetX; const x = t.config.legend.markers.offsetY; const b = t.config.legend.markers.height; const m = t.config.legend.markers.width; const v = t.config.legend.markers.strokeWidth; const y = t.config.legend.markers.strokeColor; const w = t.config.legend.markers.radius; const k = u.style; k.background = a[o], k.color = a[o], t.config.legend.markers.fillColors && t.config.legend.markers.fillColors[o] && (k.background = t.config.legend.markers.fillColors[o]), k.height = Array.isArray(b) ? `${parseFloat(b[o])}px` : `${parseFloat(b)}px`, k.width = Array.isArray(m) ? `${parseFloat(m[o])}px` : `${parseFloat(m)}px`, k.left = Array.isArray(f) ? f[o] : f, k.top = Array.isArray(x) ? x[o] : x, k.borderWidth = Array.isArray(v) ? v[o] : v, k.borderColor = Array.isArray(y) ? y[o] : y, k.borderRadius = Array.isArray(w) ? `${parseFloat(w[o])}px` : `${parseFloat(w)}px`, t.config.legend.markers.customHTML && (Array.isArray(t.config.legend.markers.customHTML) ? u.innerHTML = t.config.legend.markers.customHTML[o]() : u.innerHTML = t.config.legend.markers.customHTML()), p.setAttrs(u, { rel: o + 1, 'data:collapsed': h || c }), (h || c) && u.classList.add('apexcharts-inactive-legend'); const A = document.createElement('div'); const S = document.createElement('span'); S.classList.add('apexcharts-legend-text'), S.innerHTML = Array.isArray(l) ? l.join(' ') : l; let C = t.config.legend.labels.useSeriesColors ? t.globals.colors[o] : t.config.legend.labels.colors; C || (C = t.config.chart.foreColor), S.style.color = C, S.style.fontSize = `${parseFloat(t.config.legend.fontSize)}px`, S.style.fontWeight = t.config.legend.fontWeight, S.style.fontFamily = e || t.config.chart.fontFamily, p.setAttrs(S, {
            rel: o + 1, i: o, 'data:default-text': encodeURIComponent(l), 'data:collapsed': h || c,
          }), A.appendChild(u), A.appendChild(S); const L = new I(this.ctx); if (!t.config.legend.showForZeroSeries)L.getSeriesTotalByIndex(o) === 0 && L.seriesHaveSameValues(o) && !L.isSeriesNull(o) && t.globals.collapsedSeriesIndices.indexOf(o) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(o) === -1 && A.classList.add('apexcharts-hidden-zero-series'); t.config.legend.showForNullSeries || L.isSeriesNull(o) && t.globals.collapsedSeriesIndices.indexOf(o) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(o) === -1 && A.classList.add('apexcharts-hidden-null-series'), t.globals.dom.elLegendWrap.appendChild(A), t.globals.dom.elLegendWrap.classList.add('apexcharts-align-'.concat(t.config.legend.horizontalAlign)), t.globals.dom.elLegendWrap.classList.add(`position-${t.config.legend.position}`), A.classList.add('apexcharts-legend-series'), A.style.margin = ''.concat(t.config.legend.itemMargin.vertical, 'px ').concat(t.config.legend.itemMargin.horizontal, 'px'), t.globals.dom.elLegendWrap.style.width = t.config.legend.width ? `${t.config.legend.width}px` : '', t.globals.dom.elLegendWrap.style.height = t.config.legend.height ? `${t.config.legend.height}px` : '', p.setAttrs(A, { rel: o + 1, 'data:collapsed': h || c }), (h || c) && A.classList.add('apexcharts-inactive-legend'), t.config.legend.onItemClick.toggleDataSeries || A.classList.add('apexcharts-no-click');
        }t.config.chart.type !== 'heatmap' && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && t.globals.dom.elWrap.addEventListener('click', this.onLegendClick, !0), t.config.legend.onItemHover.highlightDataSeries && (t.globals.dom.elWrap.addEventListener('mousemove', this.onLegendHovered, !0), t.globals.dom.elWrap.addEventListener('mouseout', this.onLegendHovered, !0));
      },
    }, { key: 'setLegendWrapXY', value(t, e) { const i = this.w; const a = i.globals.dom.baseEl.querySelector('.apexcharts-legend'); const s = a.getBoundingClientRect(); let r = 0; let n = 0; if (i.config.legend.position === 'bottom')n += i.globals.svgHeight - s.height / 2; else if (i.config.legend.position === 'top') { const o = new it(this.ctx); const l = o.dimHelpers.getTitleSubtitleCoords('title').height; const h = o.dimHelpers.getTitleSubtitleCoords('subtitle').height; n = n + (l > 0 ? l - 10 : 0) + (h > 0 ? h - 10 : 0); }a.style.position = 'absolute', r = r + t + i.config.legend.offsetX, n = n + e + i.config.legend.offsetY, a.style.left = `${r}px`, a.style.top = `${n}px`, i.config.legend.position === 'bottom' ? (a.style.top = 'auto', a.style.bottom = `${5 - i.config.legend.offsetY}px`) : i.config.legend.position === 'right' && (a.style.left = 'auto', a.style.right = `${25 + i.config.legend.offsetX}px`); ['width', 'height'].forEach(((t) => { a.style[t] && (a.style[t] = `${parseInt(i.config.legend[t], 10)}px`); })); } }, { key: 'legendAlignHorizontal', value() { const t = this.w; t.globals.dom.baseEl.querySelector('.apexcharts-legend').style.right = 0; const e = this.legendHelpers.getLegendBBox(); const i = new it(this.ctx); const a = i.dimHelpers.getTitleSubtitleCoords('title'); const s = i.dimHelpers.getTitleSubtitleCoords('subtitle'); let r = 0; t.config.legend.position === 'bottom' ? r = -e.clwh / 1.8 : t.config.legend.position === 'top' && (r = a.height + s.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, r); } }, { key: 'legendAlignVertical', value() { const t = this.w; const e = this.legendHelpers.getLegendBBox(); let i = 0; t.config.legend.position === 'left' && (i = 20), t.config.legend.position === 'right' && (i = t.globals.svgWidth - e.clww - 10), this.setLegendWrapXY(i, 20); } }, { key: 'onLegendHovered', value(t) { const e = this.w; const i = t.target.classList.contains('apexcharts-legend-text') || t.target.classList.contains('apexcharts-legend-marker'); if (e.config.chart.type === 'heatmap' || this.isBarsDistributed) { if (i) { const a = parseInt(t.target.getAttribute('rel'), 10) - 1; this.ctx.events.fireEvent('legendHover', [this.ctx, a, this.w]), new F(this.ctx).highlightRangeInSeries(t, t.target); } } else !t.target.classList.contains('apexcharts-inactive-legend') && i && new F(this.ctx).toggleSeriesOnHover(t, t.target); } }, { key: 'onLegendClick', value(t) { if (t.target.classList.contains('apexcharts-legend-text') || t.target.classList.contains('apexcharts-legend-marker')) { const e = parseInt(t.target.getAttribute('rel'), 10) - 1; const i = t.target.getAttribute('data:collapsed') === 'true'; const a = this.w.config.chart.events.legendClick; typeof a === 'function' && a(this.ctx, e, this.w), this.ctx.events.fireEvent('legendClick', [this.ctx, e, this.w]); const s = this.w.config.legend.markers.onClick; typeof s === 'function' && t.target.classList.contains('apexcharts-legend-marker') && (s(this.ctx, e, this.w), this.ctx.events.fireEvent('legendMarkerClick', [this.ctx, e, this.w])), this.legendHelpers.toggleDataSeries(e, i); } } }]), t;
  }()); const nt = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.ev = this.w.config.chart.events, this.selectedClass = 'apexcharts-selected', this.localeValues = this.w.globals.locale.toolbar; } return a(t, [{
      key: 'createToolbar',
      value() {
        const t = this; const e = this.w; const i = function () { return document.createElement('div'); }; const a = i(); if (a.setAttribute('class', 'apexcharts-toolbar'), e.globals.dom.elWrap.appendChild(a), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = e.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (let s = 0; s < this.t.customIcons.length; s++) this.elCustomIcons.push(i()); const r = []; const n = function (i, a, s) {
          const n = i.toLowerCase(); t.t[n] && e.config.chart.zoom.enabled && r.push({
            el: a, icon: typeof t.t[n] === 'string' ? t.t[n] : s, title: t.localeValues[i], class: 'apexcharts-'.concat(n, '-icon'),
          });
        }; n('zoomIn', this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), n('zoomOut', this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'); const o = function (i) {
          t.t[i] && e.config.chart[i].enabled && r.push({
            el: i === 'zoom' ? t.elZoom : t.elSelection, icon: typeof t.t[i] === 'string' ? t.t[i] : i === 'zoom' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t.localeValues[i === 'zoom' ? 'selectionZoom' : 'selection'], class: e.globals.isTouchDevice ? 'apexcharts-element-hidden' : 'apexcharts-'.concat(i, '-icon'),
          });
        }; o('zoom'), o('selection'), this.t.pan && e.config.chart.zoom.enabled && r.push({
          el: this.elPan, icon: typeof this.t.pan === 'string' ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e.globals.isTouchDevice ? 'apexcharts-element-hidden' : 'apexcharts-pan-icon',
        }), n('reset', this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r.push({
          el: this.elMenuIcon, icon: typeof this.t.download === 'string' ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: 'apexcharts-menu-icon',
        }); for (let l = 0; l < this.elCustomIcons.length; l++) {
 r.push({
          el: this.elCustomIcons[l], icon: this.t.customIcons[l].icon, title: this.t.customIcons[l].title, index: this.t.customIcons[l].index, class: `apexcharts-toolbar-custom-icon ${this.t.customIcons[l].class}`, 
        }); 
} r.forEach(((t, e) => { t.index && g.moveIndexInArray(r, e, t.index); })); for (let h = 0; h < r.length; h++)p.setAttrs(r[h].el, { class: r[h].class, title: r[h].title }), r[h].el.innerHTML = r[h].icon, a.appendChild(r[h].el); this._createHamburgerMenu(a), e.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
      },
    }, { key: '_createHamburgerMenu', value(t) { this.elMenuItems = [], t.appendChild(this.elMenu), p.setAttrs(this.elMenu, { class: 'apexcharts-menu' }); const e = [{ name: 'exportSVG', title: this.localeValues.exportToSVG }, { name: 'exportPNG', title: this.localeValues.exportToPNG }, { name: 'exportCSV', title: this.localeValues.exportToCSV }]; this.w.globals.allSeriesHasEqualX || e.splice(2, 1); for (let i = 0; i < e.length; i++) this.elMenuItems.push(document.createElement('div')), this.elMenuItems[i].innerHTML = e[i].title, p.setAttrs(this.elMenuItems[i], { class: 'apexcharts-menu-item '.concat(e[i].name), title: e[i].title }), this.elMenu.appendChild(this.elMenuItems[i]); } }, { key: 'addToolbarEventListeners', value() { const t = this; this.elZoomReset.addEventListener('click', this.handleZoomReset.bind(this)), this.elSelection.addEventListener('click', this.toggleZoomSelection.bind(this, 'selection')), this.elZoom.addEventListener('click', this.toggleZoomSelection.bind(this, 'zoom')), this.elZoomIn.addEventListener('click', this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener('click', this.handleZoomOut.bind(this)), this.elPan.addEventListener('click', this.togglePanning.bind(this)), this.elMenuIcon.addEventListener('click', this.toggleMenu.bind(this)), this.elMenuItems.forEach(((e) => { e.classList.contains('exportSVG') ? e.addEventListener('click', t.handleDownload.bind(t, 'svg')) : e.classList.contains('exportPNG') ? e.addEventListener('click', t.handleDownload.bind(t, 'png')) : e.classList.contains('exportCSV') && e.addEventListener('click', t.handleDownload.bind(t, 'csv')); })); for (let e = 0; e < this.t.customIcons.length; e++) this.elCustomIcons[e].addEventListener('click', this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w)); } }, { key: 'toggleZoomSelection', value(t) { this.toggleOtherControls(); const e = t === 'selection' ? this.elSelection : this.elZoom; const i = t === 'selection' ? 'selectionEnabled' : 'zoomEnabled'; this.w.globals[i] = !this.w.globals[i], e.classList.contains(this.selectedClass) ? e.classList.remove(this.selectedClass) : e.classList.add(this.selectedClass); } }, { key: 'getToolbarIconsReference', value() { const t = this.w; this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector('.apexcharts-zoom-icon')), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector('.apexcharts-pan-icon')), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector('.apexcharts-selection-icon')); } }, { key: 'enableZoomPanFromToolbar', value(t) { this.toggleOtherControls(), t === 'pan' ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0; const e = t === 'pan' ? this.elPan : this.elZoom; const i = t === 'pan' ? this.elZoom : this.elPan; e && e.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass); } }, { key: 'togglePanning', value() { this.toggleOtherControls(), this.w.globals.panEnabled = !this.w.globals.panEnabled, this.elPan.classList.contains(this.selectedClass) ? this.elPan.classList.remove(this.selectedClass) : this.elPan.classList.add(this.selectedClass); } }, { key: 'toggleOtherControls', value() { const t = this; const e = this.w; e.globals.panEnabled = !1, e.globals.zoomEnabled = !1, e.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(((e) => { e && e.classList.remove(t.selectedClass); })); } }, { key: 'handleZoomIn', value() { const t = this.w; const e = (t.globals.minX + t.globals.maxX) / 2; const i = (t.globals.minX + e) / 2; const a = (t.globals.maxX + e) / 2; const s = this._getNewMinXMaxX(i, a); t.globals.disableZoomIn || this.zoomUpdateOptions(s.minX, s.maxX); } }, { key: 'handleZoomOut', value() { const t = this.w; if (!(t.config.xaxis.type === 'datetime' && new Date(t.globals.minX).getUTCFullYear() < 1e3)) { const e = (t.globals.minX + t.globals.maxX) / 2; const i = t.globals.minX - (e - t.globals.minX); const a = t.globals.maxX - (e - t.globals.maxX); const s = this._getNewMinXMaxX(i, a); t.globals.disableZoomOut || this.zoomUpdateOptions(s.minX, s.maxX); } } }, { key: '_getNewMinXMaxX', value(t, e) { const i = this.w.config.xaxis.convertedCatToNumeric; return { minX: i ? Math.floor(t) : t, maxX: i ? Math.floor(e) : e }; } }, { key: 'zoomUpdateOptions', value(t, e) { const i = this.w; if (!(i.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, e = i.globals.dataPoints), e - t < 2))) { let a = { min: t, max: e }; const s = this.getBeforeZoomRange(a); s && (a = s.xaxis); const r = { xaxis: a }; let n = g.clone(i.globals.initialConfig.yaxis); if (i.config.chart.zoom.autoScaleYaxis)n = new B(this.ctx).autoScaleY(this.ctx, n, { xaxis: a }); i.config.chart.group || (r.yaxis = n), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(r, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a, n); } } }, { key: 'zoomCallback', value(t, e) { typeof this.ev.zoomed === 'function' && this.ev.zoomed(this.ctx, { xaxis: t, yaxis: e }); } }, { key: 'getBeforeZoomRange', value(t, e) { let i = null; return typeof this.ev.beforeZoom === 'function' && (i = this.ev.beforeZoom(this, { xaxis: t, yaxis: e })), i; } }, { key: 'toggleMenu', value() { const t = this; window.setTimeout((() => { t.elMenu.classList.contains('apexcharts-menu-open') ? t.elMenu.classList.remove('apexcharts-menu-open') : t.elMenu.classList.add('apexcharts-menu-open'); }), 0); } }, { key: 'handleDownload', value(t) { const e = this.w; const i = new N(this.ctx); switch (t) { case 'svg': i.exportToSVG(this.ctx); break; case 'png': i.exportToPng(this.ctx); break; case 'csv': i.exportToCSV({ series: e.config.series }); } } }, { key: 'handleZoomReset', value(t) { const e = this; this.ctx.getSyncedCharts().forEach(((t) => { const i = t.w; i.globals.minX === i.globals.initialMinX && i.globals.maxX === i.globals.initialMaxX || (t.updateHelpers.revertDefaultAxisMinMax(), typeof i.config.chart.events.zoomed === 'function' && e.zoomCallback({ min: i.config.xaxis.min, max: i.config.xaxis.max }), i.globals.zoomed = !1, t.updateHelpers._updateSeries(i.globals.initialSeries, i.config.chart.animations.dynamicAnimation.enabled)); })); } }, { key: 'destroy', value() { this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null; } }]), t;
  }()); const ot = (function (t) {
    function i(t) { let a; return e(this, i), (a = c(this, l(i).call(this, t))).ctx = t, a.w = t.w, a.dragged = !1, a.graphics = new p(a.ctx), a.eventList = ['mousedown', 'mouseleave', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'], a.clientX = 0, a.clientY = 0, a.startX = 0, a.endX = 0, a.dragX = 0, a.startY = 0, a.endY = 0, a.dragY = 0, a.moveDirection = 'none', a; } return o(i, t), a(i, [{
      key: 'init',
      value(t) {
        const e = this; const i = t.xyRatios; const a = this.w; const s = this; this.xyRatios = i, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a.globals.dom.baseEl.querySelector('.apexcharts-grid'), this.zoomRect.node.classList.add('apexcharts-zoom-rect'), this.selectionRect.node.classList.add('apexcharts-selection-rect'), a.globals.dom.elGraphical.add(this.zoomRect), a.globals.dom.elGraphical.add(this.selectionRect), a.config.chart.selection.type === 'x' ? this.slDraggableRect = this.selectionRect.draggable({
          minX: 0, minY: 0, maxX: a.globals.gridWidth, maxY: a.globals.gridHeight,
        }).on('dragmove', this.selectionDragging.bind(this, 'dragging')) : a.config.chart.selection.type === 'y' ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a.globals.gridWidth }).on('dragmove', this.selectionDragging.bind(this, 'dragging')) : this.slDraggableRect = this.selectionRect.draggable().on('dragmove', this.selectionDragging.bind(this, 'dragging')), this.preselectedSelection(), this.hoverArea = a.globals.dom.baseEl.querySelector(a.globals.chartClass), this.hoverArea.classList.add('apexcharts-zoomable'), this.eventList.forEach(((t) => { e.hoverArea.addEventListener(t, s.svgMouseEvents.bind(s, i), { capture: !1, passive: !0 }); }));
      },
    }, { key: 'destroy', value() { this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null; } }, { key: 'svgMouseEvents', value(t, e) { const i = this.w; const a = this; const s = this.ctx.toolbar; const r = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type; if (e.shiftKey ? (this.shiftWasPressed = !0, s.enableZoomPanFromToolbar('pan')) : this.shiftWasPressed && (s.enableZoomPanFromToolbar('zoom'), this.shiftWasPressed = !1), !(e.target.classList.contains('apexcharts-selection-rect') || e.target.parentNode.classList.contains('apexcharts-toolbar'))) { if (a.clientX = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientX : e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX, a.clientY = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientY : e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY, e.type === 'mousedown' && e.which === 1) { const n = a.gridRect.getBoundingClientRect(); a.startX = a.clientX - n.left, a.startY = a.clientY - n.top, a.dragged = !1, a.w.globals.mousedown = !0; } if ((e.type === 'mousemove' && e.which === 1 || e.type === 'touchmove') && (a.dragged = !0, i.globals.panEnabled ? (i.globals.selection = null, a.w.globals.mousedown && a.panDragging({ context: a, zoomtype: r, xyRatios: t })) : (a.w.globals.mousedown && i.globals.zoomEnabled || a.w.globals.mousedown && i.globals.selectionEnabled) && (a.selection = a.selectionDrawing({ context: a, zoomtype: r }))), e.type === 'mouseup' || e.type === 'touchend' || e.type === 'mouseleave') { const o = a.gridRect.getBoundingClientRect(); a.w.globals.mousedown && (a.endX = a.clientX - o.left, a.endY = a.clientY - o.top, a.dragX = Math.abs(a.endX - a.startX), a.dragY = Math.abs(a.endY - a.startY), (i.globals.zoomEnabled || i.globals.selectionEnabled) && a.selectionDrawn({ context: a, zoomtype: r }), i.globals.panEnabled && i.config.xaxis.convertedCatToNumeric && a.delayedPanScrolled()), i.globals.zoomEnabled && a.hideSelectionRect(this.selectionRect), a.dragged = !1, a.w.globals.mousedown = !1; } this.makeSelectionRectDraggable(); } } }, {
      key: 'makeSelectionRectDraggable',
      value() {
        const t = this.w; if (this.selectionRect) {
          const e = this.selectionRect.node.getBoundingClientRect(); e.width > 0 && e.height > 0 && this.slDraggableRect.selectize().resize({
            constraint: {
              minX: 0, minY: 0, maxX: t.globals.gridWidth, maxY: t.globals.gridHeight,
            },
          }).on('resizing', this.selectionDragging.bind(this, 'resizing'));
        }
      },
    }, {
      key: 'preselectedSelection',
      value() {
        const t = this.w; const e = this.xyRatios; if (!t.globals.zoomEnabled) {
 if (void 0 !== t.globals.selection && t.globals.selection !== null) this.drawSelectionRect(t.globals.selection); else if (void 0 !== t.config.chart.selection.xaxis.min && void 0 !== t.config.chart.selection.xaxis.max) {
          const i = (t.config.chart.selection.xaxis.min - t.globals.minX) / e.xRatio; const a = {
            x: i, y: 0, width: t.globals.gridWidth - (t.globals.maxX - t.config.chart.selection.xaxis.max) / e.xRatio - i, height: t.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: !0,
          }; this.drawSelectionRect(a), this.makeSelectionRectDraggable(), typeof t.config.chart.events.selection === 'function' && t.config.chart.events.selection(this.ctx, { xaxis: { min: t.config.chart.selection.xaxis.min, max: t.config.chart.selection.xaxis.max }, yaxis: {} });
        } 
}
      },
    }, {
      key: 'drawSelectionRect',
      value(t) {
        const e = t.x; const i = t.y; let a = t.width; const s = t.height; const r = t.translateX; const n = t.translateY; const o = this.w; const l = this.zoomRect; const h = this.selectionRect; if (this.dragged || o.globals.selection !== null) {
          const c = { transform: `translate(${r}, ${n})` }; o.globals.zoomEnabled && this.dragged && (a < 0 && (a = 1), l.attr({
            x: e, y: i, width: a, height: s, fill: o.config.chart.zoom.zoomedArea.fill.color, 'fill-opacity': o.config.chart.zoom.zoomedArea.fill.opacity, stroke: o.config.chart.zoom.zoomedArea.stroke.color, 'stroke-width': o.config.chart.zoom.zoomedArea.stroke.width, 'stroke-opacity': o.config.chart.zoom.zoomedArea.stroke.opacity,
          }), p.setAttrs(l.node, c)), o.globals.selectionEnabled && (h.attr({
            x: e, y: i, width: a > 0 ? a : 0, height: s > 0 ? s : 0, fill: o.config.chart.selection.fill.color, 'fill-opacity': o.config.chart.selection.fill.opacity, stroke: o.config.chart.selection.stroke.color, 'stroke-width': o.config.chart.selection.stroke.width, 'stroke-dasharray': o.config.chart.selection.stroke.dashArray, 'stroke-opacity': o.config.chart.selection.stroke.opacity,
          }), p.setAttrs(h.node, c));
        }
      },
    }, {
      key: 'hideSelectionRect',
      value(t) {
        t && t.attr({
          x: 0, y: 0, width: 0, height: 0,
        });
      },
    }, {
      key: 'selectionDrawing',
      value(t) {
        const e = t.context; const i = t.zoomtype; const a = this.w; const s = e; const r = this.gridRect.getBoundingClientRect(); const n = s.startX - 1; const o = s.startY; let l = s.clientX - r.left - n; let h = s.clientY - r.top - o; let c = 0; let d = 0; let g = {}; return Math.abs(l + n) > a.globals.gridWidth ? l = a.globals.gridWidth - n : s.clientX - r.left < 0 && (l = n), n > s.clientX - r.left && (c = -(l = Math.abs(l))), o > s.clientY - r.top && (d = -(h = Math.abs(h))), g = i === 'x' ? {
          x: n, y: 0, width: l, height: a.globals.gridHeight, translateX: c, translateY: 0,
        } : i === 'y' ? {
          x: 0, y: o, width: a.globals.gridWidth, height: h, translateX: 0, translateY: d,
        } : {
          x: n, y: o, width: l, height: h, translateX: c, translateY: d,
        }, s.drawSelectionRect(g), s.selectionDragging('resizing'), g;
      },
    }, { key: 'selectionDragging', value(t, e) { const i = this; const a = this.w; const s = this.xyRatios; const r = this.selectionRect; let n = 0; t === 'resizing' && (n = 30), typeof a.config.chart.events.selection === 'function' && a.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout((() => { const t = i.gridRect.getBoundingClientRect(); const e = r.node.getBoundingClientRect(); const n = a.globals.xAxisScale.niceMin + (e.left - t.left) * s.xRatio; const o = a.globals.xAxisScale.niceMin + (e.right - t.left) * s.xRatio; const l = a.globals.yAxisScale[0].niceMin + (t.bottom - e.bottom) * s.yRatio[0]; const h = a.globals.yAxisScale[0].niceMax - (e.top - t.top) * s.yRatio[0]; a.config.chart.events.selection(i.ctx, { xaxis: { min: n, max: o }, yaxis: { min: l, max: h } }); }), n)); } }, { key: 'selectionDrawn', value(t) { const e = t.context; const i = t.zoomtype; const a = this.w; const s = e; const r = this.xyRatios; const n = this.ctx.toolbar; if (s.startX > s.endX) { const o = s.startX; s.startX = s.endX, s.endX = o; } if (s.startY > s.endY) { const l = s.startY; s.startY = s.endY, s.endY = l; } let h = a.globals.xAxisScale.niceMin + s.startX * r.xRatio; let c = a.globals.xAxisScale.niceMin + s.endX * r.xRatio; const d = []; const u = []; if (a.config.yaxis.forEach(((t, e) => { d.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * s.startY), u.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * s.endY); })), s.dragged && (s.dragX > 10 || s.dragY > 10) && h !== c) if (a.globals.zoomEnabled) { let f = g.clone(a.globals.initialConfig.yaxis); a.globals.zoomed || (a.globals.lastXAxis = g.clone(a.config.xaxis), a.globals.lastYAxis = g.clone(a.config.yaxis)), a.config.xaxis.convertedCatToNumeric && (h = Math.floor(h), c = Math.floor(c), h < 1 && (h = 1, c = a.globals.dataPoints), c - h < 2 && (c = h + 1)); let p = { min: h, max: c }; if (i !== 'xy' && i !== 'y' || f.forEach(((t, e) => { f[e].min = u[e], f[e].max = d[e]; })), a.config.chart.zoom.autoScaleYaxis) { const x = new B(s.ctx); f = x.autoScaleY(s.ctx, f, { xaxis: p }); } if (n) { const b = n.getBeforeZoomRange(p, f); b && (p = b.xaxis ? b.xaxis : p, f = b.yaxis ? b.yaxe : f); } const m = { xaxis: p }; a.config.chart.group || (m.yaxis = f), s.ctx.updateHelpers._updateOptions(m, !1, s.w.config.chart.animations.dynamicAnimation.enabled), typeof a.config.chart.events.zoomed === 'function' && n.zoomCallback(p, f), a.globals.zoomed = !0; } else if (a.globals.selectionEnabled) { let v; let y = null; v = { min: h, max: c }, i !== 'xy' && i !== 'y' || (y = g.clone(a.config.yaxis)).forEach(((t, e) => { y[e].min = u[e], y[e].max = d[e]; })), a.globals.selection = s.selection, typeof a.config.chart.events.selection === 'function' && a.config.chart.events.selection(s.ctx, { xaxis: v, yaxis: y }); } } }, { key: 'panDragging', value(t) { const e = t.context; const i = this.w; const a = e; if (void 0 !== i.globals.lastClientPosition.x) { const s = i.globals.lastClientPosition.x - a.clientX; const r = i.globals.lastClientPosition.y - a.clientY; Math.abs(s) > Math.abs(r) && s > 0 ? this.moveDirection = 'left' : Math.abs(s) > Math.abs(r) && s < 0 ? this.moveDirection = 'right' : Math.abs(r) > Math.abs(s) && r > 0 ? this.moveDirection = 'up' : Math.abs(r) > Math.abs(s) && r < 0 && (this.moveDirection = 'down'); }i.globals.lastClientPosition = { x: a.clientX, y: a.clientY }; const n = i.globals.minX; const o = i.globals.maxX; i.config.xaxis.convertedCatToNumeric || a.panScrolled(n, o); } }, { key: 'delayedPanScrolled', value() { const t = this.w; let e = t.globals.minX; let i = t.globals.maxX; const a = (t.globals.maxX - t.globals.minX) / 2; this.moveDirection === 'left' ? (e = t.globals.minX + a, i = t.globals.maxX + a) : this.moveDirection === 'right' && (e = t.globals.minX - a, i = t.globals.maxX - a), e = Math.floor(e), i = Math.floor(i), this.updateScrolledChart({ xaxis: { min: e, max: i } }, e, i); } }, { key: 'panScrolled', value(t, e) { const i = this.w; const a = this.xyRatios; let s = g.clone(i.globals.initialConfig.yaxis); this.moveDirection === 'left' ? (t = i.globals.minX + i.globals.gridWidth / 15 * a.xRatio, e = i.globals.maxX + i.globals.gridWidth / 15 * a.xRatio) : this.moveDirection === 'right' && (t = i.globals.minX - i.globals.gridWidth / 15 * a.xRatio, e = i.globals.maxX - i.globals.gridWidth / 15 * a.xRatio), (t < i.globals.initialMinX || e > i.globals.initialMaxX) && (t = i.globals.minX, e = i.globals.maxX); const r = { min: t, max: e }; i.config.chart.zoom.autoScaleYaxis && (s = new B(this.ctx).autoScaleY(this.ctx, s, { xaxis: r })); const n = { xaxis: { min: t, max: e } }; i.config.chart.group || (n.yaxis = s), this.updateScrolledChart(n, t, e); } }, { key: 'updateScrolledChart', value(t, e, i) { const a = this.w; this.ctx.updateHelpers._updateOptions(t, !1, !1), typeof a.config.chart.events.scrolled === 'function' && a.config.chart.events.scrolled(this.ctx, { xaxis: { min: e, max: i } }); } }]), i;
  }(nt)); const lt = (function () {
    function t(i) { e(this, t), this.w = i.w, this.ttCtx = i, this.ctx = i.ctx; } return a(t, [{
      key: 'getNearestValues',
      value(t) {
        const e = t.hoverArea; const i = t.elGrid; const a = t.clientX; const s = t.clientY; const r = this.w; const n = r.globals.gridWidth; let o = n / (r.globals.dataPoints - 1); const l = i.getBoundingClientRect(); const h = this.hasBars(); (r.globals.comboCharts || h) && (o = n / r.globals.dataPoints); const c = a - l.left; const d = s - l.top; c < 0 || d < 0 || c > r.globals.gridWidth || d > r.globals.gridHeight ? (e.classList.remove('hovering-zoom'), e.classList.remove('hovering-pan')) : r.globals.zoomEnabled ? (e.classList.remove('hovering-pan'), e.classList.add('hovering-zoom')) : r.globals.panEnabled && (e.classList.remove('hovering-zoom'), e.classList.add('hovering-pan')); let u = Math.round(c / o); h && (u = Math.ceil(c / o), u -= 1); for (var f, p = null, x = null, b = [], m = 0; m < r.globals.seriesXvalues.length; m++)b.push([r.globals.seriesXvalues[m][0] - 1e-6].concat(r.globals.seriesXvalues[m])); return b = b.map(((t) => t.filter(((t) => t)))), f = r.globals.seriesYvalues.map(((t) => t.filter(((t) => g.isNumber(t))))), r.globals.isXNumeric && (p = (x = this.closestInMultiArray(c, d, b, f)).index, u = x.j, p !== null && (b = r.globals.seriesXvalues[p], u = (x = this.closestInArray(c, b)).index)), r.globals.capturedSeriesIndex = p === null ? -1 : p, (!u || u < 1) && (u = 0), r.globals.capturedDataPointIndex = u, {
          capturedSeries: p, j: u, hoverX: c, hoverY: d,
        };
      },
    }, { key: 'closestInMultiArray', value(t, e, i, a) { const s = this.w; let r = 0; let n = null; let o = -1; s.globals.series.length > 1 ? r = this.getFirstActiveXArray(i) : n = 0; const l = a[r][0]; const h = i[r][0]; let c = Math.abs(t - h); let d = Math.abs(e - l); let g = d + c; return a.map(((s, r) => { s.map(((s, l) => { const h = Math.abs(e - a[r][l]); const u = Math.abs(t - i[r][l]); const f = u + h; f < g && (g = f, c = u, d = h, n = r, o = l); })); })), { index: n, j: o }; } }, { key: 'getFirstActiveXArray', value(t) { for (var e = 0, i = new I(this.ctx), a = t.map(((t, e) => (t.length > 0 ? e : -1))), s = 0; s < a.length; s++) { const r = i.getSeriesTotalByIndex(s); if (a[s] !== -1 && r !== 0 && !i.seriesHaveSameValues(s)) { e = a[s]; break; } } return e; } }, { key: 'closestInArray', value(t, e) { for (var i = e[0], a = null, s = Math.abs(t - i), r = 0; r < e.length; r++) { const n = Math.abs(t - e[r]); n < s && (s = n, a = r); } return { index: a }; } }, { key: 'isXoverlap', value(t) { const e = []; const i = this.w.globals.seriesX.filter(((t) => void 0 !== t[0])); if (i.length > 0) for (let a = 0; a < i.length - 1; a++) void 0 !== i[a][t] && void 0 !== i[a + 1][t] && i[a][t] !== i[a + 1][t] && e.push('unEqual'); return e.length === 0; } }, { key: 'isInitialSeriesSameLen', value() { for (var t = !0, e = this.w.globals.initialSeries, i = 0; i < e.length - 1; i++) if (e[i].data.length !== e[i + 1].data.length) { t = !1; break; } return t; } }, { key: 'getBarsHeight', value(t) { return d(t).reduce(((t, e) => t + e.getBBox().height), 0); } }, { key: 'getElMarkers', value() { return this.w.globals.dom.baseEl.querySelectorAll(' .apexcharts-series-markers'); } }, { key: 'getAllMarkers', value() { return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker'); } }, { key: 'hasMarkers', value() { return this.getElMarkers().length > 0; } }, { key: 'getElBars', value() { return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-rangebar-series'); } }, { key: 'hasBars', value() { return this.getElBars().length > 0; } }, { key: 'getHoverMarkerSize', value(t) { const e = this.w; let i = e.config.markers.hover.size; return void 0 === i && (i = e.globals.markers.size[t] + e.config.markers.hover.sizeOffset), i; } }, { key: 'toggleAllTooltipSeriesGroups', value(t) { const e = this.w; const i = this.ttCtx; i.allTooltipSeriesGroups.length === 0 && (i.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll('.apexcharts-tooltip-series-group')); for (let a = i.allTooltipSeriesGroups, s = 0; s < a.length; s++)t === 'enable' ? (a[s].classList.add('apexcharts-active'), a[s].style.display = e.config.tooltip.items.display) : (a[s].classList.remove('apexcharts-active'), a[s].style.display = 'none'); } }]), t;
  }()); const ht = (function () {
    function t(i) { e(this, t), this.w = i.w, this.ctx = i.ctx, this.ttCtx = i, this.tooltipUtil = new lt(i); } return a(t, [{
      key: 'drawSeriesTexts',
      value(t) {
        const e = t.shared; const i = void 0 === e || e; const a = t.ttItems; const s = t.i; const r = void 0 === s ? 0 : s; const n = t.j; const o = void 0 === n ? null : n; const l = t.y1; const h = t.y2; const c = this.w; void 0 !== c.config.tooltip.custom ? this.handleCustomTooltip({
          i: r, j: o, y1: l, y2: h, w: c,
        }) : this.toggleActiveInactiveSeries(i); const d = this.getValuesToPrint({ i: r, j: o }); this.printLabels({
          i: r, j: o, values: d, ttItems: a, shared: i,
        }); const g = this.ttCtx.getElTooltip(); this.ttCtx.tooltipRect.ttWidth = g.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = g.getBoundingClientRect().height;
      },
    }, {
      key: 'printLabels',
      value(t) {
        let e; const i = this; const a = t.i; const s = t.j; const r = t.values; const n = t.ttItems; const o = t.shared; const l = this.w; const h = r.xVal; const c = r.zVal; const d = r.xAxisTTVal; let g = ''; let u = l.globals.colors[a]; s !== null && l.config.plotOptions.bar.distributed && (u = l.globals.colors[s]); for (let f = function (t, r) {
            let f = i.getFormatters(a); g = i.getSeriesName({
              fn: f.yLbTitleFormatter, index: a, seriesIndex: a, j: s,
            }); const p = l.config.tooltip.inverseOrder ? r : t; if (l.globals.axisCharts) {
              const x = function (t) {
                return f.yLbFormatter(l.globals.series[t][s], {
                  series: l.globals.series, seriesIndex: t, dataPointIndex: s, w: l,
                });
              }; o ? (f = i.getFormatters(p), g = i.getSeriesName({
                fn: f.yLbTitleFormatter, index: p, seriesIndex: a, j: s,
              }), u = l.globals.colors[p], e = x(p), (i.tooltipUtil.hasBars() && l.config.chart.stacked && l.globals.series[p][s] === 0 || void 0 === l.globals.series[p][s]) && (e = void 0)) : e = x(a);
            }s === null && (e = f.yLbFormatter(l.globals.series[a], l)), i.DOMHandling({
              i: a,
              t: p,
              j: s,
              ttItems: n,
              values: {
                val: e, xVal: h, xAxisTTVal: d, zVal: c,
              },
              seriesName: g,
              shared: o,
              pColor: u,
            });
          }, p = 0, x = l.globals.series.length - 1; p < l.globals.series.length; p++, x--)f(p, x);
      },
    }, { key: 'getFormatters', value(t) { let e; const i = this.w; let a = i.globals.yLabelFormatters[t]; return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (a = i.globals.ttVal[t] && i.globals.ttVal[t].formatter, e = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter) : (a = i.globals.ttVal.formatter, typeof i.globals.ttVal.title.formatter === 'function' && (e = i.globals.ttVal.title.formatter)) : e = i.config.tooltip.y.title.formatter, typeof a !== 'function' && (a = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function (t) { return t; }), typeof e !== 'function' && (e = function (t) { return t; }), { yLbFormatter: a, yLbTitleFormatter: e }; } }, {
      key: 'getSeriesName',
      value(t) {
        const e = t.fn; const i = t.index; const a = t.seriesIndex; const s = t.j; const r = this.w; return e(String(r.globals.seriesNames[i]), {
          series: r.globals.series, seriesIndex: a, dataPointIndex: s, w: r,
        });
      },
    }, { key: 'DOMHandling', value(t) { const e = t.i; const i = t.t; const a = t.j; const s = t.ttItems; const r = t.values; const n = t.seriesName; const o = t.shared; let l = t.pColor; const h = this.w; const c = this.ttCtx; const d = r.val; const g = r.xVal; const u = r.xAxisTTVal; const f = r.zVal; let p = null; p = s[i].children, h.config.tooltip.fillSeriesColor && (s[i].style.backgroundColor = l, p[0].style.display = 'none'), c.showTooltipTitle && (c.tooltipTitle === null && (c.tooltipTitle = h.globals.dom.baseEl.querySelector('.apexcharts-tooltip-title')), c.tooltipTitle.innerHTML = g), c.blxaxisTooltip && (c.xaxisTooltipText.innerHTML = u !== '' ? u : g); const x = s[i].querySelector('.apexcharts-tooltip-text-label'); x && (x.innerHTML = n ? `${n}: ` : ''); const b = s[i].querySelector('.apexcharts-tooltip-text-value'); (b && (b.innerHTML = d), p[0] && p[0].classList.contains('apexcharts-tooltip-marker') && (h.config.tooltip.marker.fillColors && Array.isArray(h.config.tooltip.marker.fillColors) && (l = h.config.tooltip.marker.fillColors[e]), p[0].style.backgroundColor = l), h.config.tooltip.marker.show || (p[0].style.display = 'none'), f !== null) && (s[i].querySelector('.apexcharts-tooltip-text-z-label').innerHTML = h.config.tooltip.z.title, s[i].querySelector('.apexcharts-tooltip-text-z-value').innerHTML = void 0 !== f ? f : ''); if (o && p[0] && c.tooltipTitle) if (d == null || h.globals.collapsedSeriesIndices.indexOf(i) > -1 ? p[0].parentNode.style.display = 'none' : p[0].parentNode.style.display = h.config.tooltip.items.display, h.globals.stackedSeriesTotals[a] === 0) { for (var m = !0, v = 1; v < h.globals.seriesYvalues.length; v++)h.globals.seriesYvalues[v][a] !== h.globals.seriesYvalues[v - 1][a] && (m = !1); c.tooltipTitle.style.display = m ? 'none' : h.config.tooltip.items.display; } else c.tooltipTitle.style.display = h.config.tooltip.items.display; } }, { key: 'toggleActiveInactiveSeries', value(t) { const e = this.w; if (t) this.tooltipUtil.toggleAllTooltipSeriesGroups('enable'); else { this.tooltipUtil.toggleAllTooltipSeriesGroups('disable'); const i = e.globals.dom.baseEl.querySelector('.apexcharts-tooltip-series-group'); i && (i.classList.add('apexcharts-active'), i.style.display = e.config.tooltip.items.display); } } }, {
      key: 'getValuesToPrint',
      value(t) {
        const e = t.i; const i = t.j; const a = this.w; const s = this.ctx.series.filteredSeriesX(); let r = ''; let n = ''; let o = null; let l = null; const h = {
          series: a.globals.series, seriesIndex: e, dataPointIndex: i, w: a,
        }; const c = a.globals.ttZFormatter; i === null ? l = a.globals.series[e] : a.globals.isXNumeric ? (r = s[e][i], s[e].length === 0 && (r = s[this.tooltipUtil.getFirstActiveXArray(s)][i])) : r = void 0 !== a.globals.labels[i] ? a.globals.labels[i] : ''; const d = r; a.globals.isXNumeric && a.config.xaxis.type === 'datetime' ? r = new R(this.ctx).xLabelFormat(a.globals.ttKeyFormatter, d, d) : a.globals.isBarHorizontal || (r = a.globals.xLabelFormatter(d, h)); return void 0 !== a.config.tooltip.x.formatter && (r = a.globals.ttKeyFormatter(d, h)), a.globals.seriesZ.length > 0 && a.globals.seriesZ[0].length > 0 && (o = c(a.globals.seriesZ[e][i], a)), n = typeof a.config.xaxis.tooltip.formatter === 'function' ? a.globals.xaxisTooltipFormatter(d, h) : r, {
          val: Array.isArray(l) ? l.join(' ') : l, xVal: Array.isArray(r) ? r.join(' ') : r, xAxisTTVal: Array.isArray(n) ? n.join(' ') : n, zVal: o,
        };
      },
    }, {
      key: 'handleCustomTooltip',
      value(t) {
        const e = t.i; const i = t.j; const a = t.y1; const s = t.y2; const r = t.w; const n = this.ttCtx.getElTooltip(); let o = r.config.tooltip.custom; Array.isArray(o) && o[e] && (o = o[e]), n.innerHTML = o({
          ctx: this.ctx, series: r.globals.series, seriesIndex: e, dataPointIndex: i, y1: a, y2: s, w: r,
        });
      },
    }]), t;
  }()); const ct = (function () {
    function t(i) { e(this, t), this.ttCtx = i, this.ctx = i.ctx, this.w = i.w; } return a(t, [{ key: 'moveXCrosshairs', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const i = this.ttCtx; const a = this.w; const s = i.getElXCrosshairs(); let r = t - i.xcrosshairsWidth / 2; const n = a.globals.labels.slice().length; if (e !== null && (r = a.globals.gridWidth / n * e), s !== null && (s.setAttribute('x', r), s.setAttribute('x1', r), s.setAttribute('x2', r), s.setAttribute('y2', a.globals.gridHeight), s.classList.add('apexcharts-active')), r < 0 && (r = 0), r > a.globals.gridWidth && (r = a.globals.gridWidth), i.blxaxisTooltip) { let o = r; a.config.xaxis.crosshairs.width !== 'tickWidth' && a.config.xaxis.crosshairs.width !== 'barWidth' || (o = r + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(o); } } }, { key: 'moveYCrosshairs', value(t) { const e = this.ttCtx; e.ycrosshairs !== null && (p.setAttrs(e.ycrosshairs, { y1: t, y2: t }), p.setAttrs(e.ycrosshairsHidden, { y1: t, y2: t })); } }, { key: 'moveXAxisTooltip', value(t) { const e = this.w; const i = this.ttCtx; if (i.xaxisTooltip !== null) { i.xaxisTooltip.classList.add('apexcharts-active'); const a = i.xaxisOffY + e.config.xaxis.tooltip.offsetY + e.globals.translateY + 1 + e.config.xaxis.offsetY; if (t -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t)) { t += e.globals.translateX; let s; s = new p(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = `${s.width}px`, i.xaxisTooltip.style.left = `${t}px`, i.xaxisTooltip.style.top = `${a}px`; } } } }, { key: 'moveYAxisTooltip', value(t) { const e = this.w; const i = this.ttCtx; i.yaxisTTEls === null && (i.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip')); const a = parseInt(i.ycrosshairsHidden.getAttribute('y1'), 10); let s = e.globals.translateY + a; const r = i.yaxisTTEls[t].getBoundingClientRect().height; let n = e.globals.translateYAxisX[t] - 2; e.config.yaxis[t].opposite && (n -= 26), s -= r / 2, e.globals.ignoreYAxisIndexes.indexOf(t) === -1 ? (i.yaxisTTEls[t].classList.add('apexcharts-active'), i.yaxisTTEls[t].style.top = `${s}px`, i.yaxisTTEls[t].style.left = `${n + e.config.yaxis[t].tooltip.offsetX}px`) : i.yaxisTTEls[t].classList.remove('apexcharts-active'); } }, { key: 'moveTooltip', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const a = this.w; const s = this.ttCtx; const r = s.getElTooltip(); const n = s.tooltipRect; const o = i !== null ? parseFloat(i) : 1; let l = parseFloat(t) + o + 5; let h = parseFloat(e) + o / 2; if (l > a.globals.gridWidth / 2 && (l = l - n.ttWidth - o - 15), l > a.globals.gridWidth - n.ttWidth - 10 && (l = a.globals.gridWidth - n.ttWidth), l < -20 && (l = -20), a.config.tooltip.followCursor) { const c = s.getElGrid(); const d = c.getBoundingClientRect(); h = s.e.clientY + a.globals.translateY - d.top - n.ttHeight / 2; } const g = this.positionChecks(n, l, h); l = g.x, h = g.y, isNaN(l) || (l += a.globals.translateX, r.style.left = `${l}px`, r.style.top = `${h}px`); } }, { key: 'positionChecks', value(t, e, i) { const a = this.w; return t.ttHeight + i > a.globals.gridHeight && (i = a.globals.gridHeight - t.ttHeight + a.globals.translateY), i < 0 && (i = 0), { x: e, y: i }; } }, { key: 'moveMarkers', value(t, e) { const i = this.w; const a = this.ttCtx; if (i.globals.markers.size[t] > 0) for (let s = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), r = 0; r < s.length; r++)parseInt(s[r].getAttribute('rel'), 10) === e && (a.marker.resetPointsSize(), a.marker.enlargeCurrentPoint(e, s[r])); else a.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t); } }, { key: 'moveDynamicPointOnHover', value(t, e) { let i; let a; const s = this.w; const r = this.ttCtx; const n = s.globals.pointsArray; const o = r.tooltipUtil.getHoverMarkerSize(e); const l = s.config.series[e].type; if (!l || l !== 'column' && l !== 'candlestick') { i = n[e][t][0], a = n[e][t][1] ? n[e][t][1] : 0; const h = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle")); h && (h.setAttribute('r', o), h.setAttribute('cx', i), h.setAttribute('cy', a)), this.moveXCrosshairs(i), r.fixedTooltip || this.moveTooltip(i, a, o); } } }, { key: 'moveDynamicPointsOnHover', value(t) { let e; const i = this.ttCtx; const a = i.w; let s = 0; let r = 0; const n = a.globals.pointsArray; e = new F(this.ctx).getActiveConfigSeriesIndex(!0); const o = i.tooltipUtil.getHoverMarkerSize(e); n[e] && (s = n[e][t][0], r = n[e][t][1]); let l = null; const h = i.tooltipUtil.getAllMarkers(); if ((l = h !== null ? h : a.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers circle')) !== null) for (let c = 0; c < a.globals.series.length; c++) { const g = n[c]; if (a.globals.comboCharts && void 0 === g && (l = d(l)).splice(c, 0, null), g && g.length) { const u = n[c][t][1]; l[c].setAttribute('cx', s); const f = parseInt(l[c].parentNode.parentNode.parentNode.getAttribute('data:realIndex'), 10); u === null || isNaN(u) ? l[f] && l[f].setAttribute('r', 0) : (l[f] && l[f].setAttribute('r', o), l[f] && l[f].setAttribute('cy', u)); } } if (this.moveXCrosshairs(s), !i.fixedTooltip) { const p = r || a.globals.gridHeight; this.moveTooltip(s, p, o); } } }, {
      key: 'moveStickyTooltipOverBars',
      value(t) {
        let e; const i = this.w; const a = this.ttCtx; const s = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length; const r = s >= 2 && s % 2 == 0 ? Math.floor(s / 2) : Math.floor(s / 2) + 1; const n = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='")
          .concat(r, "'] path[j='")
          .concat(t, "']")); let o = n ? parseFloat(n.getAttribute('cx')) : 0; const l = n ? parseFloat(n.getAttribute('barWidth')) : 0; i.globals.isXNumeric ? o -= s % 2 != 0 ? l / 2 : 0 : (o = a.xAxisTicksPositions[t - 1] + a.dataPointsDividedWidth / 2, isNaN(o) && (o = a.xAxisTicksPositions[t] - a.dataPointsDividedWidth / 2)); const h = a.getElGrid().getBoundingClientRect(); if (e = a.e.clientY - h.top - a.tooltipRect.ttHeight / 2, this.moveXCrosshairs(o), !a.fixedTooltip) { const c = e || i.globals.gridHeight; this.moveTooltip(o, c); }
      },
    }]), t;
  }()); const dt = (function () { function t(i) { e(this, t), this.w = i.w, this.ttCtx = i, this.ctx = i.ctx, this.tooltipPosition = new ct(i); } return a(t, [{ key: 'drawDynamicPoints', value() { for (let t = this.w, e = new p(this.ctx), i = new X(this.ctx), a = t.globals.dom.baseEl.querySelectorAll('.apexcharts-series'), s = 0; s < a.length; s++) { const r = parseInt(a[s].getAttribute('data:realIndex'), 10); const n = t.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(r, "'] .apexcharts-series-markers-wrap")); if (n !== null) { let o = void 0; let l = 'apexcharts-marker w'.concat((Math.random() + 1).toString(36).substring(4)); t.config.chart.type !== 'line' && t.config.chart.type !== 'area' || t.globals.comboCharts || t.config.tooltip.intersect || (l += ' no-pointer-events'); const h = i.getMarkerConfig(l, r); (o = e.drawMarker(0, 0, h)).node.setAttribute('default-marker-size', 0); const c = document.createElementNS(t.globals.SVGNS, 'g'); c.classList.add('apexcharts-series-markers'), c.appendChild(o.node), n.appendChild(c); } } } }, { key: 'enlargeCurrentPoint', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; const s = this.w; s.config.chart.type !== 'bubble' && this.newPointSize(t, e); let r = e.getAttribute('cx'); let n = e.getAttribute('cy'); if (i !== null && a !== null && (r = i, n = a), this.tooltipPosition.moveXCrosshairs(r), !this.fixedTooltip) { if (s.config.chart.type === 'radar') { const o = this.ttCtx.getElGrid(); const l = o.getBoundingClientRect(); r = this.ttCtx.e.clientX - l.left; } this.tooltipPosition.moveTooltip(r, n, s.config.markers.hover.size); } } }, { key: 'enlargePoints', value(t) { for (let e = this.w, i = this.ttCtx, a = t, s = e.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker'), r = e.config.markers.hover.size, n = 0; n < s.length; n++) { const o = s[n].getAttribute('rel'); const l = s[n].getAttribute('index'); if (void 0 === r && (r = e.globals.markers.size[l] + e.config.markers.hover.sizeOffset), a === parseInt(o, 10)) { this.newPointSize(a, s[n]); const h = s[n].getAttribute('cx'); const c = s[n].getAttribute('cy'); this.tooltipPosition.moveXCrosshairs(h), i.fixedTooltip || this.tooltipPosition.moveTooltip(h, c, r); } else this.oldPointSize(s[n]); } } }, { key: 'newPointSize', value(t, e) { const i = this.w; let a = i.config.markers.hover.size; const s = t === 0 ? e.parentNode.firstChild : e.parentNode.lastChild; if (s.getAttribute('default-marker-size') !== '0') { const r = parseInt(s.getAttribute('index'), 10); void 0 === a && (a = i.globals.markers.size[r] + i.config.markers.hover.sizeOffset), s.setAttribute('r', a); } } }, { key: 'oldPointSize', value(t) { const e = parseFloat(t.getAttribute('default-marker-size')); t.setAttribute('r', e); } }, { key: 'resetPointsSize', value() { for (let t = this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker'), e = 0; e < t.length; e++) { const i = parseFloat(t[e].getAttribute('default-marker-size')); g.isNumber(i) ? t[e].setAttribute('r', i) : t[e].setAttribute('r', 0); } } }]), t; }()); const gt = (function () {
    function t(i) { e(this, t), this.w = i.w, this.ttCtx = i; } return a(t, [{ key: 'getAttr', value(t, e) { return parseFloat(t.target.getAttribute(e)); } }, {
      key: 'handleHeatTooltip',
      value(t) {
        const { e } = t; const i = t.opt; let a = t.x; let s = t.y; const r = this.ttCtx; const
          n = this.w; if (e.target.classList.contains('apexcharts-heatmap-rect')) {
          const o = this.getAttr(e, 'i'); const l = this.getAttr(e, 'j'); const h = this.getAttr(e, 'cx'); const c = this.getAttr(e, 'cy'); const d = this.getAttr(e, 'width'); const g = this.getAttr(e, 'height'); if (r.tooltipLabels.drawSeriesTexts({
            ttItems: i.ttItems, i: o, j: l, shared: !1,
          }), n.globals.capturedSeriesIndex = o, n.globals.capturedDataPointIndex = l, a = h + r.tooltipRect.ttWidth / 2 + d, s = c + r.tooltipRect.ttHeight / 2 - g / 2, r.tooltipPosition.moveXCrosshairs(h + d / 2), a > n.globals.gridWidth / 2 && (a = h - r.tooltipRect.ttWidth / 2 + d), r.w.config.tooltip.followCursor) { const u = r.getElGrid().getBoundingClientRect(); s = r.e.clientY - u.top + n.globals.translateY / 2 - 10; }
        } return { x: a, y: s };
      },
    }, {
      key: 'handleMarkerTooltip',
      value(t) {
        let e; let i; const a = t.e; const s = t.opt; let r = t.x; let n = t.y; const o = this.w; const l = this.ttCtx; if (a.target.classList.contains('apexcharts-marker')) {
          const h = parseInt(s.paths.getAttribute('cx'), 10); const c = parseInt(s.paths.getAttribute('cy'), 10); const d = parseFloat(s.paths.getAttribute('val')); if (i = parseInt(s.paths.getAttribute('rel'), 10), e = parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute('rel'), 10) - 1, l.intersect) { const u = g.findAncestor(s.paths, 'apexcharts-series'); u && (e = parseInt(u.getAttribute('data:realIndex'), 10)); } if (l.tooltipLabels.drawSeriesTexts({
            ttItems: s.ttItems, i: e, j: i, shared: !l.showOnIntersect && o.config.tooltip.shared,
          }), a.type === 'mouseup' && l.markerClick(a, e, i), o.globals.capturedSeriesIndex = e, o.globals.capturedDataPointIndex = i, r = h, n = c + o.globals.translateY - 1.4 * l.tooltipRect.ttHeight, l.w.config.tooltip.followCursor) { const f = l.getElGrid().getBoundingClientRect(); n = l.e.clientY + o.globals.translateY - f.top; }d < 0 && (n = c), l.marker.enlargeCurrentPoint(i, s.paths, r, n);
        } return { x: r, y: n };
      },
    }, { key: 'handleBarTooltip', value(t) { let e; let i; const a = t.e; const s = t.opt; const r = this.w; const n = this.ttCtx; const o = n.getElTooltip(); let l = 0; let h = 0; let c = 0; const d = this.getBarTooltipXY({ e: a, opt: s }); e = d.i; const g = d.barHeight; const u = d.j; if (r.globals.capturedSeriesIndex = e, r.globals.capturedDataPointIndex = u, r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || !r.config.tooltip.shared ? (h = d.x, c = d.y, i = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[e] : r.config.stroke.width, l = h) : r.globals.comboCharts || r.config.tooltip.shared || (l /= 2), isNaN(c) ? c = r.globals.svgHeight - n.tooltipRect.ttHeight : c < 0 && (c = 0), h + n.tooltipRect.ttWidth > r.globals.gridWidth ? h -= n.tooltipRect.ttWidth : h < 0 && (h = 0), n.w.config.tooltip.followCursor) { const f = n.getElGrid().getBoundingClientRect(); c = n.e.clientY - f.top; } if (n.tooltip === null && (n.tooltip = r.globals.dom.baseEl.querySelector('.apexcharts-tooltip')), r.config.tooltip.shared || (r.globals.comboBarCount > 0 ? n.tooltipPosition.moveXCrosshairs(l + i / 2) : n.tooltipPosition.moveXCrosshairs(l)), !n.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && n.tooltipUtil.hasBars())) { const p = r.globals.isMultipleYAxis ? r.config.yaxis[x] && r.config.yaxis[x].reversed : r.config.yaxis[0].reversed; p && (h -= n.tooltipRect.ttWidth) < 0 && (h = 0), o.style.left = `${h + r.globals.translateX}px`; var x = parseInt(s.paths.parentNode.getAttribute('data:realIndex'), 10); !p || r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || (c = c + g - 2 * (r.globals.series[e][u] < 0 ? g : 0)), n.tooltipRect.ttHeight + c > r.globals.gridHeight ? (c = r.globals.gridHeight - n.tooltipRect.ttHeight + r.globals.translateY, o.style.top = `${c}px`) : o.style.top = `${c + r.globals.translateY - n.tooltipRect.ttHeight / 2}px`; } } }, {
      key: 'getBarTooltipXY',
      value(t) {
        const { e } = t; const i = t.opt; const a = this.w; let s = null; const r = this.ttCtx; let n = 0; let o = 0; let l = 0; let h = 0; let c = 0; const
          d = e.target.classList; if (d.contains('apexcharts-bar-area') || d.contains('apexcharts-candlestick-area') || d.contains('apexcharts-rangebar-area')) {
          const g = e.target; const u = g.getBoundingClientRect(); const f = i.elGrid.getBoundingClientRect(); const p = u.height; c = u.height; const x = u.width; const b = parseInt(g.getAttribute('cx'), 10); const m = parseInt(g.getAttribute('cy'), 10); h = parseFloat(g.getAttribute('barWidth')); const v = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX; s = parseInt(g.getAttribute('j'), 10), n = parseInt(g.parentNode.getAttribute('rel'), 10) - 1; const y = g.getAttribute('data-range-y1'); const w = g.getAttribute('data-range-y2'); a.globals.comboCharts && (n = parseInt(g.parentNode.getAttribute('data:realIndex'), 10)), r.tooltipLabels.drawSeriesTexts({
            ttItems: i.ttItems, i: n, j: s, y1: y ? parseInt(y, 10) : null, y2: w ? parseInt(w, 10) : null, shared: !r.showOnIntersect && a.config.tooltip.shared,
          }), a.config.tooltip.followCursor ? a.globals.isBarHorizontal ? (o = v - f.left + 15, l = m - r.dataPointsDividedHeight + p / 2 - r.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? b - x / 2 : b - r.dataPointsDividedWidth + x / 2, l = e.clientY - f.top - r.tooltipRect.ttHeight / 2 - 15) : a.globals.isBarHorizontal ? ((o = b) < r.xyRatios.baseLineInvertedY && (o = b - r.tooltipRect.ttWidth), l = m - r.dataPointsDividedHeight + p / 2 - r.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? b - x / 2 : b - r.dataPointsDividedWidth + x / 2, l = m);
        } return {
          x: o, y: l, barHeight: c, barWidth: h, i: n, j: s,
        };
      },
    }]), t;
  }()); const ut = (function () {
    function t(i) { e(this, t), this.w = i.w, this.ttCtx = i; } return a(t, [{
      key: 'drawXaxisTooltip',
      value() {
        const t = this.w; const e = this.ttCtx; const i = t.config.xaxis.position === 'bottom'; e.xaxisOffY = i ? t.globals.gridHeight + 1 : 1; const a = i ? 'apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom' : 'apexcharts-xaxistooltip apexcharts-xaxistooltip-top'; const
          s = t.globals.dom.elWrap; e.blxaxisTooltip && (t.globals.dom.baseEl.querySelector('.apexcharts-xaxistooltip') === null && (e.xaxisTooltip = document.createElement('div'), e.xaxisTooltip.setAttribute('class', `${a} apexcharts-theme-${t.config.tooltip.theme}`), s.appendChild(e.xaxisTooltip), e.xaxisTooltipText = document.createElement('div'), e.xaxisTooltipText.classList.add('apexcharts-xaxistooltip-text'), e.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, e.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, e.xaxisTooltip.appendChild(e.xaxisTooltipText)));
      },
    }, { key: 'drawYaxisTooltip', value() { for (var t = this.w, e = this.ttCtx, i = function (i) { const a = t.config.yaxis[i].opposite || t.config.yaxis[i].crosshairs.opposite; e.yaxisOffX = a ? t.globals.gridWidth + 1 : 1; let s = 'apexcharts-yaxistooltip apexcharts-yaxistooltip-'.concat(i, a ? ' apexcharts-yaxistooltip-right' : ' apexcharts-yaxistooltip-left'); t.globals.yAxisSameScaleIndices.map(((e, a) => { e.map(((e, a) => { a === i && (s += t.config.yaxis[a].show ? ' ' : ' apexcharts-yaxistooltip-hidden'); })); })); const r = t.globals.dom.elWrap; e.blyaxisTooltip && (t.globals.dom.baseEl.querySelector('.apexcharts-yaxistooltip apexcharts-yaxistooltip-'.concat(i)) === null && (e.yaxisTooltip = document.createElement('div'), e.yaxisTooltip.setAttribute('class', `${s} apexcharts-theme-${t.config.tooltip.theme}`), r.appendChild(e.yaxisTooltip), i === 0 && (e.yaxisTooltipText = []), e.yaxisTooltipText.push(document.createElement('div')), e.yaxisTooltipText[i].classList.add('apexcharts-yaxistooltip-text'), e.yaxisTooltip.appendChild(e.yaxisTooltipText[i]))); }, a = 0; a < t.config.yaxis.length; a++)i(a); } }, { key: 'setXCrosshairWidth', value() { const t = this.w; const e = this.ttCtx; const i = e.getElXCrosshairs(); if (e.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) { const a = t.globals.dom.baseEl.querySelector('.apexcharts-bar-area'); if (a !== null && t.config.xaxis.crosshairs.width === 'barWidth') { const s = parseFloat(a.getAttribute('barWidth')); e.xcrosshairsWidth = s; } else if (t.config.xaxis.crosshairs.width === 'tickWidth') { const r = t.globals.labels.length; e.xcrosshairsWidth = t.globals.gridWidth / r; } } else if (t.config.xaxis.crosshairs.width === 'tickWidth') { const n = t.globals.labels.length; e.xcrosshairsWidth = t.globals.gridWidth / n; } else if (t.config.xaxis.crosshairs.width === 'barWidth') { const o = t.globals.dom.baseEl.querySelector('.apexcharts-bar-area'); if (o !== null) { const l = parseFloat(o.getAttribute('barWidth')); e.xcrosshairsWidth = l; } else e.xcrosshairsWidth = 1; }t.globals.isBarHorizontal && (e.xcrosshairsWidth = 0), i !== null && e.xcrosshairsWidth > 0 && i.setAttribute('width', e.xcrosshairsWidth); } }, { key: 'handleYCrosshair', value() { const t = this.w; const e = this.ttCtx; e.ycrosshairs = t.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs'), e.ycrosshairsHidden = t.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs-hidden'); } }, { key: 'drawYaxisTooltipText', value(t, e, i) { const a = this.ttCtx; const s = this.w; const r = s.globals.yLabelFormatters[t]; if (a.blyaxisTooltip) { const n = a.getElGrid().getBoundingClientRect(); const o = (e - n.top) * i.yRatio[t]; const l = s.globals.maxYArr[t] - s.globals.minYArr[t]; const h = s.globals.minYArr[t] + (l - o); a.tooltipPosition.moveYCrosshairs(e - n.top), a.yaxisTooltipText[t].innerHTML = r(h), a.tooltipPosition.moveYAxisTooltip(t); } } }]), t;
  }()); const ft = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w; const a = this.w; this.tConfig = a.config.tooltip, this.tooltipUtil = new lt(this), this.tooltipLabels = new ht(this), this.tooltipPosition = new ct(this), this.marker = new dt(this), this.intersect = new gt(this), this.axesTooltip = new ut(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !a.globals.isBarHorizontal && this.tConfig.shared; } return a(t, [{ key: 'getElTooltip', value(t) { return t || (t = this), t.w.globals.dom.baseEl.querySelector('.apexcharts-tooltip'); } }, { key: 'getElXCrosshairs', value() { return this.w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs'); } }, { key: 'getElGrid', value() { return this.w.globals.dom.baseEl.querySelector('.apexcharts-grid'); } }, { key: 'drawTooltip', value(t) { const e = this.w; this.xyRatios = t, this.blxaxisTooltip = e.config.xaxis.tooltip.enabled && e.globals.axisCharts, this.blyaxisTooltip = e.config.yaxis[0].tooltip.enabled && e.globals.axisCharts, this.allTooltipSeriesGroups = [], e.globals.axisCharts || (this.showTooltipTitle = !1); const i = document.createElement('div'); if (i.classList.add('apexcharts-tooltip'), i.classList.add('apexcharts-theme-'.concat(this.tConfig.theme)), e.globals.dom.elWrap.appendChild(i), e.globals.axisCharts) { this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair(); const a = new O(this.ctx); this.xAxisTicksPositions = a.getXAxisTicksPositions(); } if (!e.globals.comboCharts && !this.tConfig.intersect && e.config.chart.type !== 'bar' && e.config.chart.type !== 'rangeBar' || this.tConfig.shared || (this.showOnIntersect = !0), e.config.markers.size !== 0 && e.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), e.globals.collapsedSeries.length !== e.globals.series.length) { this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints, this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement('div'), this.tooltipTitle.classList.add('apexcharts-tooltip-title'), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle)); let s = e.globals.series.length; (e.globals.xyCharts || e.globals.comboCharts) && this.tConfig.shared && (s = this.showOnIntersect ? 1 : e.globals.series.length), this.legendLabels = e.globals.dom.baseEl.querySelectorAll('.apexcharts-legend-text'), this.ttItems = this.createTTElements(s), this.addSVGEvents(); } } }, { key: 'createTTElements', value(t) { for (var e = this.w, i = [], a = this.getElTooltip(), s = 0; s < t; s++) { const r = document.createElement('div'); r.classList.add('apexcharts-tooltip-series-group'), this.tConfig.shared && this.tConfig.enabledOnSeries && Array.isArray(this.tConfig.enabledOnSeries) && this.tConfig.enabledOnSeries.indexOf(s) < 0 && r.classList.add('apexcharts-tooltip-series-group-hidden'); const n = document.createElement('span'); n.classList.add('apexcharts-tooltip-marker'), n.style.backgroundColor = e.globals.colors[s], r.appendChild(n); const o = document.createElement('div'); o.classList.add('apexcharts-tooltip-text'), o.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, o.style.fontSize = this.tConfig.style.fontSize; const l = document.createElement('div'); l.classList.add('apexcharts-tooltip-y-group'); const h = document.createElement('span'); h.classList.add('apexcharts-tooltip-text-label'), l.appendChild(h); const c = document.createElement('span'); c.classList.add('apexcharts-tooltip-text-value'), l.appendChild(c); const d = document.createElement('div'); d.classList.add('apexcharts-tooltip-z-group'); const g = document.createElement('span'); g.classList.add('apexcharts-tooltip-text-z-label'), d.appendChild(g); const u = document.createElement('span'); u.classList.add('apexcharts-tooltip-text-z-value'), d.appendChild(u), o.appendChild(l), o.appendChild(d), r.appendChild(o), a.appendChild(r), i.push(r); } return i; } }, {
      key: 'addSVGEvents',
      value() {
        const t = this.w; const e = t.config.chart.type; const i = this.getElTooltip(); const a = !(e !== 'bar' && e !== 'candlestick' && e !== 'rangeBar'); const s = e === 'area' || e === 'line' || e === 'scatter' || e === 'bubble' || e === 'radar'; const r = t.globals.dom.Paper.node; const n = this.getElGrid(); n && (this.seriesBound = n.getBoundingClientRect()); let o; const l = []; const h = []; const c = {
          hoverArea: r, elGrid: n, tooltipEl: i, tooltipY: l, tooltipX: h, ttItems: this.ttItems,
        }; if (t.globals.axisCharts && (s ? o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a ? o = t.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-rangebar-area') : e === 'heatmap' && (o = t.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-heatmap')), o && o.length)) for (let d = 0; d < o.length; d++)l.push(o[d].getAttribute('cy')), h.push(o[d].getAttribute('cx')); if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || a && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([r], c); else if (a && !t.globals.comboCharts || s && this.showOnIntersect) this.addDatapointEventsListeners(c); else if (!t.globals.axisCharts || e === 'heatmap') { const g = t.globals.dom.baseEl.querySelectorAll('.apexcharts-series'); this.addPathsEventListeners(g, c); } if (this.showOnIntersect) { const u = t.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker'); u.length > 0 && this.addPathsEventListeners(u, c), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c); }
      },
    }, {
      key: 'drawFixedTooltipRect',
      value() {
        const t = this.w; const e = this.getElTooltip(); const i = e.getBoundingClientRect(); const a = i.width + 10; const s = i.height + 10; let r = this.tConfig.fixed.offsetX; let n = this.tConfig.fixed.offsetY; const o = this.tConfig.fixed.position.toLowerCase(); return o.indexOf('right') > -1 && (r = r + t.globals.svgWidth - a + 10), o.indexOf('bottom') > -1 && (n = n + t.globals.svgHeight - s - 10), e.style.left = `${r}px`, e.style.top = `${n}px`, {
          x: r, y: n, ttWidth: a, ttHeight: s,
        };
      },
    }, { key: 'addDatapointEventsListeners', value(t) { const e = this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-rangebar-area'); this.addPathsEventListeners(e, t); } }, {
      key: 'addPathsEventListeners',
      value(t, e) {
        for (var i = this, a = function (a) {
            const s = {
              paths: t[a], tooltipEl: e.tooltipEl, tooltipY: e.tooltipY, tooltipX: e.tooltipX, elGrid: e.elGrid, hoverArea: e.hoverArea, ttItems: e.ttItems,
            }; ['mousemove', 'mouseup', 'touchmove', 'mouseout', 'touchend'].map(((e) => t[a].addEventListener(e, i.seriesHover.bind(i, s), { capture: !1, passive: !0 })));
          }, s = 0; s < t.length; s++)a(s);
      },
    }, {
      key: 'seriesHover',
      value(t, e) {
        const i = this; let a = []; const s = this.w; s.config.chart.group && (a = this.ctx.getGroupedCharts()), s.globals.axisCharts && (s.globals.minX === -1 / 0 && s.globals.maxX === 1 / 0 || s.globals.dataPoints === 0) || (a.length ? a.forEach(((a) => {
          const s = i.getElTooltip(a); const r = {
            paths: t.paths, tooltipEl: s, tooltipY: t.tooltipY, tooltipX: t.tooltipX, elGrid: t.elGrid, hoverArea: t.hoverArea, ttItems: a.w.globals.tooltip.ttItems,
          }; a.w.globals.minX === i.w.globals.minX && a.w.globals.maxX === i.w.globals.maxX && a.w.globals.tooltip.seriesHoverByContext({
            chartCtx: a, ttCtx: a.w.globals.tooltip, opt: r, e,
          });
        })) : this.seriesHoverByContext({
          chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t, e,
        }));
      },
    }, {
      key: 'seriesHoverByContext',
      value(t) {
        const e = t.chartCtx; const i = t.ttCtx; const a = t.opt; const s = t.e; const r = e.w; const n = this.getElTooltip(); (i.tooltipRect = {
          x: 0, y: 0, ttWidth: n.getBoundingClientRect().width, ttHeight: n.getBoundingClientRect().height,
        }, i.e = s, !i.tooltipUtil.hasBars() || r.globals.comboCharts || i.isBarShared) || this.tConfig.onDatasetHover.highlightDataSeries && new F(e).toggleSeriesOnHover(s, s.target.parentNode); i.fixedTooltip && i.drawFixedTooltipRect(), r.globals.axisCharts ? i.axisChartsTooltips({ e: s, opt: a, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: s, opt: a, tooltipRect: i.tooltipRect });
      },
    }, {
      key: 'axisChartsTooltips',
      value(t) {
        let e; let i; const a = t.e; const s = t.opt; const r = this.w; const n = s.elGrid.getBoundingClientRect(); const o = a.type === 'touchmove' ? a.touches[0].clientX : a.clientX; const l = a.type === 'touchmove' ? a.touches[0].clientY : a.clientY; if (this.clientY = l, this.clientX = o, r.globals.capturedSeriesIndex = -1, r.globals.capturedDataPointIndex = -1, l < n.top || l > n.top + n.height) this.handleMouseOut(s); else {
          if (Array.isArray(this.tConfig.enabledOnSeries) && !r.config.tooltip.shared) { const h = parseInt(s.paths.getAttribute('index'), 10); if (this.tConfig.enabledOnSeries.indexOf(h) < 0) return void this.handleMouseOut(s); } const c = this.getElTooltip(); const d = this.getElXCrosshairs(); let g = r.globals.xyCharts || r.config.chart.type === 'bar' && !r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r.globals.comboCharts && this.tooltipUtil.hasBars(); if (r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && (g = !1), a.type === 'mousemove' || a.type === 'touchmove' || a.type === 'mouseup') {
            if (d !== null && d.classList.add('apexcharts-active'), this.ycrosshairs !== null && this.blyaxisTooltip && this.ycrosshairs.classList.add('apexcharts-active'), g && !this.showOnIntersect) this.handleStickyTooltip(a, o, l, s); else if (r.config.chart.type === 'heatmap') {
              const u = this.intersect.handleHeatTooltip({
                e: a, opt: s, x: e, y: i,
              }); e = u.x, i = u.y, c.style.left = `${e}px`, c.style.top = `${i}px`;
            } else {
 this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a, opt: s }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
              e: a, opt: s, x: e, y: i,
            }); 
} if (this.blyaxisTooltip) for (let f = 0; f < r.config.yaxis.length; f++) this.axesTooltip.drawYaxisTooltipText(f, l, this.xyRatios); s.tooltipEl.classList.add('apexcharts-active');
          } else a.type !== 'mouseout' && a.type !== 'touchend' || this.handleMouseOut(s);
        }
      },
    }, {
      key: 'nonAxisChartsTooltips',
      value(t) {
        const { e } = t; const i = t.opt; const a = t.tooltipRect; const s = this.w; const r = i.paths.getAttribute('rel'); const n = this.getElTooltip(); const
          o = s.globals.dom.elWrap.getBoundingClientRect(); if (e.type === 'mousemove' || e.type === 'touchmove') { n.classList.add('apexcharts-active'), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(r, 10) - 1, shared: !1 }); const l = s.globals.clientX - o.left - a.ttWidth / 2; const h = s.globals.clientY - o.top - a.ttHeight - 10; n.style.left = `${l}px`, n.style.top = `${h}px`; } else e.type !== 'mouseout' && e.type !== 'touchend' || n.classList.remove('apexcharts-active');
      },
    }, {
      key: 'handleStickyTooltip',
      value(t, e, i, a) {
        const s = this.w; const r = this.tooltipUtil.getNearestValues({
          context: this, hoverArea: a.hoverArea, elGrid: a.elGrid, clientX: e, clientY: i,
        }); const n = r.j; const o = r.capturedSeries; r.hoverX < 0 || r.hoverX > s.globals.gridWidth ? this.handleMouseOut(a) : o !== null ? this.handleStickyCapturedSeries(t, o, a, n) : this.tooltipUtil.isXoverlap(n) && this.create(t, this, 0, n, a.ttItems);
      }, 
    }, { key: 'handleStickyCapturedSeries', value(t, e, i, a) { const s = this.w; s.globals.series[e][a] === null ? this.handleMouseOut(i) : void 0 !== s.globals.series[e][a] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(a) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, e, a, i.ttItems) : this.create(t, this, e, a, i.ttItems, !1) : this.tooltipUtil.isXoverlap(a) && this.create(t, this, 0, a, i.ttItems); } }, { key: 'deactivateHoverFilter', value() { for (let t = this.w, e = new p(this.ctx), i = t.globals.dom.Paper.select('.apexcharts-bar-area'), a = 0; a < i.length; a++)e.pathMouseLeave(i[a]); } }, { key: 'handleMouseOut', value(t) { const e = this.w; const i = this.getElXCrosshairs(); if (t.tooltipEl.classList.remove('apexcharts-active'), this.deactivateHoverFilter(), e.config.chart.type !== 'bubble' && this.marker.resetPointsSize(), i !== null && i.classList.remove('apexcharts-active'), this.ycrosshairs !== null && this.ycrosshairs.classList.remove('apexcharts-active'), this.blxaxisTooltip && this.xaxisTooltip.classList.remove('apexcharts-active'), this.blyaxisTooltip) { this.yaxisTTEls === null && (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip')); for (let a = 0; a < this.yaxisTTEls.length; a++) this.yaxisTTEls[a].classList.remove('apexcharts-active'); }e.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(((t) => { const e = t.getAttribute('data:default-text'); t.innerHTML = decodeURIComponent(e); })); } }, { key: 'markerClick', value(t, e, i) { const a = this.w; typeof a.config.chart.events.markerClick === 'function' && a.config.chart.events.markerClick(t, this.ctx, { seriesIndex: e, dataPointIndex: i, w: a }), this.ctx.events.fireEvent('markerClick', [t, this.ctx, { seriesIndex: e, dataPointIndex: i, w: a }]); } }, {
      key: 'create',
      value(t, e, i, a, s) {
        let r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null; const n = this.w; const o = e; t.type === 'mouseup' && this.markerClick(t, i, a), r === null && (r = this.tConfig.shared); const l = this.tooltipUtil.hasMarkers(); const h = this.tooltipUtil.getElBars(); if (n.config.legend.tooltipHoverFormatter) { const c = n.config.legend.tooltipHoverFormatter; const d = Array.from(this.legendLabels); d.forEach(((t) => { const e = t.getAttribute('data:default-text'); t.innerHTML = decodeURIComponent(e); })); for (let g = 0; g < d.length; g++) { const u = d[g]; const f = parseInt(u.getAttribute('i'), 10); const x = decodeURIComponent(u.getAttribute('data:default-text')); const b = c(x, { seriesIndex: r ? f : i, dataPointIndex: a, w: n }); if (r)u.innerHTML = n.globals.collapsedSeriesIndices.indexOf(f) < 0 ? b : x; else if (u.innerHTML = f === i ? b : x, i === f) break; } } if (r) {
          if (o.tooltipLabels.drawSeriesTexts({
            ttItems: s, i, j: a, shared: !this.showOnIntersect && this.tConfig.shared,
          }), l && (n.globals.markers.largestSize > 0 ? o.marker.enlargePoints(a) : o.tooltipPosition.moveDynamicPointsOnHover(a)), this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(h), this.barSeriesHeight > 0)) { const m = new p(this.ctx); const v = n.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a, "']")); this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a); for (let y = 0; y < v.length; y++)m.pathMouseEnter(v[y]); }
        } else {
 o.tooltipLabels.drawSeriesTexts({
          shared: !1, ttItems: s, i, j: a,
        }), this.tooltipUtil.hasBars() && o.tooltipPosition.moveStickyTooltipOverBars(a), l && o.tooltipPosition.moveMarkers(i, a); 
}
      },
    }]), t;
  }()); const pt = (function () {
    function t(i) { e(this, t), this.w = i.w, this.barCtx = i; } return a(t, [{
      key: 'handleBarDataLabels',
      value(t) {
        const e = t.x; const i = t.y; const a = t.y1; const s = t.y2; const r = t.i; const n = t.j; const o = t.realIndex; const l = t.series; const h = t.barHeight; const c = t.barWidth; const d = t.barYPosition; const g = t.visibleSeries; const u = t.renderedPath; const f = this.w; const x = new p(this.barCtx.ctx); const b = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o] : this.barCtx.strokeWidth; let m = e + parseFloat(c * g); let v = i + parseFloat(h * g); f.globals.isXNumeric && !f.globals.isBarHorizontal && (m = e + parseFloat(c * (g + 1)), v = i + parseFloat(h * (g + 1)) - b); const y = e; let w = i; let k = {}; const A = f.config.dataLabels; const S = this.barCtx.barOptions.dataLabels; void 0 !== d && this.barCtx.isTimelineBar && (v = d, w = d); const C = A.offsetX; const L = A.offsetY; let P = { width: 0, height: 0 }; f.config.dataLabels.enabled && (P = x.getTextRects(f.globals.yLabelFormatters[0](f.globals.maxY), parseFloat(A.style.fontSize))); const T = {
          x: e, y: i, i: r, j: n, renderedPath: u, bcx: m, bcy: v, barHeight: h, barWidth: c, textRects: P, strokeWidth: b, dataLabelsX: y, dataLabelsY: w, barDataLabelsConfig: S, offX: C, offY: L,
        }; return k = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(T) : this.calculateColumnsDataLabelsPosition(T), u.attr({
          cy: k.bcy, cx: k.bcx, j: n, val: l[r][n], barHeight: h, barWidth: c,
        }), this.drawCalculatedDataLabels({
          x: k.dataLabelsX, y: k.dataLabelsY, val: this.barCtx.isTimelineBar ? [a, s] : l[r][n], i: o, j: n, barWidth: c, barHeight: h, textRects: P, dataLabelsConfig: A,
        });
      },
    }, {
      key: 'calculateColumnsDataLabelsPosition',
      value(t) {
        let e; const i = this.w; const a = t.i; const s = t.j; let r = t.y; let n = t.bcx; const o = t.barWidth; const l = t.barHeight; const h = t.textRects; let c = t.dataLabelsY; const d = t.barDataLabelsConfig; const g = t.strokeWidth; const u = t.offX; const f = t.offY; const p = i.config.plotOptions.bar.dataLabels.orientation === 'vertical'; n -= g / 2; const x = i.globals.gridWidth / i.globals.dataPoints; if (e = i.globals.isXNumeric ? n - o / 2 + u : n - x + o / 2 + u, p) { e = e + h.height / 2 - g / 2 - 2; } const b = this.barCtx.series[a][s] <= 0; switch (this.barCtx.isReversed && (r -= l), d.position) { case 'center': c = p ? b ? r + l / 2 + f : r + l / 2 - f : b ? r + l / 2 + h.height / 2 + f : r + l / 2 + h.height / 2 - f; break; case 'bottom': c = p ? b ? r + l + f : r + l - f : b ? r + l + h.height + g + f : r + l - h.height / 2 + g - f; break; case 'top': c = p ? b ? r + f : r - f : b ? r - h.height / 2 - f : r + h.height + f; } return i.config.chart.stacked || (c < 0 ? c = 0 + g : c + h.height / 3 > i.globals.gridHeight && (c = i.globals.gridHeight - g)), {
          bcx: n, bcy: r, dataLabelsX: e, dataLabelsY: c,
        };
      },
    }, {
      key: 'calculateBarsDataLabelsPosition',
      value(t) {
        const e = this.w; let i = t.x; const a = t.i; const s = t.j; const r = t.bcy; const n = t.barHeight; const o = t.barWidth; const l = t.textRects; let h = t.dataLabelsX; const c = t.strokeWidth; const d = t.barDataLabelsConfig; const g = t.offX; const u = t.offY; const f = e.globals.gridHeight / e.globals.dataPoints; const p = r - (this.barCtx.isTimelineBar ? 0 : f) + n / 2 + l.height / 2 + u - 3; const x = this.barCtx.series[a][s] <= 0; let b = i; switch (this.barCtx.isReversed && (b = i + o, i = e.globals.gridWidth - o), d.position) { case 'center': h = x ? b - o / 2 - g : b - o / 2 + g; break; case 'bottom': h = x ? b - o - c - Math.round(l.width / 2) - g : b - o + c + Math.round(l.width / 2) + g; break; case 'top': h = x ? b - c + Math.round(l.width / 2) - g : b - c - Math.round(l.width / 2) + g; } return e.config.chart.stacked || (h < 0 ? h = h + l.width + c : h + l.width / 2 > e.globals.gridWidth && (h = e.globals.gridWidth - l.width - c)), {
          bcx: i, bcy: r, dataLabelsX: h, dataLabelsY: p,
        };
      },
    }, {
      key: 'drawCalculatedDataLabels',
      value(t) {
        const e = t.x; const i = t.y; const a = t.val; const s = t.i; const r = t.j; const o = t.textRects; let l = t.barHeight; let h = t.barWidth; const c = t.dataLabelsConfig; const d = this.w; let g = 'rotate(0)'; d.config.plotOptions.bar.dataLabels.orientation === 'vertical' && (g = 'rotate(-90, '.concat(e, ', ').concat(i, ')')); const u = new Y(this.barCtx.ctx); const f = new p(this.barCtx.ctx); const x = c.formatter; let b = null; const m = d.globals.collapsedSeriesIndices.indexOf(s) > -1; if (c.enabled && !m) {
          b = f.group({ class: 'apexcharts-data-labels', transform: g }); let v = ''; void 0 !== a && (v = x(a, { seriesIndex: s, dataPointIndex: r, w: d })), a === 0 && d.config.chart.stacked && (v = ''); const y = d.globals.series[s][r] <= 0; const w = d.config.plotOptions.bar.dataLabels.position; if (d.config.plotOptions.bar.dataLabels.orientation === 'vertical' && (w === 'top' && (c.textAnchor = y ? 'end' : 'start'), w === 'center' && (c.textAnchor = 'middle'), w === 'bottom' && (c.textAnchor = y ? 'end' : 'start')), this.barCtx.isTimelineBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels)h < f.getTextRects(v, parseFloat(c.style.fontSize)).width && (v = ''); d.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? ((h = Math.abs(d.globals.series[s][r]) / this.barCtx.invertedYRatio[this.barCtx.yaxisIndex]) > 0 && o.width / 1.6 > h || h < 0 && o.width / 1.6 < h) && (v = '') : (l = Math.abs(d.globals.series[s][r]) / this.barCtx.yRatio[this.barCtx.yaxisIndex], o.height / 1.6 > l && (v = ''))); const k = n({}, c); this.barCtx.isHorizontal && a < 0 && (c.textAnchor === 'start' ? k.textAnchor = 'end' : c.textAnchor === 'end' && (k.textAnchor = 'start')), u.plotDataLabelsText({
            x: e, y: i, text: v, i: s, j: r, parent: b, dataLabelsConfig: k, alwaysDrawDataLabel: !0, offsetCorrection: !0,
          });
        } return b;
      },
    }]), t;
  }()); const xt = (function () {
    function t(i) { e(this, t), this.w = i.w, this.barCtx = i; } return a(t, [{ key: 'initVariables', value(t) { const e = this.w; this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1; for (let i = 0; i < t.length; i++) if (t[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[i].length), e.globals.isXNumeric) for (let a = 0; a < t[i].length; a++)e.globals.seriesX[i][a] > e.globals.minX && e.globals.seriesX[i][a] < e.globals.maxX && this.barCtx.visibleItems++; else this.barCtx.visibleItems = e.globals.dataPoints; this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1); } }, {
      key: 'initialPositions',
      value() {
        let t; let e; let i; let a; let s; let r; let n; let o; const l = this.w; let h = l.globals.dataPoints; if (this.barCtx.isTimelineBar && (h = l.globals.labels.length), this.barCtx.isHorizontal)s = (i = l.globals.gridHeight / h) / this.barCtx.seriesLen, l.globals.isXNumeric && (s = (i = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s = s * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, o = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), e = (i - s * this.barCtx.seriesLen) / 2; else { if (a = l.globals.gridWidth / this.barCtx.visibleItems, l.config.xaxis.convertedCatToNumeric && (a = l.globals.gridWidth / l.globals.dataPoints), r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l.globals.isXNumeric) { let c = this.barCtx.xRatio; l.config.xaxis.convertedCatToNumeric && (c = this.barCtx.initialXRatio), l.globals.minXDiff && l.globals.minXDiff / c > 0 && (a = l.globals.minXDiff / c), (r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1); }n = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = l.globals.padHorizontal + (a - r * this.barCtx.seriesLen) / 2; } return {
          x: t, y: e, yDivision: i, xDivision: a, barHeight: s, barWidth: r, zeroH: n, zeroW: o,
        };
      },
    }, {
      key: 'getPathFillColor',
      value(t, e, i, a) {
        const s = this.w; const r = new M(this.barCtx.ctx); let n = null; const o = this.barCtx.barOptions.distributed ? i : e; this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(((a) => { t[e][i] >= a.from && t[e][i] <= a.to && (n = a.color); })); return s.config.series[e].data[i] && s.config.series[e].data[i].fillColor && (n = s.config.series[e].data[i].fillColor), r.fillPath({
          seriesNumber: this.barCtx.barOptions.distributed ? o : a, dataPointIndex: i, color: n, value: t[e][i],
        });
      },
    }, { key: 'getStrokeWidth', value(t, e, i) { let a = 0; const s = this.w; return void 0 === this.barCtx.series[t][e] || this.barCtx.series[t][e] === null ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, s.config.stroke.show && (this.barCtx.isNullValue || (a = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), a; } }, { key: 'getBarEndingShape', value(t, e, i, a, s) { const r = new p(this.barCtx.ctx); if (this.barCtx.isHorizontal) { let n = null; let o = e.x; if (void 0 !== i[a][s] || i[a][s] !== null) { const l = i[a][s] < 0; let h = e.barHeight / 2 - e.strokeWidth; switch (l && (h = -e.barHeight / 2 - e.strokeWidth), t.config.chart.stacked || this.barCtx.barOptions.endingShape === 'rounded' && (o = e.x - h / 2), this.barCtx.barOptions.endingShape) { case 'flat': n = r.line(o, e.barYPosition + e.barHeight - e.strokeWidth); break; case 'rounded': n = r.quadraticCurve(o + h, e.barYPosition + (e.barHeight - e.strokeWidth) / 2, o, e.barYPosition + e.barHeight - e.strokeWidth); } } return { path: n, ending_p_from: '', newX: o }; } let c = null; let d = e.y; if (void 0 !== i[a][s] || i[a][s] !== null) { const g = i[a][s] < 0; let u = e.barWidth / 2 - e.strokeWidth; switch (g && (u = -e.barWidth / 2 - e.strokeWidth), t.config.chart.stacked || this.barCtx.barOptions.endingShape === 'rounded' && (d += u / 2), this.barCtx.barOptions.endingShape) { case 'flat': c = r.line(e.barXPosition + e.barWidth - e.strokeWidth, d); break; case 'rounded': c = r.quadraticCurve(e.barXPosition + (e.barWidth - e.strokeWidth) / 2, d - u, e.barXPosition + e.barWidth - e.strokeWidth, d); } } return { path: c, ending_p_from: '', newY: d }; } }]), t;
  }()); const bt = (function () {
    function t(i, a) { e(this, t), this.ctx = i, this.w = i.w; const s = this.w; this.barOptions = s.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s.config.stroke.width, this.isNullValue = !1, this.isTimelineBar = s.config.xaxis.type === 'datetime' && s.globals.seriesRangeBarTimeline.length, this.xyRatios = a, this.xyRatios !== null && (this.xRatio = a.xRatio, this.initialXRatio = a.initialXRatio, this.yRatio = a.yRatio, this.invertedXRatio = a.invertedXRatio, this.invertedYRatio = a.invertedYRatio, this.baseLineY = a.baseLineY, this.baseLineInvertedY = a.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.barHelpers = new xt(this); } return a(t, [{
      key: 'draw',
      value(t, e) {
        const i = this.w; const a = new p(this.ctx); const s = new I(this.ctx, i); t = s.getLogSeries(t), this.series = t, this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t); const r = a.group({ class: 'apexcharts-bar-series apexcharts-plot-series' }); i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn('WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.'); for (let o = 0, l = 0; o < t.length; o++, l++) {
          var h; var c; var d; var u; let f = void 0; let x = void 0; const b = []; const m = []; const v = i.globals.comboCharts ? e[o] : o; const y = a.group({
            class: 'apexcharts-series', rel: o + 1, seriesName: g.escapeString(i.globals.seriesNames[v]), 'data:realIndex': v,
          }); this.ctx.series.addCollapsedClassToSeries(y, v), t[o].length > 0 && (this.visibleI += 1); let w = 0; let k = 0; this.yRatio.length > 1 && (this.yaxisIndex = v), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed; const A = this.barHelpers.initialPositions(); x = A.y, w = A.barHeight, c = A.yDivision, u = A.zeroW, f = A.x, k = A.barWidth, h = A.xDivision, d = A.zeroH, this.horizontal || m.push(f + k / 2); for (let S = a.group({ class: 'apexcharts-datalabels', 'data:realIndex': v }), C = 0; C < i.globals.dataPoints; C++) {
            const L = this.barHelpers.getStrokeWidth(o, C, v); let P = null; const T = {
              indexes: {
                i: o, j: C, realIndex: v, bc: l,
              },
              x: f,
              y: x,
              strokeWidth: L,
              elSeries: y,
            }; this.isHorizontal ? (P = this.drawBarPaths(n({}, T, { barHeight: w, zeroW: u, yDivision: c })), k = this.series[o][C] / this.invertedYRatio) : (P = this.drawColumnPaths(n({}, T, { xDivision: h, barWidth: k, zeroH: d })), w = this.series[o][C] / this.yRatio[this.yaxisIndex]), x = P.y, f = P.x, C > 0 && m.push(f + k / 2), b.push(x); const z = this.barHelpers.getPathFillColor(t, o, C, v); this.renderSeries({
              realIndex: v, pathFill: z, j: C, i: o, pathFrom: P.pathFrom, pathTo: P.pathTo, strokeWidth: L, elSeries: y, x: f, y: x, series: t, barHeight: w, barWidth: k, elDataLabelsWrap: S, visibleSeries: this.visibleI, type: 'bar',
            });
          }i.globals.seriesXvalues[v] = m, i.globals.seriesYvalues[v] = b, r.add(y);
        } return r;
      },
    }, {
      key: 'renderSeries',
      value(t) {
        const e = t.realIndex; let i = t.pathFill; let a = t.lineFill; const s = t.j; const r = t.i; const n = t.pathFrom; const o = t.pathTo; const l = t.strokeWidth; const h = t.elSeries; const c = t.x; const d = t.y; const g = t.y1; const f = t.y2; const x = t.series; const b = t.barHeight; const m = t.barWidth; const v = t.barYPosition; const y = t.elDataLabelsWrap; const w = t.visibleSeries; const k = t.type; const A = this.w; const S = new p(this.ctx); a || (a = this.barOptions.distributed ? A.globals.stroke.colors[s] : A.globals.stroke.colors[e]), A.config.series[r].data[s] && A.config.series[r].data[s].strokeColor && (a = A.config.series[r].data[s].strokeColor), this.isNullValue && (i = 'none'); const C = s / A.config.chart.animations.animateGradually.delay * (A.config.chart.animations.speed / A.globals.dataPoints) / 2.4; const L = S.renderPaths({
          i: r, j: s, realIndex: e, pathFrom: n, pathTo: o, stroke: a, strokeWidth: l, strokeLineCap: A.config.stroke.lineCap, fill: i, animationDelay: C, initialSpeed: A.config.chart.animations.speed, dataChangeSpeed: A.config.chart.animations.dynamicAnimation.speed, className: 'apexcharts-'.concat(k, '-area'),
        }); L.attr('clip-path', 'url(#gridRectMask'.concat(A.globals.cuid, ')')), void 0 !== g && void 0 !== f && (L.attr('data-range-y1', g), L.attr('data-range-y2', f)), new u(this.ctx).setSelectionFilter(L, e, s), h.add(L); const P = new pt(this).handleBarDataLabels({
          x: c, y: d, y1: g, y2: f, i: r, j: s, series: x, realIndex: e, barHeight: b, barWidth: m, barYPosition: v, renderedPath: L, visibleSeries: w,
        }); return P !== null && y.add(P), h.add(y), h;
      },
    }, {
      key: 'drawBarPaths',
      value(t) {
        const e = t.indexes; const i = t.barHeight; const a = t.strokeWidth; const s = t.zeroW; let r = t.x; let n = t.y; const o = t.yDivision; const l = t.elSeries; const h = this.w; const c = new p(this.ctx); const d = e.i; const g = e.j; const u = e.realIndex; let f = e.bc; h.globals.isXNumeric && (n = (h.globals.seriesX[d][g] - h.globals.minX) / this.invertedXRatio - i); const x = n + i * this.visibleI; let b = c.move(s, x); let m = c.move(s, x); h.globals.previousPaths.length > 0 && (m = this.getPreviousPath(u, g)); const v = {
          barHeight: i, strokeWidth: a, barYPosition: x, x: r = void 0 === this.series[d][g] || this.series[d][g] === null ? s : s + this.series[d][g] / this.invertedYRatio - 2 * (this.isReversed ? this.series[d][g] / this.invertedYRatio : 0), zeroW: s,
        }; const y = this.barHelpers.getBarEndingShape(h, v, this.series, d, g); if (b = b + c.line(y.newX, x) + y.path + c.line(s, x + i - a) + c.line(s, x), m = m + c.line(s, x) + y.ending_p_from + c.line(s, x + i - a) + c.line(s, x + i - a) + c.line(s, x), h.globals.isXNumeric || (n += o), this.barOptions.colors.backgroundBarColors.length > 0 && d === 0) { f >= this.barOptions.colors.backgroundBarColors.length && (f = 0); const w = this.barOptions.colors.backgroundBarColors[f]; const k = c.drawRect(0, x - i * this.visibleI, h.globals.gridWidth, i * this.seriesLen, 0, w, this.barOptions.colors.backgroundBarOpacity); l.add(k), k.node.classList.add('apexcharts-backgroundBar'); } return {
          pathTo: b, pathFrom: m, x: r, y: n, barYPosition: x,
        };
      },
    }, {
      key: 'drawColumnPaths',
      value(t) {
        const e = t.indexes; let i = t.x; let a = t.y; const s = t.xDivision; const r = t.barWidth; const n = t.zeroH; const o = t.strokeWidth; const l = t.elSeries; const h = this.w; const c = new p(this.ctx); const d = e.i; const g = e.j; const u = e.realIndex; let f = e.bc; if (h.globals.isXNumeric) { let x = d; h.globals.seriesX[d].length || (x = h.globals.maxValsInArrayIndex), i = (h.globals.seriesX[x][g] - h.globals.minX) / this.xRatio - r * this.seriesLen / 2; } const b = i + r * this.visibleI; let m = c.move(b, n); let v = c.move(b, n); h.globals.previousPaths.length > 0 && (v = this.getPreviousPath(u, g)); const y = {
          barWidth: r, strokeWidth: o, barXPosition: b, y: a = void 0 === this.series[d][g] || this.series[d][g] === null ? n : n - this.series[d][g] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[d][g] / this.yRatio[this.yaxisIndex] : 0), zeroH: n,
        }; const w = this.barHelpers.getBarEndingShape(h, y, this.series, d, g); if (m = m + c.line(b, w.newY) + w.path + c.line(b + r - o, n) + c.line(b - o / 2, n), v = v + c.line(b, n) + w.ending_p_from + c.line(b + r - o, n) + c.line(b + r - o, n) + c.line(b - o / 2, n), h.globals.isXNumeric || (i += s), this.barOptions.colors.backgroundBarColors.length > 0 && d === 0) { f >= this.barOptions.colors.backgroundBarColors.length && (f = 0); const k = this.barOptions.colors.backgroundBarColors[f]; const A = c.drawRect(b - r * this.visibleI, 0, r * this.seriesLen, h.globals.gridHeight, 0, k, this.barOptions.colors.backgroundBarOpacity); l.add(A), A.node.classList.add('apexcharts-backgroundBar'); } return {
          pathTo: m, pathFrom: v, x: i, y: a, barXPosition: b,
        };
      },
    }, { key: 'getPreviousPath', value(t, e) { for (var i, a = this.w, s = 0; s < a.globals.previousPaths.length; s++) { const r = a.globals.previousPaths[s]; r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(t, 10) && void 0 !== a.globals.previousPaths[s].paths[e] && (i = a.globals.previousPaths[s].paths[e].d); } return i; } }]), t;
  }()); const mt = (function (t) {
    function i() { return e(this, i), c(this, l(i).apply(this, arguments)); } return o(i, t), a(i, [{
      key: 'draw',
      value(t, e) {
        const i = this; const a = this.w; this.graphics = new p(this.ctx), this.bar = new bt(this.ctx, this.xyRatios); const s = new I(this.ctx, a); t = s.getLogSeries(t), this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t), a.config.chart.stackType === '100%' && (t = a.globals.seriesPercent.slice()), this.series = t, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = []; for (let r = 0; r < t.length; r++)t[r].length > 0 && (this.totalItems += t[r].length); for (var o = this.graphics.group({ class: 'apexcharts-bar-series apexcharts-plot-series' }), l = 0, h = 0, c = function (s, r) {
            let c = void 0; let d = void 0; let u = void 0; let f = void 0; const p = []; const x = []; const b = a.globals.comboCharts ? e[s] : s; i.yRatio.length > 1 && (i.yaxisIndex = b), i.isReversed = a.config.yaxis[i.yaxisIndex] && a.config.yaxis[i.yaxisIndex].reversed; let m = i.graphics.group({
              class: 'apexcharts-series', seriesName: g.escapeString(a.globals.seriesNames[b]), rel: s + 1, 'data:realIndex': b,
            }); const v = i.graphics.group({ class: 'apexcharts-datalabels', 'data:realIndex': b }); let y = 0; let w = 0; const k = i.initialPositions(l, h, c, d, u, f); h = k.y, y = k.barHeight, d = k.yDivision, f = k.zeroW, l = k.x, w = k.barWidth, c = k.xDivision, u = k.zeroH, i.yArrj = [], i.yArrjF = [], i.yArrjVal = [], i.xArrj = [], i.xArrjF = [], i.xArrjVal = [], i.prevY.length === 1 && i.prevY[0].every(((t) => isNaN(t))) && (i.prevY[0] = i.prevY[0].map(((t) => u)), i.prevYF[0] = i.prevYF[0].map(((t) => 0))); for (let A = 0; A < a.globals.dataPoints; A++) {
              const S = i.barHelpers.getStrokeWidth(s, A, b); const C = {
                indexes: {
                  i: s, j: A, realIndex: b, bc: r,
                },
                strokeWidth: S,
                x: l,
                y: h,
                elSeries: m,
              }; let L = null; i.isHorizontal ? (L = i.drawStackedBarPaths(n({}, C, { zeroW: f, barHeight: y, yDivision: d })), w = i.series[s][A] / i.invertedYRatio) : (L = i.drawStackedColumnPaths(n({}, C, { xDivision: c, barWidth: w, zeroH: u })), y = i.series[s][A] / i.yRatio[i.yaxisIndex]), h = L.y, l = L.x, p.push(l), x.push(h); const P = i.barHelpers.getPathFillColor(t, s, A, b); m = i.renderSeries({
                realIndex: b, pathFill: P, j: A, i: s, pathFrom: L.pathFrom, pathTo: L.pathTo, strokeWidth: S, elSeries: m, x: l, y: h, series: t, barHeight: y, barWidth: w, elDataLabelsWrap: v, type: 'bar', visibleSeries: 0,
              });
            }a.globals.seriesXvalues[b] = p, a.globals.seriesYvalues[b] = x, i.prevY.push(i.yArrj), i.prevYF.push(i.yArrjF), i.prevYVal.push(i.yArrjVal), i.prevX.push(i.xArrj), i.prevXF.push(i.xArrjF), i.prevXVal.push(i.xArrjVal), o.add(m);
          }, d = 0, u = 0; d < t.length; d++, u++)c(d, u); return o;
      },
    }, {
      key: 'initialPositions',
      value(t, e, i, a, s, r) {
        let n; let o; const l = this.w; return this.isHorizontal ? (n = (n = a = l.globals.gridHeight / l.globals.dataPoints) * parseInt(l.config.plotOptions.bar.barHeight, 10) / 100, r = this.baseLineInvertedY + l.globals.padHorizontal + (this.isReversed ? l.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e = (a - n) / 2) : (o = i = l.globals.gridWidth / l.globals.dataPoints, o = l.globals.isXNumeric ? (i = l.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : o * parseInt(l.config.plotOptions.bar.columnWidth, 10) / 100, s = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t = l.globals.padHorizontal + (i - o) / 2), {
          x: t, y: e, yDivision: a, xDivision: i, barHeight: n, barWidth: o, zeroH: s, zeroW: r,
        };
      },
    }, {
      key: 'drawStackedBarPaths',
      value(t) {
        for (var e, i = t.indexes, a = t.barHeight, s = t.strokeWidth, r = t.zeroW, n = t.x, o = t.y, l = t.yDivision, h = t.elSeries, c = this.w, d = o, g = i.i, u = i.j, f = i.realIndex, p = i.bc, x = 0, b = 0; b < this.prevXF.length; b++)x += this.prevXF[b][u]; if (g > 0) { let m = r; this.prevXVal[g - 1][u] < 0 ? m = this.series[g][u] >= 0 ? this.prevX[g - 1][u] + x - 2 * (this.isReversed ? x : 0) : this.prevX[g - 1][u] : this.prevXVal[g - 1][u] >= 0 && (m = this.series[g][u] >= 0 ? this.prevX[g - 1][u] : this.prevX[g - 1][u] - x + 2 * (this.isReversed ? x : 0)), e = m; } else e = r; n = this.series[g][u] === null ? e : e + this.series[g][u] / this.invertedYRatio - 2 * (this.isReversed ? this.series[g][u] / this.invertedYRatio : 0); const v = {
          barHeight: a, strokeWidth: s, invertedYRatio: this.invertedYRatio, barYPosition: d, x: n,
        }; const y = this.barHelpers.getBarEndingShape(c, v, this.series, g, u); this.series.length > 1 && g !== this.endingShapeOnSeriesNumber && (y.path = this.graphics.line(y.newX, d + a - s)), this.xArrj.push(y.newX), this.xArrjF.push(Math.abs(e - y.newX)), this.xArrjVal.push(this.series[g][u]); let w = this.graphics.move(e, d); let k = this.graphics.move(e, d); if (c.globals.previousPaths.length > 0 && (k = this.bar.getPreviousPath(f, u, !1)), w = w + this.graphics.line(y.newX, d) + y.path + this.graphics.line(e, d + a - s) + this.graphics.line(e, d), k = k + this.graphics.line(e, d) + this.graphics.line(e, d + a - s) + this.graphics.line(e, d + a - s) + this.graphics.line(e, d + a - s) + this.graphics.line(e, d), c.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && g === 0) { p >= c.config.plotOptions.bar.colors.backgroundBarColors.length && (p = 0); const A = c.config.plotOptions.bar.colors.backgroundBarColors[p]; const S = this.graphics.drawRect(0, d, c.globals.gridWidth, a, 0, A, c.config.plotOptions.bar.colors.backgroundBarOpacity); h.add(S), S.node.classList.add('apexcharts-backgroundBar'); } return {
          pathTo: w, pathFrom: k, x: n, y: o += l,
        };
      },
    }, {
      key: 'drawStackedColumnPaths',
      value(t) {
        const e = t.indexes; let i = t.x; let a = t.y; const s = t.xDivision; const r = t.barWidth; const n = t.zeroH; const o = t.strokeWidth; const l = t.elSeries; const h = this.w; const c = e.i; const d = e.j; const g = e.realIndex; let u = e.bc; if (h.globals.isXNumeric) { let f = h.globals.seriesX[c][d]; f || (f = 0), i = (f - h.globals.minX) / this.xRatio - r / 2; } for (var p, x = i, b = 0, m = 0; m < this.prevYF.length; m++)b += isNaN(this.prevYF[m][d]) ? 0 : this.prevYF[m][d]; if (c > 0 && !h.globals.isXNumeric || c > 0 && h.globals.isXNumeric && h.globals.seriesX[c - 1][d] === h.globals.seriesX[c][d]) { let v; let y; const w = Math.min(this.yRatio.length + 1, c + 1); if (void 0 !== this.prevY[c - 1]) for (let k = 1; k < w; k++) if (!isNaN(this.prevY[c - k][d])) { y = this.prevY[c - k][d]; break; } for (let A = 1; A < w; A++) { if (this.prevYVal[c - A][d] < 0) { v = this.series[c][d] >= 0 ? y - b + 2 * (this.isReversed ? b : 0) : y; break; } if (this.prevYVal[c - A][d] >= 0) { v = this.series[c][d] >= 0 ? y : y + b - 2 * (this.isReversed ? b : 0); break; } }p = this.prevYF[0].every(((t) => t === 0)) && this.prevYF.slice(1, c).every(((t) => t.every(((t) => isNaN(t))))) ? h.globals.gridHeight - n : v; } else p = h.globals.gridHeight - n; a = p - this.series[c][d] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[c][d] / this.yRatio[this.yaxisIndex] : 0); const S = {
          barWidth: r, strokeWidth: o, yRatio: this.yRatio[this.yaxisIndex], barXPosition: x, y: a,
        }; const C = this.barHelpers.getBarEndingShape(h, S, this.series, c, d); this.yArrj.push(C.newY), this.yArrjF.push(Math.abs(p - C.newY)), this.yArrjVal.push(this.series[c][d]); let L = this.graphics.move(x, p); let P = this.graphics.move(x, p); if (h.globals.previousPaths.length > 0 && (P = this.bar.getPreviousPath(g, d, !1)), L = L + this.graphics.line(x, C.newY) + C.path + this.graphics.line(x + r - o, p) + this.graphics.line(x - o / 2, p), P = P + this.graphics.line(x, p) + this.graphics.line(x + r - o, p) + this.graphics.line(x + r - o, p) + this.graphics.line(x + r - o, p) + this.graphics.line(x - o / 2, p), h.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && c === 0) { u >= h.config.plotOptions.bar.colors.backgroundBarColors.length && (u = 0); const T = h.config.plotOptions.bar.colors.backgroundBarColors[u]; const z = this.graphics.drawRect(x, 0, r, h.globals.gridHeight, 0, T, h.config.plotOptions.bar.colors.backgroundBarOpacity); l.add(z), z.node.classList.add('apexcharts-backgroundBar'); } return i += s, {
          pathTo: L, pathFrom: P, x: h.globals.isXNumeric ? i - s : i, y: a,
        };
      },
    }]), i;
  }(bt)); const vt = (function (t) {
    function i() { return e(this, i), c(this, l(i).apply(this, arguments)); } return o(i, t), a(i, [{
      key: 'draw',
      value(t, e) {
        const i = this.w; const a = new p(this.ctx); const s = new M(this.ctx); this.candlestickOptions = this.w.config.plotOptions.candlestick; const r = new I(this.ctx, i); t = r.getLogSeries(t), this.series = t, this.yRatio = r.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t); for (var n = a.group({ class: 'apexcharts-candlestick-series apexcharts-plot-series' }), o = 0; o < t.length; o++) {
          var l; var h; let c = void 0; let d = void 0; const u = []; const f = []; const x = i.globals.comboCharts ? e[o] : o; const b = a.group({
            class: 'apexcharts-series', seriesName: g.escapeString(i.globals.seriesNames[x]), rel: o + 1, 'data:realIndex': x,
          }); t[o].length > 0 && (this.visibleI += 1); var m; var v; this.yRatio.length > 1 && (this.yaxisIndex = x); const y = this.barHelpers.initialPositions(); d = y.y, m = y.barHeight, c = y.x, v = y.barWidth, l = y.xDivision, h = y.zeroH, f.push(c + v / 2); for (let w = a.group({ class: 'apexcharts-datalabels', 'data:realIndex': x }), k = 0; k < i.globals.dataPoints; k++) {
            var A; const S = this.barHelpers.getStrokeWidth(o, k, x); const C = this.drawCandleStickPaths({
              indexes: { i: o, j: k, realIndex: x }, x: c, y: d, xDivision: l, barWidth: v, zeroH: h, strokeWidth: S, elSeries: b,
            }); d = C.y, c = C.x, A = C.color, k > 0 && f.push(c + v / 2), u.push(d); const L = s.fillPath({
              seriesNumber: x, dataPointIndex: k, color: A, value: t[o][k],
            }); const P = this.candlestickOptions.wick.useFillColor ? A : void 0; this.renderSeries({
              realIndex: x, pathFill: L, lineFill: P, j: k, i: o, pathFrom: C.pathFrom, pathTo: C.pathTo, strokeWidth: S, elSeries: b, x: c, y: d, series: t, barHeight: m, barWidth: v, elDataLabelsWrap: w, visibleSeries: this.visibleI, type: 'candlestick',
            });
          }i.globals.seriesXvalues[x] = f, i.globals.seriesYvalues[x] = u, n.add(b);
        } return n;
      },
    }, {
      key: 'drawCandleStickPaths',
      value(t) {
        const e = t.indexes; let i = t.x; const a = (t.y, t.xDivision); const s = t.barWidth; const r = t.zeroH; const n = t.strokeWidth; const o = this.w; const l = new p(this.ctx); const h = e.i; const c = e.j; let d = !0; const g = o.config.plotOptions.candlestick.colors.upward; const u = o.config.plotOptions.candlestick.colors.downward; const f = this.yRatio[this.yaxisIndex]; const x = e.realIndex; const b = this.getOHLCValue(x, c); let m = r; let v = r; b.o > b.c && (d = !1); let y = Math.min(b.o, b.c); let w = Math.max(b.o, b.c); o.globals.isXNumeric && (i = (o.globals.seriesX[x][c] - o.globals.minX) / this.xRatio - s / 2); const k = i + s * this.visibleI; void 0 === this.series[h][c] || this.series[h][c] === null ? y = r : (y = r - y / f, w = r - w / f, m = r - b.h / f, v = r - b.l / f); let A = l.move(k, r); let S = l.move(k, y); return o.globals.previousPaths.length > 0 && (S = this.getPreviousPath(x, c, !0)), A = l.move(k, w) + l.line(k + s / 2, w) + l.line(k + s / 2, m) + l.line(k + s / 2, w) + l.line(k + s, w) + l.line(k + s, y) + l.line(k + s / 2, y) + l.line(k + s / 2, v) + l.line(k + s / 2, y) + l.line(k, y) + l.line(k, w - n / 2), S += l.move(k, y), o.globals.isXNumeric || (i += a), {
          pathTo: A, pathFrom: S, x: i, y: w, barXPosition: k, color: d ? g : u,
        };
      },
    }, {
      key: 'getOHLCValue',
      value(t, e) {
        const i = this.w; return {
          o: i.globals.seriesCandleO[t][e], h: i.globals.seriesCandleH[t][e], l: i.globals.seriesCandleL[t][e], c: i.globals.seriesCandleC[t][e],
        };
      },
    }]), i;
  }(bt)); const yt = (function () {
    function t(i, a) { e(this, t), this.ctx = i, this.w = i.w, this.xRatio = a.xRatio, this.yRatio = a.yRatio, this.negRange = !1, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0; } return a(t, [{
      key: 'draw',
      value(t) {
        const e = this.w; const i = new p(this.ctx); const a = i.group({ class: 'apexcharts-heatmap' }); a.attr('clip-path', 'url(#gridRectMask'.concat(e.globals.cuid, ')')); const s = e.globals.gridWidth / e.globals.dataPoints; const r = e.globals.gridHeight / e.globals.series.length; let n = 0; let o = !1; this.checkColorRange(); const l = t.slice(); e.config.yaxis[0].reversed && (o = !0, l.reverse()); for (let h = o ? 0 : l.length - 1; o ? h < l.length : h >= 0; o ? h++ : h--) {
          const c = i.group({
            class: 'apexcharts-series apexcharts-heatmap-series', seriesName: g.escapeString(e.globals.seriesNames[h]), rel: h + 1, 'data:realIndex': h,
          }); if (e.config.chart.dropShadow.enabled) { const d = e.config.chart.dropShadow; new u(this.ctx).dropShadow(c, d, h); } for (let f = 0, x = 0; x < l[h].length; x++) {
            let b = 1; const m = e.config.plotOptions.heatmap.shadeIntensity; const v = this.determineHeatColor(h, x); b = e.globals.hasNegs || this.negRange ? e.config.plotOptions.heatmap.reverseNegativeShade ? v.percent < 0 ? v.percent / 100 * (1.25 * m) : (1 - v.percent / 100) * (1.25 * m) : v.percent < 0 ? 1 - (1 + v.percent / 100) * m : (1 - v.percent / 100) * m : 1 - v.percent / 100; let y = v.color; const w = new g(); if (e.config.plotOptions.heatmap.enableShades && (y = g.hexToRgba(w.shadeColor(b, v.color), e.config.fill.opacity)), e.config.fill.type === 'image') {
 y = new M(this.ctx).fillPath({
              seriesNumber: h, dataPointIndex: x, opacity: e.globals.hasNegs ? v.percent < 0 ? 1 - (1 + v.percent / 100) : m + v.percent / 100 : v.percent / 100, patternID: g.randomId(), width: e.config.fill.image.width ? e.config.fill.image.width : s, height: e.config.fill.image.height ? e.config.fill.image.height : r,
            }); 
} const k = this.rectRadius; const A = i.drawRect(f, n, s, r, k); if (A.attr({ cx: f, cy: n }), A.node.classList.add('apexcharts-heatmap-rect'), c.add(A), A.attr({
              fill: y, i: h, index: h, j: x, val: l[h][x], 'stroke-width': this.strokeWidth, stroke: e.globals.stroke.colors[0], color: y,
            }), A.node.addEventListener('mouseenter', i.pathMouseEnter.bind(this, A)), A.node.addEventListener('mouseleave', i.pathMouseLeave.bind(this, A)), A.node.addEventListener('mousedown', i.pathMouseDown.bind(this, A)), e.config.chart.animations.enabled && !e.globals.dataChanged) { let S = 1; e.globals.resized || (S = e.config.chart.animations.speed), this.animateHeatMap(A, f, n, s, r, S); } if (e.globals.dataChanged) { let C = 1; if (this.dynamicAnim.enabled && e.globals.shouldAnimate) { C = this.dynamicAnim.speed; let L = e.globals.previousPaths[h] && e.globals.previousPaths[h][x] && e.globals.previousPaths[h][x].color; L || (L = 'rgba(255, 255, 255, 0)'), this.animateHeatColor(A, g.isColorHex(L) ? L : g.rgb2hex(L), g.isColorHex(y) ? y : g.rgb2hex(y), C); } } const P = this.calculateHeatmapDataLabels({
              x: f, y: n, i: h, j: x, series: l, rectHeight: r, rectWidth: s,
            }); P !== null && c.add(P), f += s;
          }n += r, a.add(c);
        } const T = e.globals.yAxisScale[0].result.slice(); e.config.yaxis[0].reversed ? T.unshift('') : T.push(''), e.globals.yAxisScale[0].result = T; const z = e.globals.gridHeight / e.globals.series.length; return e.config.yaxis[0].labels.offsetY = -z / 2, a;
      },
    }, { key: 'checkColorRange', value() { const t = this; const e = this.w.config.plotOptions.heatmap; e.colorScale.ranges.length > 0 && e.colorScale.ranges.map(((e, i) => { e.from < 0 && (t.negRange = !0); })); } }, { key: 'determineHeatColor', value(t, e) { const i = this.w; let a = i.globals.series[t][e]; const s = i.config.plotOptions.heatmap; const r = s.colorScale.inverse ? e : t; let n = i.globals.colors[r]; let o = Math.min.apply(Math, d(i.globals.series[t])); let l = Math.max.apply(Math, d(i.globals.series[t])); s.distributed || (o = i.globals.minY, l = i.globals.maxY), void 0 !== s.colorScale.min && (o = s.colorScale.min < i.globals.minY ? s.colorScale.min : i.globals.minY, l = s.colorScale.max > i.globals.maxY ? s.colorScale.max : i.globals.maxY); const h = Math.abs(l) + Math.abs(o); a === 0 && (a = 1e-6); let c = 100 * a / (h === 0 ? h - 1e-6 : h); s.colorScale.ranges.length > 0 && s.colorScale.ranges.map(((t, e) => { if (a >= t.from && a <= t.to) { n = t.color, o = t.from, l = t.to; const i = Math.abs(l) + Math.abs(o); c = 100 * a / (i === 0 ? i - 1e-6 : i); } })); return { color: n, percent: c }; } }, {
      key: 'calculateHeatmapDataLabels',
      value(t) {
        const e = t.x; const i = t.y; const a = t.i; const s = t.j; const r = (t.series, t.rectHeight); const n = t.rectWidth; const o = this.w; const l = o.config.dataLabels; const h = new p(this.ctx); const c = new Y(this.ctx); const d = l.formatter; let g = null; if (l.enabled) {
          g = h.group({ class: 'apexcharts-data-labels' }); const u = l.offsetX; const f = l.offsetY; const x = e + n / 2 + u; const b = i + r / 2 + parseFloat(l.style.fontSize) / 3 + f; const m = d(o.globals.series[a][s], { seriesIndex: a, dataPointIndex: s, w: o }); c.plotDataLabelsText({
            x, y: b, text: m, i: a, j: s, parent: g, dataLabelsConfig: l,
          });
        } return g;
      },
    }, {
      key: 'animateHeatMap',
      value(t, e, i, a, s, r) {
        const n = new f(this.ctx); n.animateRect(t, {
          x: e + a / 2, y: i + s / 2, width: 0, height: 0,
        }, {
          x: e, y: i, width: a, height: s,
        }, r, (() => { n.animationCompleted(t); }));
      },
    }, { key: 'animateHeatColor', value(t, e, i, a) { t.attr({ fill: e }).animate(a).attr({ fill: i }); } }]), t;
  }()); const wt = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0; const a = this.w; this.graphics = new p(this.ctx), this.lineColorArr = void 0 !== a.globals.stroke.colors ? a.globals.stroke.colors : a.globals.colors, this.defaultSize = a.globals.svgHeight < a.globals.svgWidth ? a.globals.gridHeight + 1.5 * a.globals.goldenPadding : a.globals.gridWidth, this.maxValue = this.w.globals.maxY, this.minValue = this.w.globals.minY, this.polygons = a.config.plotOptions.radar.polygons; const s = a.globals.labels.slice().sort(((t, e) => e.length - t.length))[0]; const r = this.graphics.getTextRects(s, a.config.xaxis.labels.style.fontSize); this.strokeWidth = a.config.stroke.show ? a.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - a.config.chart.dropShadow.blur, a.config.xaxis.labels.show && (this.size -= r.width / 1.75), void 0 !== a.config.plotOptions.radar.size && (this.size = a.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = []; } return a(t, [{
      key: 'draw',
      value(t) {
        const e = this; const i = this.w; const a = new M(this.ctx); const s = []; const r = new Y(this.ctx); t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen; const o = i.globals.gridWidth / 2; const l = i.globals.gridHeight / 2; const h = this.graphics.group({ class: 'apexcharts-radar-series apexcharts-plot-series', transform: 'translate('.concat(o || 0, ', ').concat(l || 0, ')') }); let c = []; let d = null; let f = null; if (this.yaxisLabels = this.graphics.group({ class: 'apexcharts-yaxis' }), t.forEach(((t, o) => {
          const l = t.length === i.globals.dataPoints; const h = e.graphics.group().attr({
            class: 'apexcharts-series', 'data:longestSeries': l, seriesName: g.escapeString(i.globals.seriesNames[o]), rel: o + 1, 'data:realIndex': o,
          }); e.dataRadiusOfPercent[o] = [], e.dataRadius[o] = [], e.angleArr[o] = [], t.forEach(((t, i) => { const a = Math.abs(e.maxValue - e.minValue); t += Math.abs(e.minValue), e.dataRadiusOfPercent[o][i] = t / a, e.dataRadius[o][i] = e.dataRadiusOfPercent[o][i] * e.size, e.angleArr[o][i] = i * e.disAngle; })), c = e.getDataPointsPos(e.dataRadius[o], e.angleArr[o]); const p = e.createPaths(c, { x: 0, y: 0 }); d = e.graphics.group({ class: 'apexcharts-series-markers-wrap apexcharts-element-hidden' }), f = e.graphics.group({ class: 'apexcharts-datalabels', 'data:realIndex': o }), i.globals.delayedElements.push({ el: d.node, index: o }); const x = {
            i: o, realIndex: o, animationDelay: o, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: 'apexcharts-radar', shouldClipToGrid: !1, bindEventsOnPaths: !1, stroke: i.globals.stroke.colors[o], strokeLineCap: i.config.stroke.lineCap,
          }; let b = null; i.globals.previousPaths.length > 0 && (b = e.getPreviousPath(o)); for (let m = 0; m < p.linePathsTo.length; m++) {
            const v = e.graphics.renderPaths(n({}, x, {
              pathFrom: b === null ? p.linePathsFrom[m] : b, pathTo: p.linePathsTo[m], strokeWidth: Array.isArray(e.strokeWidth) ? e.strokeWidth[o] : e.strokeWidth, fill: 'none', drawShadow: !1,
            })); h.add(v); const y = a.fillPath({ seriesNumber: o }); const w = e.graphics.renderPaths(n({}, x, {
              pathFrom: b === null ? p.areaPathsFrom[m] : b, pathTo: p.areaPathsTo[m], strokeWidth: 0, fill: y, drawShadow: !1,
            })); if (i.config.chart.dropShadow.enabled) { const k = new u(e.ctx); const A = i.config.chart.dropShadow; k.dropShadow(w, { ...A, noUserSpaceOnUse: !0 }, o); }h.add(w);
          }t.forEach(((t, a) => {
 const s = new X(e.ctx).getMarkerConfig('apexcharts-marker', o, a); const l = e.graphics.drawMarker(c[a].x, c[a].y, s); l.attr('rel', a), l.attr('j', a), l.attr('index', o), l.node.setAttribute('default-marker-size', s.pSize); const g = e.graphics.group({ class: 'apexcharts-series-markers' }); if (g && g.add(l), d.add(g), h.add(d), i.config.dataLabels.enabled) {
 const u = i.config.dataLabels; r.plotDataLabelsText({
            x: c[a].x, y: c[a].y, text: i.globals.series[o][a], textAnchor: 'middle', i: o, j: o, parent: f, offsetCorrection: !1, dataLabelsConfig: n({}, u), 
          }); 
}h.add(f); 
})), s.push(h);
        })), this.drawPolygons({ parent: h }), i.config.xaxis.labels.show) { const p = this.drawXAxisTexts(); h.add(p); } return h.add(this.yaxisLabels), s.forEach(((t) => { h.add(t); })), h;
      }, 
    }, { key: 'drawPolygons', value(t) { for (var e = this, i = this.w, a = t.parent, s = i.globals.yAxisScale[0].result.reverse(), r = s.length, n = [], o = this.size / (r - 1), l = 0; l < r; l++)n[l] = o * l; n.reverse(); const h = []; const c = []; n.forEach(((t, i) => { const a = e.getPolygonPos(t); let s = ''; a.forEach(((t, a) => { if (i === 0) { const r = e.graphics.drawLine(t.x, t.y, 0, 0, Array.isArray(e.polygons.connectorColors) ? e.polygons.connectorColors[a] : e.polygons.connectorColors); c.push(r); }a === 0 && e.yaxisLabelsTextsPos.push({ x: t.x, y: t.y }), s += `${t.x },${t.y } `; })), h.push(s); })), h.forEach(((t, s) => { const r = e.polygons.strokeColors; const n = e.graphics.drawPolygon(t, Array.isArray(r) ? r[s] : r, i.globals.radarPolygons.fill.colors[s]); a.add(n); })), c.forEach(((t) => { a.add(t); })), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(((t, i) => { const a = e.drawYAxisTexts(t.x, t.y, i, s[i]); e.yaxisLabels.add(a); })); } }, {
      key: 'drawYAxisTexts',
      value(t, e, i, a) {
        const s = this.w; const r = s.config.yaxis[0]; const n = s.globals.yLabelFormatters[0]; return this.graphics.drawText({
          x: t + r.labels.offsetX, y: e + r.labels.offsetY, text: n(a, i), textAnchor: 'middle', fontSize: r.labels.style.fontSize, fontFamily: r.labels.style.fontFamily, foreColor: r.labels.style.color,
        });
      },
    }, {
      key: 'drawXAxisTexts',
      value() {
        const t = this; const e = this.w; const i = e.config.xaxis.labels; const a = this.graphics.group({ class: 'apexcharts-xaxis' }); const s = this.getPolygonPos(this.size); return e.globals.labels.forEach(((r, o) => {
          const l = e.config.xaxis.labels.formatter; const h = new Y(t.ctx); if (s[o]) {
            const c = t.getTextPos(s[o], t.size); const d = l(r, { seriesIndex: -1, dataPointIndex: o, w: e }); h.plotDataLabelsText({
              x: c.newX, y: c.newY, text: d, textAnchor: c.textAnchor, i: o, j: o, parent: a, color: i.style.colors[o] ? i.style.colors[o] : '#a8a8a8', dataLabelsConfig: n({ textAnchor: c.textAnchor, dropShadow: { enabled: !1 } }, i), offsetCorrection: !1,
            });
          }
        })), a;
      }, 
    }, {
      key: 'createPaths',
      value(t, e) {
        const i = this; const a = []; let s = []; const r = []; let n = []; if (t.length) { s = [this.graphics.move(e.x, e.y)], n = [this.graphics.move(e.x, e.y)]; let o = this.graphics.move(t[0].x, t[0].y); let l = this.graphics.move(t[0].x, t[0].y); t.forEach(((e, a) => { o += i.graphics.line(e.x, e.y), l += i.graphics.line(e.x, e.y), a === t.length - 1 && (o += 'Z', l += 'Z'); })), a.push(o), r.push(l); } return {
          linePathsFrom: s, linePathsTo: a, areaPathsFrom: n, areaPathsTo: r,
        };
      },
    }, { key: 'getTextPos', value(t, e) { let i = 'middle'; let a = t.x; let s = t.y; return Math.abs(t.x) >= 10 ? t.x > 0 ? (i = 'start', a += 10) : t.x < 0 && (i = 'end', a -= 10) : i = 'middle', Math.abs(t.y) >= e - 10 && (t.y < 0 ? s -= 10 : t.y > 0 && (s += 10)), { textAnchor: i, newX: a, newY: s }; } }, { key: 'getPreviousPath', value(t) { for (var e = this.w, i = null, a = 0; a < e.globals.previousPaths.length; a++) { const s = e.globals.previousPaths[a]; s.paths.length > 0 && parseInt(s.realIndex, 10) === parseInt(t, 10) && void 0 !== e.globals.previousPaths[a].paths[0] && (i = e.globals.previousPaths[a].paths[0].d); } return i; } }, { key: 'getDataPointsPos', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen; t = t || [], e = e || []; for (var a = [], s = 0; s < i; s++) { const r = {}; r.x = t[s] * Math.sin(e[s]), r.y = -t[s] * Math.cos(e[s]), a.push(r); } return a; } }, { key: 'getPolygonPos', value(t) { for (var e = [], i = 2 * Math.PI / this.dataPointsLen, a = 0; a < this.dataPointsLen; a++) { const s = {}; s.x = t * Math.sin(a * i), s.y = -t * Math.cos(a * i), e.push(s); } return e; } }]), t;
  }()); const kt = (function (t) {
    function i(t) { let a; e(this, i), (a = c(this, l(i).call(this, t))).ctx = t, a.w = t.w, a.animBeginArr = [0], a.animDur = 0; const s = a.w; return a.startAngle = s.config.plotOptions.radialBar.startAngle, a.endAngle = s.config.plotOptions.radialBar.endAngle, a.totalAngle = Math.abs(s.config.plotOptions.radialBar.endAngle - s.config.plotOptions.radialBar.startAngle), a.trackStartAngle = s.config.plotOptions.radialBar.track.startAngle, a.trackEndAngle = s.config.plotOptions.radialBar.track.endAngle, a.radialDataLabels = s.config.plotOptions.radialBar.dataLabels, a.trackStartAngle || (a.trackStartAngle = a.startAngle), a.trackEndAngle || (a.trackEndAngle = a.endAngle), a.endAngle === 360 && (a.endAngle = 359.99), a.fullAngle = 360 - s.config.plotOptions.radialBar.endAngle - s.config.plotOptions.radialBar.startAngle, a.margin = parseInt(s.config.plotOptions.radialBar.track.margin, 10), a; } return o(i, t), a(i, [{
      key: 'draw',
      value(t) {
        const e = this.w; const i = new p(this.ctx); const a = i.group({ class: 'apexcharts-radialbar' }); if (e.globals.noData) return a; const s = i.group(); const r = this.defaultSize / 2; const n = e.globals.gridWidth / 2; let o = this.defaultSize / 2.05; e.config.chart.sparkline.enabled || (o = o - e.config.stroke.width - e.config.chart.dropShadow.blur); const l = e.globals.fill.colors; if (e.config.plotOptions.radialBar.track.show) {
          const h = this.drawTracks({
            size: o, centerX: n, centerY: r, colorArr: l, series: t,
          }); s.add(h);
        } const c = this.drawArcs({
          size: o, centerX: n, centerY: r, colorArr: l, series: t,
        }); let d = 360; e.config.plotOptions.radialBar.startAngle < 0 && (d = this.totalAngle); const g = (360 - d) / 360; if (e.globals.radialSize = o - o * g, this.radialDataLabels.value.show) { const u = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY); e.globals.radialSize += u * g; } return s.add(c.g), e.config.plotOptions.radialBar.hollow.position === 'front' && (c.g.add(c.elHollow), c.dataLabels && c.g.add(c.dataLabels)), a.add(s), a;
      },
    }, {
      key: 'drawTracks',
      value(t) {
        const e = this.w; const i = new p(this.ctx); const a = i.group({ class: 'apexcharts-tracks' }); const s = new u(this.ctx); const r = new M(this.ctx); const n = this.getStrokeWidth(t); t.size -= n / 2; for (let o = 0; o < t.series.length; o++) {
          const l = i.group({ class: 'apexcharts-radialbar-track apexcharts-track' }); a.add(l), l.attr({ rel: o + 1 }), t.size = t.size - n - this.margin; const h = e.config.plotOptions.radialBar.track; const c = r.fillPath({
            seriesNumber: 0, size: t.size, fillColors: Array.isArray(h.background) ? h.background[o] : h.background, solid: !0,
          }); const d = this.trackStartAngle; let g = this.trackEndAngle; Math.abs(g) + Math.abs(d) >= 360 && (g = 360 - Math.abs(this.startAngle) - 0.1); const f = i.drawPath({
            d: '', stroke: c, strokeWidth: n * parseInt(h.strokeWidth, 10) / 100, fill: 'none', strokeOpacity: h.opacity, classes: 'apexcharts-radialbar-area',
          }); if (h.dropShadow.enabled) { const x = h.dropShadow; s.dropShadow(f, x); }l.add(f), f.attr('id', `apexcharts-radialbarTrack-${o}`), this.animatePaths(f, {
            centerX: t.centerX, centerY: t.centerY, endAngle: g, startAngle: d, size: t.size, i: o, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: !0, easing: e.globals.easing,
          });
        } return a;
      },
    }, {
      key: 'drawArcs',
      value(t) {
        const e = this.w; const i = new p(this.ctx); const a = new M(this.ctx); const s = new u(this.ctx); const r = i.group(); const n = this.getStrokeWidth(t); t.size -= n / 2; let o = e.config.plotOptions.radialBar.hollow.background; const l = t.size - n * t.series.length - this.margin * t.series.length - n * parseInt(e.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2; const h = l - e.config.plotOptions.radialBar.hollow.margin; void 0 !== e.config.plotOptions.radialBar.hollow.image && (o = this.drawHollowImage(t, r, l, o)); const c = this.drawHollow({
          size: h, centerX: t.centerX, centerY: t.centerY, fill: o || 'transparent',
        }); if (e.config.plotOptions.radialBar.hollow.dropShadow.enabled) { const d = e.config.plotOptions.radialBar.hollow.dropShadow; s.dropShadow(c, d); } let f = 1; !this.radialDataLabels.total.show && e.globals.series.length > 1 && (f = 0); let x = null; this.radialDataLabels.show && (x = this.renderInnerDataLabels(this.radialDataLabels, {
          hollowSize: l, centerX: t.centerX, centerY: t.centerY, opacity: f,
        })), e.config.plotOptions.radialBar.hollow.position === 'back' && (r.add(c), x && r.add(x)); let b = !1; e.config.plotOptions.radialBar.inverseOrder && (b = !0); for (let m = b ? t.series.length - 1 : 0; b ? m >= 0 : m < t.series.length; b ? m-- : m++) {
          const v = i.group({ class: 'apexcharts-series apexcharts-radial-series', seriesName: g.escapeString(e.globals.seriesNames[m]) }); r.add(v), v.attr({ rel: m + 1, 'data:realIndex': m }), this.ctx.series.addCollapsedClassToSeries(v, m), t.size = t.size - n - this.margin; const y = a.fillPath({ seriesNumber: m, size: t.size, value: t.series[m] }); const w = this.startAngle; let k = void 0; const A = g.negToZero(t.series[m] > 100 ? 100 : t.series[m]) / 100; let S = Math.round(this.totalAngle * A) + this.startAngle; let C = void 0; e.globals.dataChanged && (k = this.startAngle, C = Math.round(this.totalAngle * g.negToZero(e.globals.previousPaths[m]) / 100) + k), Math.abs(S) + Math.abs(w) >= 360 && (S -= 0.01), Math.abs(C) + Math.abs(k) >= 360 && (C -= 0.01); const L = S - w; const P = Array.isArray(e.config.stroke.dashArray) ? e.config.stroke.dashArray[m] : e.config.stroke.dashArray; const T = i.drawPath({
            d: '', stroke: y, strokeWidth: n, fill: 'none', fillOpacity: e.config.fill.opacity, classes: `apexcharts-radialbar-area apexcharts-radialbar-slice-${m}`, strokeDashArray: P,
          }); if (p.setAttrs(T.node, { 'data:angle': L, 'data:value': t.series[m] }), e.config.chart.dropShadow.enabled) { const z = e.config.chart.dropShadow; s.dropShadow(T, z, m); } this.addListeners(T, this.radialDataLabels), v.add(T), T.attr({ index: 0, j: m }); let I = 0; !this.initialAnim || e.globals.resized || e.globals.dataChanged || (I = (S - w) / 360 * e.config.chart.animations.speed, this.animDur = I / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), e.globals.dataChanged && (I = (S - w) / 360 * e.config.chart.animations.dynamicAnimation.speed, this.animDur = I / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), this.animatePaths(T, {
            centerX: t.centerX, centerY: t.centerY, endAngle: S, startAngle: w, prevEndAngle: C, prevStartAngle: k, size: t.size, i: m, totalItems: 2, animBeginArr: this.animBeginArr, dur: I, shouldSetPrevPaths: !0, easing: e.globals.easing,
          });
        } return { g: r, elHollow: c, dataLabels: x };
      },
    }, {
      key: 'drawHollow',
      value(t) {
        const e = new p(this.ctx).drawCircle(2 * t.size); return e.attr({
          class: 'apexcharts-radialbar-hollow', cx: t.centerX, cy: t.centerY, r: t.size, fill: t.fill,
        }), e;
      },
    }, {
      key: 'drawHollowImage',
      value(t, e, i, a) {
        const s = this.w; const r = new M(this.ctx); const n = g.randomId(); const o = s.config.plotOptions.radialBar.hollow.image; if (s.config.plotOptions.radialBar.hollow.imageClipped) {
 r.clippedImgArea({
          width: i, height: i, image: o, patternID: 'pattern'.concat(s.globals.cuid).concat(n),
        }), a = 'url(#pattern'.concat(s.globals.cuid).concat(n, ')'); 
} else { const l = s.config.plotOptions.radialBar.hollow.imageWidth; const h = s.config.plotOptions.radialBar.hollow.imageHeight; if (void 0 === l && void 0 === h) { const c = s.globals.dom.Paper.image(o).loaded((function (e) { this.move(t.centerX - e.width / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - e.height / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY); })); e.add(c); } else { const d = s.globals.dom.Paper.image(o).loaded((function (e) { this.move(t.centerX - l / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - h / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l, h); })); e.add(d); } } return a;
      },
    }, { key: 'getStrokeWidth', value(t) { const e = this.w; return t.size * (100 - parseInt(e.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t.series.length + 1) - this.margin; } }]), i;
  }(at)); const At = (function (t) {
    function i() { return e(this, i), c(this, l(i).apply(this, arguments)); } return o(i, t), a(i, [{
      key: 'draw',
      value(t, e) {
        const i = this.w; const a = new p(this.ctx); this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.barHelpers.initVariables(t); for (var s = a.group({ class: 'apexcharts-rangebar-series apexcharts-plot-series' }), r = 0; r < t.length; r++) {
          var o; var l; var h; let c = void 0; let d = void 0; let u = void 0; const f = i.globals.comboCharts ? e[r] : r; const x = a.group({
            class: 'apexcharts-series', seriesName: g.escapeString(i.globals.seriesNames[f]), rel: r + 1, 'data:realIndex': f,
          }); t[r].length > 0 && (this.visibleI += 1); let b = 0; let m = 0; this.yRatio.length > 1 && (this.yaxisIndex = f); const v = this.barHelpers.initialPositions(); d = v.y, h = v.zeroW, c = v.x, m = v.barWidth, o = v.xDivision, l = v.zeroH; for (let y = a.group({ class: 'apexcharts-datalabels', 'data:realIndex': f }), w = 0; w < i.globals.dataPoints; w++) {
            const k = this.barHelpers.getStrokeWidth(r, w, f); const A = this.seriesRangeStart[r][w]; const S = this.seriesRangeEnd[r][w]; let C = null; let L = null; const P = {
              x: c, y: d, strokeWidth: k, elSeries: x,
            }; if (u = v.yDivision, b = v.barHeight, this.isHorizontal) {
              L = d + b * this.visibleI; const T = (u - b * this.seriesLen) / 2; if (void 0 === i.config.series[r].data[w]) break; if (this.isTimelineBar && i.config.series[r].data[w].x) {
                const z = this.detectOverlappingBars({
                  i: r, j: w, barYPosition: L, srty: T, barHeight: b, yDivision: u, initPositions: v,
                }); b = z.barHeight, L = z.barYPosition;
              }m = (C = this.drawRangeBarPaths(n({
                indexes: { i: r, j: w, realIndex: f }, barHeight: b, barYPosition: L, zeroW: h, yDivision: u, y1: A, y2: S,
              }, P))).barWidth;
            } else {
 b = (C = this.drawRangeColumnPaths(n({
              indexes: { i: r, j: w, realIndex: f }, zeroH: l, barWidth: m, xDivision: o,
            }, P))).barHeight; 
} d = C.y, c = C.x; const I = this.barHelpers.getPathFillColor(t, r, w, f); const M = i.globals.stroke.colors[f]; this.renderSeries({
              realIndex: f, pathFill: I, lineFill: M, j: w, i: r, x: c, y: d, y1: A, y2: S, pathFrom: C.pathFrom, pathTo: C.pathTo, strokeWidth: k, elSeries: x, series: t, barHeight: b, barYPosition: L, barWidth: m, elDataLabelsWrap: y, visibleSeries: this.visibleI, type: 'rangebar',
            });
          }s.add(x);
        } return s;
      },
    }, { key: 'detectOverlappingBars', value(t) { const e = t.i; const i = t.j; let a = t.barYPosition; const s = t.srty; let r = t.barHeight; const n = t.yDivision; const o = t.initPositions; const l = this.w; let h = []; const c = l.config.series[e].data[i].rangeName; const d = l.config.series[e].data[i].x; const g = l.globals.labels.indexOf(d); const u = l.globals.seriesRangeBarTimeline[e].findIndex(((t) => t.x === d && t.overlaps.length > 0)); return a = s + r * this.visibleI + n * g, u > -1 && (h = l.globals.seriesRangeBarTimeline[e][u].overlaps).indexOf(c) > -1 && (a = (r = o.barHeight / h.length) * this.visibleI + n * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + r * (this.visibleI + h.indexOf(c)) + n * g), { barYPosition: a, barHeight: r }; } }, {
      key: 'drawRangeColumnPaths',
      value(t) {
        const e = t.indexes; let i = t.x; const a = t.strokeWidth; const s = t.xDivision; const r = t.barWidth; const n = t.zeroH; const o = this.w; const l = new p(this.ctx); const h = e.i; const c = e.j; const d = this.yRatio[this.yaxisIndex]; const g = e.realIndex; const u = this.getRangeValue(g, c); let f = Math.min(u.start, u.end); let x = Math.max(u.start, u.end); o.globals.isXNumeric && (i = (o.globals.seriesX[h][c] - o.globals.minX) / this.xRatio - r / 2); const b = i + r * this.visibleI; void 0 === this.series[h][c] || this.series[h][c] === null ? f = n : (f = n - f / d, x = n - x / d); const m = Math.abs(x - f); let v = l.move(b, n); let y = l.move(b, f); return o.globals.previousPaths.length > 0 && (y = this.getPreviousPath(g, c, !0)), v = l.move(b, x) + l.line(b + r, x) + l.line(b + r, f) + l.line(b, f) + l.line(b, x - a / 2), y = y + l.move(b, f) + l.line(b + r, f) + l.line(b + r, f) + l.line(b, f), o.globals.isXNumeric || (i += s), {
          pathTo: v, pathFrom: y, barHeight: m, x: i, y: x, barXPosition: b,
        };
      },
    }, {
      key: 'drawRangeBarPaths',
      value(t) {
        const e = t.indexes; let i = t.y; const a = t.y1; const s = t.y2; const r = t.yDivision; const n = t.barHeight; const o = t.barYPosition; const l = t.zeroW; const h = this.w; const c = new p(this.ctx); const d = l + a / this.invertedYRatio; const g = l + s / this.invertedYRatio; let u = c.move(l, o); let f = c.move(d, o); h.globals.previousPaths.length > 0 && (f = this.getPreviousPath(e.realIndex, e.j)); const x = Math.abs(g - d); return u = c.move(d, o) + c.line(g, o) + c.line(g, o + n) + c.line(d, o + n) + c.line(d, o), f = f + c.line(d, o) + c.line(d, o + n) + c.line(d, o + n) + c.line(d, o), h.globals.isXNumeric || (i += r), {
          pathTo: u, pathFrom: f, barWidth: x, x: g, y: i,
        };
      },
    }, { key: 'getRangeValue', value(t, e) { const i = this.w; return { start: i.globals.seriesRangeStart[t][e], end: i.globals.seriesRangeEnd[t][e] }; } }]), i;
  }(bt)); const St = (function () { function t(i) { e(this, t), this.w = i.w, this.lineCtx = i; } return a(t, [{ key: 'sameValueSeriesFix', value(t, e) { const i = this.w; if (i.config.chart.type === 'line' && (i.config.fill.type === 'gradient' || i.config.fill.type[t] === 'gradient') && new I(this.lineCtx.ctx, i).seriesHaveSameValues(t)) { const a = e[t].slice(); a[a.length - 1] = a[a.length - 1] + 1e-6, e[t] = a; } return e; } }, { key: 'calculatePoints', value(t) { const e = t.series; const i = t.realIndex; const a = t.x; const s = t.y; const r = t.i; const n = t.j; const o = t.prevY; const l = this.w; const h = []; const c = []; if (n === 0) { let d = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX; l.globals.isXNumeric && (d = (l.globals.seriesX[i][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX), h.push(d), c.push(g.isNumber(e[r][0]) ? o + l.config.markers.offsetY : null), h.push(a + l.config.markers.offsetX), c.push(g.isNumber(e[r][n + 1]) ? s + l.config.markers.offsetY : null); } else h.push(a + l.config.markers.offsetX), c.push(g.isNumber(e[r][n + 1]) ? s + l.config.markers.offsetY : null); return { x: h, y: c }; } }, { key: 'checkPreviousPaths', value(t) { for (var e = t.pathFromLine, i = t.pathFromArea, a = t.realIndex, s = this.w, r = 0; r < s.globals.previousPaths.length; r++) { const n = s.globals.previousPaths[r]; (n.type === 'line' || n.type === 'area') && n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(a, 10) && (n.type === 'line' ? (this.lineCtx.appendPathFrom = !1, e = s.globals.previousPaths[r].paths[0].d) : n.type === 'area' && (this.lineCtx.appendPathFrom = !1, i = s.globals.previousPaths[r].paths[0].d, s.config.stroke.show && s.globals.previousPaths[r].paths[1] && (e = s.globals.previousPaths[r].paths[1].d))); } return { pathFromLine: e, pathFromArea: i }; } }, { key: 'determineFirstPrevY', value(t) { const e = t.i; const i = t.series; let a = t.prevY; let s = t.lineYPosition; const r = this.w; if (void 0 !== i[e][0])a = (s = r.config.chart.stacked && e > 0 ? this.lineCtx.prevSeriesY[e - 1][0] : this.lineCtx.zeroY) - i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0); else if (r.config.chart.stacked && e > 0 && void 0 === i[e][0]) for (let n = e - 1; n >= 0; n--) if (i[n][0] !== null && void 0 !== i[n][0]) { a = s = this.lineCtx.prevSeriesY[n][0]; break; } return { prevY: a, lineYPosition: s }; } }]), t; }()); const Ct = (function () {
    function t(i, a, s) { e(this, t), this.ctx = i, this.w = i.w, this.xyRatios = a, this.pointsChart = !(this.w.config.chart.type !== 'bubble' && this.w.config.chart.type !== 'scatter') || s, this.scatter = new E(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new St(this), this.markers = new X(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0; } return a(t, [{
      key: 'draw',
      value(t, e, i) {
        const a = this.w; const s = new p(this.ctx); const r = a.globals.comboCharts ? e : a.config.chart.type; const n = s.group({ class: 'apexcharts-'.concat(r, '-series apexcharts-plot-series') }); const o = new I(this.ctx, a); this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = o.getLogSeries(t), this.yRatio = o.getLogYRatios(this.yRatio); for (var l = [], h = 0; h < t.length; h++) {
          t = this.lineHelpers.sameValueSeriesFix(h, t); const c = a.globals.comboCharts ? i[h] : h; this._initSerieVariables(t, h, c); const d = []; const g = []; let u = a.globals.padHorizontal + this.categoryAxisCorrection; this.ctx.series.addCollapsedClassToSeries(this.elSeries, c), a.globals.isXNumeric && a.globals.seriesX.length > 0 && (u = (a.globals.seriesX[c][0] - a.globals.minX) / this.xRatio), g.push(u); var f; const x = u; const b = x; let m = this.zeroY; m = this.lineHelpers.determineFirstPrevY({
            i: h, series: t, prevY: m, lineYPosition: 0,
          }).prevY, d.push(m), f = m; const v = this._calculatePathsFrom({
            series: t, i: h, realIndex: c, prevX: b, prevY: m,
          }); const y = this._iterateOverDataPoints({
            series: t, realIndex: c, i: h, x: u, y: 1, pX: x, pY: f, pathsFrom: v, linePaths: [], areaPaths: [], seriesIndex: i, lineYPosition: 0, xArrj: g, yArrj: d,
          }); this._handlePaths({
            type: r, realIndex: c, i: h, paths: y,
          }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l.push(this.elSeries);
        } for (let w = l.length; w > 0; w--)n.add(l[w - 1]); return n;
      },
    }, { key: '_initSerieVariables', value(t, e, i) { const a = this.w; const s = new p(this.ctx); this.xDivision = a.globals.gridWidth / (a.globals.dataPoints - (a.config.xaxis.tickPlacement === 'on' ? 1 : 0)), this.strokeWidth = Array.isArray(a.config.stroke.width) ? a.config.stroke.width[i] : a.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = a.config.yaxis[this.yaxisIndex] && a.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, this.zeroY > a.globals.gridHeight && (this.areaBottomY = a.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s.group({ class: 'apexcharts-series', seriesName: g.escapeString(a.globals.seriesNames[i]) }), this.elPointsMain = s.group({ class: 'apexcharts-series-markers-wrap' }), this.elDataLabelsWrap = s.group({ class: 'apexcharts-datalabels', 'data:realIndex': i }); const r = t[e].length === a.globals.dataPoints; this.elSeries.attr({ 'data:longestSeries': r, rel: e + 1, 'data:realIndex': i }), this.appendPathFrom = !0; } }, {
      key: '_calculatePathsFrom',
      value(t) {
        let e; let i; let a; let s; const r = t.series; const n = t.i; const o = t.realIndex; let l = t.prevX; let h = t.prevY; const c = this.w; const d = new p(this.ctx); if (r[n][0] === null) { for (let g = 0; g < r[n].length; g++) if (r[n][g] !== null) { l = this.xDivision * g, h = this.zeroY - r[n][g] / this.yRatio[this.yaxisIndex], e = d.move(l, h), i = d.move(l, this.areaBottomY); break; } } else e = d.move(l, h), i = d.move(l, this.areaBottomY) + d.line(l, h); if (a = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), s = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), c.globals.previousPaths.length > 0) { const u = this.lineHelpers.checkPreviousPaths({ pathFromLine: a, pathFromArea: s, realIndex: o }); a = u.pathFromLine, s = u.pathFromArea; } return {
          prevX: l, prevY: h, linePath: e, areaPath: i, pathFromLine: a, pathFromArea: s,
        };
      },
    }, {
      key: '_handlePaths',
      value(t) {
        const e = t.type; const i = t.realIndex; const a = t.i; const s = t.paths; const r = this.w; const o = new p(this.ctx); const l = new M(this.ctx); this.prevSeriesY.push(s.yArrj), r.globals.seriesXvalues[i] = s.xArrj, r.globals.seriesYvalues[i] = s.yArrj, this.pointsChart || r.globals.delayedElements.push({ el: this.elPointsMain.node, index: i }); const h = {
          i: a, realIndex: i, animationDelay: a, initialSpeed: r.config.chart.animations.speed, dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed, className: 'apexcharts-'.concat(e),
        }; if (e === 'area') {
 for (let c = l.fillPath({ seriesNumber: i }), d = 0; d < s.areaPaths.length; d++) {
          const g = o.renderPaths(n({}, h, {
            pathFrom: s.pathFromArea, pathTo: s.areaPaths[d], stroke: 'none', strokeWidth: 0, strokeLineCap: null, fill: c,
          })); this.elSeries.add(g);
        } 
} if (r.config.stroke.show && !this.pointsChart) {
          let u = null; u = e === 'line' ? l.fillPath({ seriesNumber: i, i: a }) : r.globals.stroke.colors[i]; for (let f = 0; f < s.linePaths.length; f++) {
            const x = o.renderPaths(n({}, h, {
              pathFrom: s.pathFromLine, pathTo: s.linePaths[f], stroke: u, strokeWidth: this.strokeWidth, strokeLineCap: r.config.stroke.lineCap, fill: 'none',
            })); this.elSeries.add(x);
          }
        }
      },
    }, {
      key: '_iterateOverDataPoints',
      value(t) {
        for (var e = t.series, i = t.realIndex, a = t.i, s = t.x, r = t.y, n = t.pX, o = t.pY, l = t.pathsFrom, h = t.linePaths, c = t.areaPaths, d = t.seriesIndex, u = t.lineYPosition, f = t.xArrj, x = t.yArrj, b = this.w, m = new p(this.ctx), v = this.yRatio, y = l.prevY, w = l.linePath, k = l.areaPath, A = l.pathFromLine, S = l.pathFromArea, C = g.isNumber(b.globals.minYArr[i]) ? b.globals.minYArr[i] : b.globals.minY, L = b.globals.dataPoints > 1 ? b.globals.dataPoints - 1 : b.globals.dataPoints, P = 0; P < L; P++) {
          const T = void 0 === e[a][P + 1] || e[a][P + 1] === null; if (b.globals.isXNumeric) { let z = b.globals.seriesX[i][P + 1]; void 0 === b.globals.seriesX[i][P + 1] && (z = b.globals.seriesX[i][L - 1]), s = (z - b.globals.minX) / this.xRatio; } else s += this.xDivision; u = b.config.chart.stacked && a > 0 && b.globals.collapsedSeries.length < b.config.series.length - 1 ? this.prevSeriesY[a - 1][P + 1] : this.zeroY, r = T ? u - C / v[this.yaxisIndex] + 2 * (this.isReversed ? C / v[this.yaxisIndex] : 0) : u - e[a][P + 1] / v[this.yaxisIndex] + 2 * (this.isReversed ? e[a][P + 1] / v[this.yaxisIndex] : 0), f.push(s), x.push(r); const I = this.lineHelpers.calculatePoints({
            series: e, x: s, y: r, realIndex: i, i: a, j: P, prevY: y,
          }); const M = this._createPaths({
            series: e, i: a, realIndex: i, j: P, x: s, y: r, pX: n, pY: o, linePath: w, areaPath: k, linePaths: h, areaPaths: c, seriesIndex: d,
          }); c = M.areaPaths, h = M.linePaths, n = M.pX, o = M.pY, k = M.areaPath, w = M.linePath, this.appendPathFrom && (A += m.line(s, this.zeroY), S += m.line(s, this.zeroY)), this.handleNullDataPoints(e, I, a, P, i), this._handleMarkersAndLabels({
            pointsPos: I, series: e, x: s, y: r, prevY: y, i: a, j: P, realIndex: i,
          });
        } return {
          yArrj: x, xArrj: f, pathFromArea: S, areaPaths: c, pathFromLine: A, linePaths: h,
        };
      },
    }, {
      key: '_handleMarkersAndLabels',
      value(t) {
        const e = t.pointsPos; const i = (t.series, t.x, t.y, t.prevY, t.i); const a = t.j; const s = t.realIndex; const r = this.w; const n = new Y(this.ctx); if (this.pointsChart) {
 this.scatter.draw(this.elSeries, a, {
          realIndex: s, pointsPos: e, zRatio: this.zRatio, elParent: this.elPointsMain,
        }); 
} else { r.globals.series[i].length > 1 && this.elPointsMain.node.classList.add('apexcharts-element-hidden'); const o = this.markers.plotChartMarkers(e, s, a + 1); o !== null && this.elPointsMain.add(o); } const l = n.drawDataLabel(e, s, a + 1, null, this.strokeWidth); l !== null && this.elDataLabelsWrap.add(l);
      },
    }, {
      key: '_createPaths',
      value(t) {
        const e = t.series; const { i } = t; const a = t.realIndex; const s = t.j; const r = t.x; const n = t.y; let o = t.pX; let l = t.pY; let h = t.linePath; let c = t.areaPath; const d = t.linePaths; const g = t.areaPaths; const u = t.seriesIndex; const f = this.w; const x = new p(this.ctx); let b = f.config.stroke.curve; const m = this.areaBottomY; if (Array.isArray(f.config.stroke.curve) && (b = Array.isArray(u) ? f.config.stroke.curve[u[i]] : f.config.stroke.curve[i]), b === 'smooth') { const v = 0.35 * (r - o); f.globals.hasNullValues ? (e[i][s] !== null && (e[i][s + 1] !== null ? (h = x.move(o, l) + x.curve(o + v, l, r - v, n, r + 1, n), c = `${x.move(o + 1, l) + x.curve(o + v, l, r - v, n, r + 1, n) + x.line(r, m) + x.line(o, m)}z`) : (h = x.move(o, l), c = `${x.move(o, l)}z`)), d.push(h), g.push(c)) : (h += x.curve(o + v, l, r - v, n, r, n), c += x.curve(o + v, l, r - v, n, r, n)), o = r, l = n, s === e[i].length - 2 && (c = `${c + x.curve(o, l, r, n, r, m) + x.move(r, n)}z`, f.globals.hasNullValues || (d.push(h), g.push(c))); } else { if (e[i][s + 1] === null) { h += x.move(r, n); const y = f.globals.isXNumeric ? (f.globals.seriesX[a][s] - f.globals.minX) / this.xRatio : r - this.xDivision; c = `${c + x.line(y, m) + x.move(r, n)}z`; }e[i][s] === null && (h += x.move(r, n), c += x.move(r, m)), b === 'stepline' ? (h = h + x.line(r, null, 'H') + x.line(null, n, 'V'), c = c + x.line(r, null, 'H') + x.line(null, n, 'V')) : b === 'straight' && (h += x.line(r, n), c += x.line(r, n)), s === e[i].length - 2 && (c = `${c + x.line(r, m) + x.move(r, n)}z`, d.push(h), g.push(c)); } return {
          linePaths: d, areaPaths: g, pX: o, pY: l, linePath: h, areaPath: c,
        };
      },
    }, { key: 'handleNullDataPoints', value(t, e, i, a, s) { const r = this.w; if (t[i][a] === null && r.config.markers.showNullDataPoints) { const n = this.markers.plotChartMarkers(e, s, a + 1, this.strokeWidth - r.config.markers.strokeWidth / 2, !0); n !== null && this.elPointsMain.add(n); } } }]), t;
  }()); const Lt = (function () {
    function t(i) { e(this, t), this.ctx = i, this.w = i.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC; } return a(t, [{
      key: 'calculateTimeScaleTicks',
      value(t, e) {
        const i = this; const a = this.w; if (a.globals.allSeriesCollapsed) return a.globals.labels = [], a.globals.timescaleLabels = [], []; const s = new C(this.ctx); const r = (e - t) / 864e5; this.determineInterval(r), a.globals.disableZoomIn = !1, a.globals.disableZoomOut = !1, r < 0.005 ? a.globals.disableZoomIn = !0 : r > 5e4 && (a.globals.disableZoomOut = !0); const o = s.getTimeUnitsfromTimestamp(t, e, this.utc); const l = a.globals.gridWidth / r; const h = l / 24; const c = h / 60; const d = Math.floor(24 * r); const g = Math.floor(24 * r * 60); const u = Math.floor(r); const f = Math.floor(r / 30); const p = Math.floor(r / 365); const x = {
          minMinute: o.minMinute, minHour: o.minHour, minDate: o.minDate, minMonth: o.minMonth, minYear: o.minYear,
        }; const b = {
          firstVal: x, currentMinute: x.minMinute, currentHour: x.minHour, currentMonthDate: x.minDate, currentDate: x.minDate, currentMonth: x.minMonth, currentYear: x.minYear, daysWidthOnXAxis: l, hoursWidthOnXAxis: h, minutesWidthOnXAxis: c, numberOfMinutes: g, numberOfHours: d, numberOfDays: u, numberOfMonths: f, numberOfYears: p,
        }; switch (this.tickInterval) { case 'years': this.generateYearScale(b); break; case 'months': case 'half_year': this.generateMonthScale(b); break; case 'months_days': case 'months_fortnight': case 'days': case 'week_days': this.generateDayScale(b); break; case 'hours': this.generateHourScale(b); break; case 'minutes': this.generateMinuteScale(b); } const m = this.timeScaleArray.map(((t) => {
          const e = {
            position: t.position, unit: t.unit, year: t.year, day: t.day ? t.day : 1, hour: t.hour ? t.hour : 0, month: t.month + 1,
          }; return t.unit === 'month' ? n({}, e, { day: 1, value: t.value + 1 }) : t.unit === 'day' || t.unit === 'hour' ? n({}, e, { value: t.value }) : t.unit === 'minute' ? n({}, e, { value: t.value, minute: t.value }) : t;
        })); return m.filter(((t) => { let e = 1; let s = Math.ceil(a.globals.gridWidth / 120); const r = t.value; void 0 !== a.config.xaxis.tickAmount && (s = a.config.xaxis.tickAmount), m.length > s && (e = Math.floor(m.length / s)); let n = !1; let o = !1; switch (i.tickInterval) { case 'half_year': e = 7, t.unit === 'year' && (n = !0); break; case 'months': e = 1, t.unit === 'year' && (n = !0); break; case 'months_fortnight': e = 15, t.unit !== 'year' && t.unit !== 'month' || (n = !0), r === 30 && (o = !0); break; case 'months_days': e = 10, t.unit === 'month' && (n = !0), r === 30 && (o = !0); break; case 'week_days': e = 8, t.unit === 'month' && (n = !0); break; case 'days': e = 1, t.unit === 'month' && (n = !0); break; case 'hours': t.unit === 'day' && (n = !0); break; case 'minutes': r % 5 != 0 && (o = !0); } if (i.tickInterval === 'minutes' || i.tickInterval === 'hours') { if (!o) return !0; } else if ((r % e == 0 || n) && !o) return !0; }));
      },
    }, { key: 'recalcDimensionsBasedOnFormat', value(t, e) { const i = this.w; const a = this.formatDates(t); const s = this.removeOverlappingTS(a); i.globals.timescaleLabels = s.slice(), new it(this.ctx).plotCoords(); } }, { key: 'determineInterval', value(t) { switch (!0) { case t > 1825: this.tickInterval = 'years'; break; case t > 800 && t <= 1825: this.tickInterval = 'half_year'; break; case t > 180 && t <= 800: this.tickInterval = 'months'; break; case t > 90 && t <= 180: this.tickInterval = 'months_fortnight'; break; case t > 60 && t <= 90: this.tickInterval = 'months_days'; break; case t > 30 && t <= 60: this.tickInterval = 'week_days'; break; case t > 2 && t <= 30: this.tickInterval = 'days'; break; case t > 0.1 && t <= 2: this.tickInterval = 'hours'; break; case t < 0.1: this.tickInterval = 'minutes'; break; default: this.tickInterval = 'days'; } } }, {
      key: 'generateYearScale',
      value(t) {
        const e = t.firstVal; const i = t.currentMonth; const a = t.currentYear; const s = t.daysWidthOnXAxis; const r = t.numberOfYears; let n = e.minYear; let o = 0; const l = new C(this.ctx); if (e.minDate > 1 && e.minMonth > 0) {
          const h = l.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate); o = (l.determineDaysOfYear(e.minYear) - h + 1) * s, n = e.minYear + 1, this.timeScaleArray.push({
            position: o, value: n, unit: 'year', year: n, month: g.monthMod(i + 1),
          });
        } else {
 e.minDate === 1 && e.minMonth === 0 && this.timeScaleArray.push({
          position: o, value: n, unit: 'year', year: a, month: g.monthMod(i + 1),
        }); 
} for (let c = n, d = o, u = 0; u < r; u++) {
 c++, d = l.determineDaysOfYear(c - 1) * s + d, this.timeScaleArray.push({
          position: d, value: c, unit: 'year', year: c, month: 1,
        }); 
}
      },
    }, {
      key: 'generateMonthScale',
      value(t) {
        const e = t.firstVal; const i = t.currentMonthDate; const a = t.currentMonth; const s = t.currentYear; const r = t.daysWidthOnXAxis; const n = t.numberOfMonths; let o = a; let l = 0; const h = new C(this.ctx); let c = 'month'; let d = 0; if (e.minDate > 1) {
          l = (h.determineDaysOfMonths(a + 1, e.minYear) - i + 1) * r, o = g.monthMod(a + 1); let u = s + d; let f = g.monthMod(o); let p = o; o === 0 && (c = 'year', p = u, f = 1, u += d += 1), this.timeScaleArray.push({
            position: l, value: p, unit: c, year: u, month: f,
          });
        } else {
 this.timeScaleArray.push({
          position: l, value: o, unit: c, year: s, month: g.monthMod(a),
        }); 
} for (let x = o + 1, b = l, m = 0, v = 1; m < n; m++, v++) {
          (x = g.monthMod(x)) === 0 ? (c = 'year', d += 1) : c = 'month'; const y = s + Math.floor(x / 12) + d; b = h.determineDaysOfMonths(x, y) * r + b; const w = x === 0 ? y : x; this.timeScaleArray.push({
            position: b, value: w, unit: c, year: y, month: x === 0 ? 1 : x,
          }), x++;
        }
      },
    }, {
      key: 'generateDayScale',
      value(t) {
        const e = t.firstVal; const i = t.currentMonth; const a = t.currentYear; const s = t.hoursWidthOnXAxis; let r = t.numberOfDays; const n = new C(this.ctx); let o = 'day'; const l = e.minDate + 1; let h = l; const c = function (t, e, i) { return t > n.determineDaysOfMonths(e + 1, i) ? (h = 1, o = 'month', u = e += 1, e) : e; }; let d = (24 - e.minHour) * s; var u = l; let f = c(h, i, a); e.minHour === 0 && e.minDate === 1 && (d = 0, u = g.monthMod(e.minMonth), o = 'month', h = e.minDate, r++), this.timeScaleArray.push({
          position: d, value: u, unit: o, year: a, month: g.monthMod(f), day: h,
        }); for (let p = d, x = 0; x < r; x++) {
          o = 'day', f = c(h += 1, f, a + Math.floor(f / 12) + 0); const b = a + Math.floor(f / 12) + 0; p = 24 * s + p; const m = h === 1 ? g.monthMod(f) : h; this.timeScaleArray.push({
            position: p, value: m, unit: o, year: b, month: g.monthMod(f), day: m,
          });
        }
      },
    }, {
      key: 'generateHourScale',
      value(t) {
        const e = t.firstVal; const i = t.currentDate; const a = t.currentMonth; const s = t.currentYear; const r = t.minutesWidthOnXAxis; const n = t.numberOfHours; const o = new C(this.ctx); let l = 'hour'; const h = function (t, e) { return t > o.determineDaysOfMonths(e + 1, s) && (x = 1, e += 1), { month: e, date: x }; }; const c = function (t, e) { return t > o.determineDaysOfMonths(e + 1, s) ? e += 1 : e; }; const d = 60 - e.minMinute; let u = d * r; let f = e.minHour + 1; let p = f + 1; d === 60 && (u = 0, p = (f = e.minHour) + 1); var x = i; let b = c(x, a); this.timeScaleArray.push({
          position: u, value: f, unit: l, day: x, hour: p, year: s, month: g.monthMod(b),
        }); for (let m = u, v = 0; v < n; v++) {
          if (l = 'hour', p >= 24)p = 0, l = 'day', b = h(x += 1, b).month, b = c(x, b); const y = s + Math.floor(b / 12) + 0; m = p === 0 && v === 0 ? d * r : 60 * r + m; const w = p === 0 ? x : p; this.timeScaleArray.push({
            position: m, value: w, unit: l, hour: p, day: x, year: y, month: g.monthMod(b),
          }), p++;
        }
      },
    }, {
      key: 'generateMinuteScale',
      value(t) {
        const e = t.firstVal; const i = t.currentMinute; const a = t.currentHour; const s = t.currentDate; const r = t.currentMonth; const n = t.currentYear; const o = t.minutesWidthOnXAxis; const l = t.numberOfMinutes; const h = o - (i - e.minMinute); const c = e.minMinute + 1; let d = c + 1; const u = s; const f = r; const p = n; let x = a; this.timeScaleArray.push({
          position: h, value: c, unit: 'minute', day: u, hour: x, minute: d, year: p, month: g.monthMod(f),
        }); for (let b = h, m = 0; m < l; m++) {
 d >= 60 && (d = 0, (x += 1) === 24 && (x = 0)), b = o + b, this.timeScaleArray.push({
          position: b, value: d, unit: 'minute', hour: x, minute: d, day: u, year: n + Math.floor(f / 12) + 0, month: g.monthMod(f),
        }), d++; 
}
      },
    }, { key: 'createRawDateString', value(t, e) { let i = t.year; return i += `-${(`0${t.month.toString()}`).slice(-2)}`, t.unit === 'day' ? i += t.unit === 'day' ? `-${(`0${e}`).slice(-2)}` : '-01' : i += `-${(`0${t.day ? t.day : '1'}`).slice(-2)}`, t.unit === 'hour' ? i += t.unit === 'hour' ? `T${(`0${e}`).slice(-2)}` : 'T00' : i += `T${(`0${t.hour ? t.hour : '0'}`).slice(-2)}`, i += t.unit === 'minute' ? `:${(`0${e}`).slice(-2)}:00` : ':00:00', this.utc && (i += '.000Z'), i; } }, {
      key: 'formatDates',
      value(t) {
        const e = this; const i = this.w; return t.map(((t) => {
          let a = t.value.toString(); const s = new C(e.ctx); const r = e.createRawDateString(t, a); const n = s.getDate(r); if (void 0 === i.config.xaxis.labels.format) { let o = 'dd MMM'; const l = i.config.xaxis.labels.datetimeFormatter; t.unit === 'year' && (o = l.year), t.unit === 'month' && (o = l.month), t.unit === 'day' && (o = l.day), t.unit === 'hour' && (o = l.hour), t.unit === 'minute' && (o = l.minute), a = s.formatDate(n, o); } else a = s.formatDate(n, i.config.xaxis.labels.format); return {
            dateString: r, position: t.position, value: a, unit: t.unit, year: t.year, month: t.month,
          };
        }));
      }, 
    }, { key: 'removeOverlappingTS', value(t) { const e = this; const i = new p(this.ctx); let a = 0; let s = t.map(((s, r) => { if (r > 0 && e.w.config.xaxis.labels.hideOverlappingLabels) { const n = i.getTextRects(t[a].value).width; const o = t[a].position; return s.position > o + n + 10 ? (a = r, s) : null; } return s; })); return s = s.filter(((t) => t !== null)); } }]), t;
  }()); const Pt = (function () { function t(i, a) { e(this, t), this.ctx = a, this.w = a.w, this.el = i; } return a(t, [{ key: 'setupElements', value() { const t = this.w.globals; const e = this.w.config; const i = e.chart.type; t.axisCharts = ['line', 'area', 'bar', 'rangeBar', 'candlestick', 'scatter', 'bubble', 'radar', 'heatmap'].indexOf(i) > -1, t.xyCharts = ['line', 'area', 'bar', 'rangeBar', 'candlestick', 'scatter', 'bubble'].indexOf(i) > -1, t.isBarHorizontal = (e.chart.type === 'bar' || e.chart.type === 'rangeBar') && e.plotOptions.bar.horizontal, t.chartClass = `.apexcharts${t.cuid}`, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement('div'), p.setAttrs(t.dom.elWrap, { id: t.chartClass.substring(1), class: `apexcharts-canvas ${t.chartClass.substring(1)}` }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({ class: 'apexcharts-svg', 'xmlns:data': 'ApexChartsNS', transform: 'translate('.concat(e.chart.offsetX, ', ').concat(e.chart.offsetY, ')') }), t.dom.Paper.node.style.background = e.chart.background, this.setSVGDimensions(), t.dom.elGraphical = t.dom.Paper.group().attr({ class: 'apexcharts-inner apexcharts-graphical' }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.elLegendWrap = document.createElement('div'), t.dom.elLegendWrap.classList.add('apexcharts-legend'), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs); } }, { key: 'plotChartType', value(t, e) { const i = this.w; const a = i.config; const s = i.globals; const r = { series: [], i: [] }; const n = { series: [], i: [] }; const o = { series: [], i: [] }; const l = { series: [], i: [] }; const h = { series: [], i: [] }; const c = { series: [], i: [] }; s.series.map(((e, d) => { void 0 !== t[d].type ? (t[d].type === 'column' || t[d].type === 'bar' ? (s.series.length > 1 && a.plotOptions.bar.horizontal && console.warn('Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`'), h.series.push(e), h.i.push(d), i.globals.columnSeries = h.series) : t[d].type === 'area' ? (n.series.push(e), n.i.push(d)) : t[d].type === 'line' ? (r.series.push(e), r.i.push(d)) : t[d].type === 'scatter' ? (o.series.push(e), o.i.push(d)) : t[d].type === 'bubble' ? (l.series.push(e), l.i.push(d)) : t[d].type === 'candlestick' ? (c.series.push(e), c.i.push(d)) : console.warn('You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble'), s.comboCharts = !0) : (r.series.push(e), r.i.push(d)); })); const d = new Ct(this.ctx, e); const g = new vt(this.ctx, e); const u = new at(this.ctx); const f = new kt(this.ctx); const p = new At(this.ctx, e); const x = new wt(this.ctx); let b = []; if (s.comboCharts) { if (n.series.length > 0 && b.push(d.draw(n.series, 'area', n.i)), h.series.length > 0) if (i.config.chart.stacked) { const m = new mt(this.ctx, e); b.push(m.draw(h.series, h.i)); } else { const v = new bt(this.ctx, e); b.push(v.draw(h.series, h.i)); } if (r.series.length > 0 && b.push(d.draw(r.series, 'line', r.i)), c.series.length > 0 && b.push(g.draw(c.series, c.i)), o.series.length > 0) { const y = new Ct(this.ctx, e, !0); b.push(y.draw(o.series, 'scatter', o.i)); } if (l.series.length > 0) { const w = new Ct(this.ctx, e, !0); b.push(w.draw(l.series, 'bubble', l.i)); } } else switch (a.chart.type) { case 'line': b = d.draw(s.series, 'line'); break; case 'area': b = d.draw(s.series, 'area'); break; case 'bar': if (a.chart.stacked)b = new mt(this.ctx, e).draw(s.series); else b = new bt(this.ctx, e).draw(s.series); break; case 'candlestick': b = new vt(this.ctx, e).draw(s.series); break; case 'rangeBar': b = p.draw(s.series); break; case 'heatmap': b = new yt(this.ctx, e).draw(s.series); break; case 'pie': case 'donut': b = u.draw(s.series); break; case 'radialBar': b = f.draw(s.series); break; case 'radar': b = x.draw(s.series); break; default: b = d.draw(s.series); } return b; } }, { key: 'setSVGDimensions', value() { const t = this.w.globals; const e = this.w.config; t.svgWidth = e.chart.width, t.svgHeight = e.chart.height; let i = g.getDimensions(this.el); const a = e.chart.width.toString().split(/[0-9]+/g).pop(); if (a === '%' ? g.isNumber(i[0]) && (i[0].width === 0 && (i = g.getDimensions(this.el.parentNode)), t.svgWidth = i[0] * parseInt(e.chart.width, 10) / 100) : a !== 'px' && a !== '' || (t.svgWidth = parseInt(e.chart.width, 10)), t.svgHeight !== 'auto' && t.svgHeight !== '') if (e.chart.height.toString().split(/[0-9]+/g).pop() === '%') { const s = g.getDimensions(this.el.parentNode); t.svgHeight = s[1] * parseInt(e.chart.height, 10) / 100; } else t.svgHeight = parseInt(e.chart.height, 10); else t.axisCharts ? t.svgHeight = t.svgWidth / 1.61 : t.svgHeight = t.svgWidth / 1.2; t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), p.setAttrs(t.dom.Paper.node, { width: t.svgWidth, height: t.svgHeight }); const r = e.chart.sparkline.enabled ? 0 : t.axisCharts ? e.chart.parentHeightOffset : 0; t.dom.Paper.node.parentNode.parentNode.style.minHeight = `${t.svgHeight + r}px`, t.dom.elWrap.style.width = `${t.svgWidth}px`, t.dom.elWrap.style.height = `${t.svgHeight}px`; } }, { key: 'shiftGraphPosition', value() { const t = this.w.globals; const e = t.translateY; const i = { transform: `translate(${t.translateX}, ${e})` }; p.setAttrs(t.dom.elGraphical.node, i), t.x2SpaceAvailable = t.svgWidth - t.dom.elGraphical.x() - t.gridWidth; } }, { key: 'resizeNonAxisCharts', value() { const t = this.w; const e = t.globals; let i = 0; let a = t.config.chart.sparkline.enabled ? 0 : 15; a += t.config.grid.padding.bottom, t.config.legend.position !== 'top' && t.config.legend.position !== 'bottom' || !t.config.legend.show || t.config.legend.floating || (i = new rt(this.ctx).legendHelpers.getLegendBBox().clwh + 10); const s = t.globals.dom.baseEl.querySelector('.apexcharts-radialbar'); let r = 2.05 * t.globals.radialSize; if (s && !t.config.chart.sparkline.enabled) { const n = g.getBoundingClientRect(s); r = n.bottom; const o = n.bottom - n.top; r = Math.max(2.05 * t.globals.radialSize, o); } const l = r + e.translateY + i + a; e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute('height', l), e.dom.elWrap.style.height = `${l}px`, p.setAttrs(e.dom.Paper.node, { height: l }), e.dom.Paper.node.parentNode.parentNode.style.minHeight = `${l}px`; } }, { key: 'coreCalculations', value() { new V(this.ctx).init(); } }, { key: 'resetGlobals', value() { const t = this; const e = function () { return t.w.config.series.map(((t) => [])); }; const i = new T(); const a = this.w.globals; i.initGlobalVars(a), a.seriesXvalues = e(), a.seriesYvalues = e(); } }, { key: 'isMultipleY', value() { if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0; } }, { key: 'xySettings', value() { let t = null; const e = this.w; if (e.globals.axisCharts) { if (e.config.xaxis.crosshairs.position === 'back') new q(this.ctx).drawXCrosshairs(); if (e.config.yaxis[0].crosshairs.position === 'back') new q(this.ctx).drawYCrosshairs(); if (e.config.xaxis.type === 'datetime' && void 0 === e.config.xaxis.labels.formatter) { const i = new Lt(this.ctx); let a = []; isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? a = i.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (a = i.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), i.recalcDimensionsBasedOnFormat(a); }t = new I(this.ctx).getCalculatedRatios(); } return t; } }, { key: 'setupBrushHandler', value() { const t = this; const e = this.w; if (e.config.chart.brush.enabled && typeof e.config.chart.events.selection !== 'function') { const i = e.config.chart.brush.targets || [e.config.chart.brush.target]; i.forEach(((e) => { const i = ApexCharts.getChartByID(e); i.w.globals.brushSource = t.ctx; const a = function () { t.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: i.w.globals.minX, max: i.w.globals.maxX } } } }, !1, !1); }; typeof i.w.config.chart.events.zoomed !== 'function' && (i.w.config.chart.events.zoomed = function () { a(); }), typeof i.w.config.chart.events.scrolled !== 'function' && (i.w.config.chart.events.scrolled = function () { a(); }); })), e.config.chart.events.selection = function (t, a) { i.forEach(((t) => { const i = ApexCharts.getChartByID(t); let s = g.clone(e.config.yaxis); e.config.chart.brush.autoScaleYaxis && i.w.globals.series.length === 1 && (s = new B(i).autoScaleY(i, s, a)); i.ctx.updateHelpers._updateOptions({ xaxis: { min: a.xaxis.min, max: a.xaxis.max }, yaxis: n({}, i.w.config.yaxis[0], { min: s[0].min, max: s[0].max }) }, !1, !1, !1, !1); })); }; } } }]), t; }()); const Tt = (function () {
    function i(t) { e(this, i), this.ctx = t, this.w = t.w; } return a(i, [{ key: '_updateOptions', value(e) { const i = this; const a = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; const n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let o = [this.ctx]; r && (o = this.ctx.getSyncedCharts()), this.ctx.w.globals.isExecCalled && (o = [this.ctx], this.ctx.w.globals.isExecCalled = !1), o.forEach(((r) => { const o = r.w; return o.globals.shouldAnimate = s, a || (o.globals.resized = !0, o.globals.dataChanged = !0, s && r.series.getPreviousPaths()), e && t(e) === 'object' && (r.config = new P(e), e = I.extendArrayProps(r.config, e), r.w.globals.chartID !== i.ctx.w.globals.chartID && delete e.series, o.config = g.extend(o.config, e), n && (o.globals.lastXAxis = [], o.globals.lastYAxis = [], o.globals.initialConfig = g.extend({}, o.config), o.globals.initialSeries = JSON.parse(JSON.stringify(o.config.series)))), r.update(e); })); } }, { key: '_updateSeries', value(t, e) { let i; const a = this; const s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const r = this.w; return r.globals.shouldAnimate = e, r.globals.dataChanged = !0, r.globals.allSeriesCollapsed && (r.globals.allSeriesCollapsed = !1), e && this.ctx.series.getPreviousPaths(), r.globals.axisCharts ? ((i = t.map(((t, e) => a._extendSeries(t, e)))).length === 0 && (i = [{ data: [] }]), r.config.series = i) : r.config.series = t.slice(), s && (r.globals.initialConfig.series = JSON.parse(JSON.stringify(r.config.series)), r.globals.initialSeries = JSON.parse(JSON.stringify(r.config.series))), this.ctx.update(); } }, { key: '_extendSeries', value(t, e) { const i = this.w; return n({}, i.config.series[e], { name: t.name ? t.name : i.config.series[e] && i.config.series[e].name, type: t.type ? t.type : i.config.series[e] && i.config.series[e].type, data: t.data ? t.data : i.config.series[e] && i.config.series[e].data }); } }, {
      key: 'toggleDataPointSelection',
      value(t, e) {
        const i = this.w; let a = null; const s = ".apexcharts-series[data\\:realIndex='".concat(t, "']"); i.globals.axisCharts ? a = i.globals.dom.Paper.select(''.concat(s, " path[j='").concat(e, "'], ").concat(s, " circle[j='").concat(e, "'], ")
          .concat(s, " rect[j='")
          .concat(e, "']")).members[0] : void 0 === e && (a = i.globals.dom.Paper.select(''.concat(s, " path[j='").concat(t, "']")).members[0], (i.config.chart.type === 'pie' || i.config.chart.type === 'donut') && new at(this.ctx).pieClicked(t)); return a ? (new p(this.ctx).pathMouseDown(a, null), a.node ? a.node : null) : (console.warn('toggleDataPointSelection: Element not found'), null);
      },
    }, { key: 'forceXAxisUpdate', value(t) { const e = this.w; if (['min', 'max'].forEach(((i) => { void 0 !== t.xaxis[i] && (e.config.xaxis[i] = t.xaxis[i], e.globals.lastXAxis[i] = t.xaxis[i]); })), t.xaxis.categories && t.xaxis.categories.length && (e.config.xaxis.categories = t.xaxis.categories), e.config.xaxis.convertedCatToNumeric) { const i = new L(t); t = i.convertCatToNumericXaxis(t, this.ctx); } return t; } }, { key: 'forceYAxisUpdate', value(t) { const e = this.w; return e.config.chart.stacked && e.config.chart.stackType === '100%' && (Array.isArray(t.yaxis) ? t.yaxis.forEach(((e, i) => { t.yaxis[i].min = 0, t.yaxis[i].max = 100; })) : (t.yaxis.min = 0, t.yaxis.max = 100)), t; } }, { key: 'revertDefaultAxisMinMax', value() { const t = this; const e = this.w; e.config.xaxis.min = e.globals.lastXAxis.min, e.config.xaxis.max = e.globals.lastXAxis.max, e.config.yaxis.map(((i, a) => { e.globals.zoomed ? void 0 !== e.globals.lastYAxis[a] && (i.min = e.globals.lastYAxis[a].min, i.max = e.globals.lastYAxis[a].max) : void 0 !== t.ctx.opts.yaxis[a] && (i.min = t.ctx.opts.yaxis[a].min, i.max = t.ctx.opts.yaxis[a].max); })); } }]), i;
  }()); y = typeof window !== 'undefined' ? window : void 0, w = function (e, i) {
    var a = (void 0 !== this ? this : e).SVG = function (t) { if (a.supported) return t = new a.Doc(t), a.parser.draw || a.prepare(), t; }; if (a.ns = 'http://www.w3.org/2000/svg', a.xmlns = 'http://www.w3.org/2000/xmlns/', a.xlink = 'http://www.w3.org/1999/xlink', a.svgjs = 'http://svgjs.com/svgjs', a.supported = !0, !a.supported) return !1; a.did = 1e3, a.eid = function (t) { return `Svgjs${d(t)}${a.did++}`; }, a.create = function (t) { const e = i.createElementNS(this.ns, t); return e.setAttribute('id', this.eid(t)), e; }, a.extend = function () { let t; let e; let i; let s; for (e = (t = [].slice.call(arguments)).pop(), s = t.length - 1; s >= 0; s--) if (t[s]) for (i in e)t[s].prototype[i] = e[i]; a.Set && a.Set.inherit && a.Set.inherit(); }, a.invent = function (t) { const e = typeof t.create === 'function' ? t.create : function () { this.constructor.call(this, a.create(t.create)); }; return t.inherit && (e.prototype = new t.inherit()), t.extend && a.extend(e, t.extend), t.construct && a.extend(t.parent || a.Container, t.construct), e; }, a.adopt = function (t) { return t ? t.instance ? t.instance : ((i = t.nodeName == 'svg' ? t.parentNode instanceof e.SVGElement ? new a.Nested() : new a.Doc() : t.nodeName == 'linearGradient' ? new a.Gradient('linear') : t.nodeName == 'radialGradient' ? new a.Gradient('radial') : a[d(t.nodeName)] ? new (a[d(t.nodeName)])() : new a.Element(t)).type = t.nodeName, i.node = t, t.instance = i, i instanceof a.Doc && i.namespace().defs(), i.setData(JSON.parse(t.getAttribute('svgjs:data')) || {}), i) : null; let i; }, a.prepare = function () {
      const t = i.getElementsByTagName('body')[0]; const e = (t ? new a.Doc(t) : a.adopt(i.documentElement).nested()).size(2, 0); a.parser = {
        body: t || i.documentElement, draw: e.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node, poly: e.polyline().node, path: e.path().node, native: a.create('svg'),
      };
    }, a.parser = { native: a.create('svg') }, i.addEventListener('DOMContentLoaded', (() => { a.parser.draw || a.prepare(); }), !1), a.regex = {
      numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g,
    }, a.utils = { map(t, e) { let i; const a = t.length; const s = []; for (i = 0; i < a; i++)s.push(e(t[i])); return s; }, filter(t, e) { let i; const a = t.length; const s = []; for (i = 0; i < a; i++)e(t[i]) && s.push(t[i]); return s; }, filterSVGElements(t) { return this.filter(t, ((t) => t instanceof e.SVGElement)); } }, a.defaults = {
      attrs: {
        'fill-opacity': 1, 'stroke-opacity': 1, 'stroke-width': 0, 'stroke-linejoin': 'miter', 'stroke-linecap': 'butt', fill: '#000000', stroke: '#000000', opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, 'stop-opacity': 1, 'stop-color': '#000000', 'font-size': 16, 'font-family': 'Helvetica, Arial, sans-serif', 'text-anchor': 'start',
      },
    }, a.Color = function (e) { let i; let s; this.r = 0, this.g = 0, this.b = 0, e && (typeof e === 'string' ? a.regex.isRgb.test(e) ? (i = a.regex.rgb.exec(e.replace(a.regex.whitespace, '')), this.r = parseInt(i[1]), this.g = parseInt(i[2]), this.b = parseInt(i[3])) : a.regex.isHex.test(e) && (i = a.regex.hex.exec((s = e).length == 4 ? ['#', s.substring(1, 2), s.substring(1, 2), s.substring(2, 3), s.substring(2, 3), s.substring(3, 4), s.substring(3, 4)].join('') : s), this.r = parseInt(i[1], 16), this.g = parseInt(i[2], 16), this.b = parseInt(i[3], 16)) : t(e) === 'object' && (this.r = e.r, this.g = e.g, this.b = e.b)); }, a.extend(a.Color, {
      toString() { return this.toHex(); }, toHex() { return `#${g(this.r)}${g(this.g)}${g(this.b)}`; }, toRgb() { return `rgb(${[this.r, this.g, this.b].join()})`; }, brightness() { return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11; }, morph(t) { return this.destination = new a.Color(t), this; }, at(t) { return this.destination ? (t = t < 0 ? 0 : t > 1 ? 1 : t, new a.Color({ r: ~~(this.r + (this.destination.r - this.r) * t), g: ~~(this.g + (this.destination.g - this.g) * t), b: ~~(this.b + (this.destination.b - this.b) * t) })) : this; },
    }), a.Color.test = function (t) { return t += '', a.regex.isHex.test(t) || a.regex.isRgb.test(t); }, a.Color.isRgb = function (t) { return t && typeof t.r === 'number' && typeof t.g === 'number' && typeof t.b === 'number'; }, a.Color.isColor = function (t) { return a.Color.isRgb(t) || a.Color.test(t); }, a.Array = function (t, e) { (t = (t || []).valueOf()).length == 0 && e && (t = e.valueOf()), this.value = this.parse(t); }, a.extend(a.Array, { toString() { return this.value.join(' '); }, valueOf() { return this.value; }, parse(t) { return t = t.valueOf(), Array.isArray(t) ? t : this.split(t); } }), a.PointArray = function (t, e) { a.Array.call(this, t, e || [[0, 0]]); }, a.PointArray.prototype = new a.Array(), a.PointArray.prototype.constructor = a.PointArray; for (var s = {
        M(t, e, i) { return e.x = i.x = t[0], e.y = i.y = t[1], ['M', e.x, e.y]; }, L(t, e) { return e.x = t[0], e.y = t[1], ['L', t[0], t[1]]; }, H(t, e) { return e.x = t[0], ['H', t[0]]; }, V(t, e) { return e.y = t[0], ['V', t[0]]; }, C(t, e) { return e.x = t[4], e.y = t[5], ['C', t[0], t[1], t[2], t[3], t[4], t[5]]; }, Q(t, e) { return e.x = t[2], e.y = t[3], ['Q', t[0], t[1], t[2], t[3]]; }, Z(t, e, i) { return e.x = i.x, e.y = i.y, ['Z']; },
      }, r = 'mlhvqtcsaz'.split(''), n = 0, o = r.length; n < o; ++n)s[r[n]] = (function (t) { return function (e, i, a) { if (t == 'H')e[0] += i.x; else if (t == 'V')e[0] += i.y; else if (t == 'A')e[5] += i.x, e[6] += i.y; else for (let r = 0, n = e.length; r < n; ++r)e[r] = e[r] + (r % 2 ? i.y : i.x); return s[t](e, i, a); }; }(r[n].toUpperCase())); a.PathArray = function (t, e) { a.Array.call(this, t, e || [['M', 0, 0]]); }, a.PathArray.prototype = new a.Array(), a.PathArray.prototype.constructor = a.PathArray, a.extend(a.PathArray, {
      toString() { return (function (t) { for (var e = 0, i = t.length, a = ''; e < i; e++)a += t[e][0], t[e][1] != null && (a += t[e][1], t[e][2] != null && (a += ' ', a += t[e][2], t[e][3] != null && (a += ' ', a += t[e][3], a += ' ', a += t[e][4], t[e][5] != null && (a += ' ', a += t[e][5], a += ' ', a += t[e][6], t[e][7] != null && (a += ' ', a += t[e][7]))))); return `${a} `; }(this.value)); },
      move(t, e) { const i = this.bbox(); return i.x, i.y, this; },
      at(t) { if (!this.destination) return this; let e; let i; let s; let r; const n = this.value; const o = this.destination.value; const l = []; const h = new a.PathArray(); for (e = 0, i = n.length; e < i; e++) { for (l[e] = [n[e][0]], s = 1, r = n[e].length; s < r; s++)l[e][s] = n[e][s] + (o[e][s] - n[e][s]) * t; l[e][0] === 'A' && (l[e][4] = +(l[e][4] != 0), l[e][5] = +(l[e][5] != 0)); } return h.value = l, h; },
      parse(t) {
        if (t instanceof a.PathArray) return t.valueOf(); let e; const i = {
          M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0,
        }; t = typeof t === 'string' ? t.replace(a.regex.numbersWithDots, h).replace(a.regex.pathLetters, ' $& ').replace(a.regex.hyphen, '$1 -').trim()
          .split(a.regex.delimiter) : t.reduce(((t, e) => [].concat.call(t, e)), []); const r = []; const n = new a.Point(); const o = new a.Point(); let l = 0; const c = t.length; do { a.regex.isPathLetter.test(t[l]) ? (e = t[l], ++l) : e == 'M' ? e = 'L' : e == 'm' && (e = 'l'), r.push(s[e].call(null, t.slice(l, l += i[e.toUpperCase()]).map(parseFloat), n, o)); } while (c > l);return r;
      },
      bbox() { return a.parser.draw || a.prepare(), a.parser.path.setAttribute('d', this.toString()), a.parser.path.getBBox(); },
    }), a.Number = a.invent({
      create(t, e) { this.value = 0, this.unit = e || '', typeof t === 'number' ? this.value = isNaN(t) ? 0 : isFinite(t) ? t : t < 0 ? -34e37 : 34e37 : typeof t === 'string' ? (e = t.match(a.regex.numberAndUnit)) && (this.value = parseFloat(e[1]), e[5] == '%' ? this.value /= 100 : e[5] == 's' && (this.value *= 1e3), this.unit = e[5]) : t instanceof a.Number && (this.value = t.valueOf(), this.unit = t.unit); },
      extend: {
        toString() { return (this.unit == '%' ? ~~(1e8 * this.value) / 1e6 : this.unit == 's' ? this.value / 1e3 : this.value) + this.unit; }, toJSON() { return this.toString(); }, valueOf() { return this.value; }, plus(t) { return t = new a.Number(t), new a.Number(this + t, this.unit || t.unit); }, minus(t) { return t = new a.Number(t), new a.Number(this - t, this.unit || t.unit); }, times(t) { return t = new a.Number(t), new a.Number(this * t, this.unit || t.unit); }, divide(t) { return t = new a.Number(t), new a.Number(this / t, this.unit || t.unit); }, to(t) { const e = new a.Number(this); return typeof t === 'string' && (e.unit = t), e; }, morph(t) { return this.destination = new a.Number(t), t.relative && (this.destination.value += this.value), this; }, at(t) { return this.destination ? new a.Number(this.destination).minus(this).times(t).plus(this) : this; },
      },
    }), a.Element = a.invent({
      create(t) { this._stroke = a.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t) && (this.type = t.nodeName, this.node.instance = this, this._stroke = t.getAttribute('stroke') || this._stroke); },
      extend: {
        x(t) { return this.attr('x', t); }, y(t) { return this.attr('y', t); }, cx(t) { return t == null ? this.x() + this.width() / 2 : this.x(t - this.width() / 2); }, cy(t) { return t == null ? this.y() + this.height() / 2 : this.y(t - this.height() / 2); }, move(t, e) { return this.x(t).y(e); }, center(t, e) { return this.cx(t).cy(e); }, width(t) { return this.attr('width', t); }, height(t) { return this.attr('height', t); }, size(t, e) { const i = u(this, t, e); return this.width(new a.Number(i.width)).height(new a.Number(i.height)); }, clone(t) { this.writeDataToDom(); const e = x(this.node.cloneNode(!0)); return t ? t.add(e) : this.after(e), e; }, remove() { return this.parent() && this.parent().removeElement(this), this; }, replace(t) { return this.after(t).remove(), t; }, addTo(t) { return t.put(this); }, putIn(t) { return t.add(this); }, id(t) { return this.attr('id', t); }, show() { return this.style('display', ''); }, hide() { return this.style('display', 'none'); }, visible() { return this.style('display') != 'none'; }, toString() { return this.attr('id'); }, classes() { const t = this.attr('class'); return t == null ? [] : t.trim().split(a.regex.delimiter); }, hasClass(t) { return this.classes().indexOf(t) != -1; }, addClass(t) { if (!this.hasClass(t)) { const e = this.classes(); e.push(t), this.attr('class', e.join(' ')); } return this; }, removeClass(t) { return this.hasClass(t) && this.attr('class', this.classes().filter(((e) => e != t)).join(' ')), this; }, toggleClass(t) { return this.hasClass(t) ? this.removeClass(t) : this.addClass(t); }, reference(t) { return a.get(this.attr(t)); }, parent(t) { let i = this; if (!i.node.parentNode) return null; if (i = a.adopt(i.node.parentNode), !t) return i; for (;i && i.node instanceof e.SVGElement;) { if (typeof t === 'string' ? i.matches(t) : i instanceof t) return i; if (!i.node.parentNode || i.node.parentNode.nodeName == '#document') return null; i = a.adopt(i.node.parentNode); } }, doc() { return this instanceof a.Doc ? this : this.parent(a.Doc); }, parents(t) { const e = []; let i = this; do { if (!(i = i.parent(t)) || !i.node) break; e.push(i); } while (i.parent);return e; }, matches(t) { return (function (t, e) { return (t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector).call(t, e); }(this.node, t)); }, native() { return this.node; }, svg(t) { const e = i.createElement('svg'); if (!(t && this instanceof a.Parent)) return e.appendChild(t = i.createElement('svg')), this.writeDataToDom(), t.appendChild(this.node.cloneNode(!0)), e.innerHTML.replace(/^<svg>/, '').replace(/<\/svg>$/, ''); e.innerHTML = `<svg>${t.replace(/\n/, '').replace(/<([\w:-]+)([^<]+?)\/>/g, '<$1$2></$1>')}</svg>`; for (let s = 0, r = e.firstChild.childNodes.length; s < r; s++) this.node.appendChild(e.firstChild.firstChild); return this; }, writeDataToDom() { return (this.each || this.lines) && (this.each ? this : this.lines()).each((function () { this.writeDataToDom(); })), this.node.removeAttribute('svgjs:data'), Object.keys(this.dom).length && this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)), this; }, setData(t) { return this.dom = t, this; }, is(t) { return (function (t, e) { return t instanceof e; }(this, t)); },
      },
    }), a.easing = {
      '-': function (t) { return t; }, '<>': function (t) { return -Math.cos(t * Math.PI) / 2 + 0.5; }, '>': function (t) { return Math.sin(t * Math.PI / 2); }, '<': function (t) { return 1 - Math.cos(t * Math.PI / 2); },
    }, a.morph = function (t) { return function (e, i) { return new a.MorphObj(e, i).at(t); }; }, a.Situation = a.invent({ create(t) { this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new a.Number(t.duration).valueOf(), this.delay = new a.Number(t.delay).valueOf(), this.start = +new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {}; } }), a.FX = a.invent({
      create(t) { this._target = t, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1; },
      extend: {
        animate(e, i, s) { t(e) === 'object' && (i = e.ease, s = e.delay, e = e.duration); const r = new a.Situation({ duration: e || 1e3, delay: s || 0, ease: a.easing[i || '-'] || i }); return this.queue(r), this; },
        target(t) { return t && t instanceof a.Element ? (this._target = t, this) : this._target; },
        timeToAbsPos(t) { return (t - this.situation.start) / (this.situation.duration / this._speed); },
        absPosToTime(t) { return this.situation.duration / this._speed * t + this.situation.start; },
        startAnimFrame() { this.stopAnimFrame(), this.animationFrame = e.requestAnimationFrame(() => { this.step(); }); },
        stopAnimFrame() { e.cancelAnimationFrame(this.animationFrame); },
        start() { return !this.active && this.situation && (this.active = !0, this.startCurrent()), this; },
        startCurrent() { return this.situation.start = +new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step(); },
        queue(t) { return (typeof t === 'function' || t instanceof a.Situation) && this.situations.push(t), this.situation || (this.situation = this.situations.shift()), this; },
        dequeue() { return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof a.Situation ? this.start() : this.situation.call(this)), this; },
        initAnimations() { let t; let e; let i; const s = this.situation; if (s.init) return this; for (t in s.animations) for (i = this.target()[t](), Array.isArray(i) || (i = [i]), Array.isArray(s.animations[t]) || (s.animations[t] = [s.animations[t]]), e = i.length; e--;)s.animations[t][e] instanceof a.Number && (i[e] = new a.Number(i[e])), s.animations[t][e] = i[e].morph(s.animations[t][e]); for (t in s.attrs)s.attrs[t] = new a.MorphObj(this.target().attr(t), s.attrs[t]); for (t in s.styles)s.styles[t] = new a.MorphObj(this.target().style(t), s.styles[t]); return s.initialTransformation = this.target().matrixify(), s.init = !0, this; },
        clearQueue() { return this.situations = [], this; },
        clearCurrent() { return this.situation = null, this; },
        stop(t, e) { const i = this.active; return this.active = !1, e && this.clearQueue(), t && this.situation && (!i && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent(); },
        after(t) { const e = this.last(); return this.target().on('finished.fx', (function i(a) { a.detail.situation == e && (t.call(this, e), this.off('finished.fx', i)); })), this._callStart(); },
        during(t) { const e = this.last(); const i = function (i) { i.detail.situation == e && t.call(this, i.detail.pos, a.morph(i.detail.pos), i.detail.eased, e); }; return this.target().off('during.fx', i).on('during.fx', i), this.after((function () { this.off('during.fx', i); })), this._callStart(); },
        afterAll(t) { const e = function e(i) { t.call(this), this.off('allfinished.fx', e); }; return this.target().off('allfinished.fx', e).on('allfinished.fx', e), this._callStart(); },
        last() { return this.situations.length ? this.situations[this.situations.length - 1] : this.situation; },
        add(t, e, i) { return this.last()[i || 'animations'][t] = e, this._callStart(); },
        step(t) {
          let e; let i; let a; t || (this.absPos = this.timeToAbsPos(+new Date())), !1 !== this.situation.loops ? (e = Math.max(this.absPos, 0), i = Math.floor(e), !0 === this.situation.loops || i < this.situation.loops ? (this.pos = e - i, a = this.situation.loop, this.situation.loop = i) : (this.absPos = this.situation.loops, this.pos = 1, a = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos); const s = this.situation.ease(this.pos); for (const r in this.situation.once)r > this.lastPos && r <= s && (this.situation.once[r].call(this.target(), this.pos, s), delete this.situation.once[r]); return this.active && this.target().fire('during', {
            pos: this.pos, eased: s, fx: this, situation: this.situation,
          }), this.situation ? (this.eachAt(), this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0 ? (this.stopAnimFrame(), this.target().fire('finished', { fx: this, situation: this.situation }), this.situations.length || (this.target().fire('allfinished'), this.situations.length || (this.target().off('.fx'), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s, this) : this;
        },
        eachAt() { let t; let e; let i; const s = this; const r = this.target(); const n = this.situation; for (t in n.animations)i = [].concat(n.animations[t]).map(((t) => (typeof t !== 'string' && t.at ? t.at(n.ease(s.pos), s.pos) : t))), r[t].apply(r, i); for (t in n.attrs)i = [t].concat(n.attrs[t]).map(((t) => (typeof t !== 'string' && t.at ? t.at(n.ease(s.pos), s.pos) : t))), r.attr.apply(r, i); for (t in n.styles)i = [t].concat(n.styles[t]).map(((t) => (typeof t !== 'string' && t.at ? t.at(n.ease(s.pos), s.pos) : t))), r.style.apply(r, i); if (n.transforms.length) { for (i = n.initialTransformation, t = 0, e = n.transforms.length; t < e; t++) { const o = n.transforms[t]; o instanceof a.Matrix ? i = o.relative ? i.multiply((new a.Matrix()).morph(o).at(n.ease(this.pos))) : i.morph(o).at(n.ease(this.pos)) : (o.relative || o.undo(i.extract()), i = i.multiply(o.at(n.ease(this.pos)))); }r.matrix(i); } return this; },
        once(t, e, i) { const a = this.last(); return i || (t = a.ease(t)), a.once[t] = e, this; },
        _callStart() { return setTimeout(() => { this.start(); }, 0), this; },
      },
      parent: a.Element,
      construct: {
        animate(t, e, i) { return (this.fx || (this.fx = new a.FX(this))).animate(t, e, i); }, delay(t) { return (this.fx || (this.fx = new a.FX(this))).delay(t); }, stop(t, e) { return this.fx && this.fx.stop(t, e), this; }, finish() { return this.fx && this.fx.finish(), this; },
      },
    }), a.MorphObj = a.invent({ create(t, e) { return a.Color.isColor(e) ? new a.Color(t).morph(e) : a.regex.delimiter.test(t) ? a.regex.pathLetters.test(t) ? new a.PathArray(t).morph(e) : new a.Array(t).morph(e) : a.regex.numberAndUnit.test(e) ? new a.Number(t).morph(e) : (this.value = t, void (this.destination = e)); }, extend: { at(t, e) { return e < 1 ? this.value : this.destination; }, valueOf() { return this.value; } } }), a.extend(a.FX, { attr(e, i, a) { if (t(e) === 'object') for (const s in e) this.attr(s, e[s]); else this.add(e, i, 'attrs'); return this; }, plot(t, e, i, a) { return arguments.length == 4 ? this.plot([t, e, i, a]) : this.add('plot', new (this.target().morphArray)(t)); } }), a.Box = a.invent({ create(e, i, s, r) { if (!(t(e) !== 'object' || e instanceof a.Element)) return a.Box.call(this, e.left != null ? e.left : e.x, e.top != null ? e.top : e.y, e.width, e.height); arguments.length == 4 && (this.x = e, this.y = i, this.width = s, this.height = r), b(this); } }), a.BBox = a.invent({
      create(t) {
        if (a.Box.apply(this, [].slice.call(arguments)), t instanceof a.Element) {
          let e; try { if (!i.documentElement.contains) { for (var s = t.node; s.parentNode;)s = s.parentNode; if (s != i) throw new Error('Element not in the dom'); }e = t.node.getBBox(); } catch (i) {
            if (t instanceof a.Shape) { a.parser.draw || a.prepare(); const r = t.clone(a.parser.draw.instance).show(); e = r.node.getBBox(), r.remove(); } else {
              e = {
                x: t.node.clientLeft, y: t.node.clientTop, width: t.node.clientWidth, height: t.node.clientHeight,
              };
            }
          }a.Box.call(this, e);
        }
      },
      inherit: a.Box,
      parent: a.Element,
      construct: { bbox() { return new a.BBox(this); } },
    }), a.BBox.prototype.constructor = a.BBox, a.Matrix = a.invent({
      create(e) { let i; const s = p([1, 0, 0, 1, 0, 0]); for (e = e instanceof a.Element ? e.matrixify() : typeof e === 'string' ? p(e.split(a.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? p([].slice.call(arguments)) : Array.isArray(e) ? p(e) : t(e) === 'object' ? e : s, i = v.length - 1; i >= 0; --i) this[v[i]] = e[v[i]] != null ? e[v[i]] : s[v[i]]; },
      extend: {
        extract() {
          const t = f(this, 0, 1); const e = (f(this, 1, 0), 180 / Math.PI * Math.atan2(t.y, t.x) - 90); return {
            x: this.e, y: this.f, transformedX: (this.e * Math.cos(e * Math.PI / 180) + this.f * Math.sin(e * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(e * Math.PI / 180) + this.e * Math.sin(-e * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: e, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new a.Matrix(this),
          };
        },
        clone() { return new a.Matrix(this); },
        morph(t) { return this.destination = new a.Matrix(t), this; },
        multiply(t) { return new a.Matrix(this.native().multiply((function (t) { return t instanceof a.Matrix || (t = new a.Matrix(t)), t; }(t)).native())); },
        inverse() { return new a.Matrix(this.native().inverse()); },
        translate(t, e) { return new a.Matrix(this.native().translate(t || 0, e || 0)); },
        native() { for (var t = a.parser.native.createSVGMatrix(), e = v.length - 1; e >= 0; e--)t[v[e]] = this[v[e]]; return t; },
        toString() { return `matrix(${m(this.a)},${m(this.b)},${m(this.c)},${m(this.d)},${m(this.e)},${m(this.f)})`; },
      },
      parent: a.Element,
      construct: { ctm() { return new a.Matrix(this.node.getCTM()); }, screenCTM() { if (this instanceof a.Nested) { const t = this.rect(1, 1); const e = t.node.getScreenCTM(); return t.remove(), new a.Matrix(e); } return new a.Matrix(this.node.getScreenCTM()); } },
    }), a.Point = a.invent({ create(e, i) { let a; a = Array.isArray(e) ? { x: e[0], y: e[1] } : t(e) === 'object' ? { x: e.x, y: e.y } : e != null ? { x: e, y: i != null ? i : e } : { x: 0, y: 0 }, this.x = a.x, this.y = a.y; }, extend: { clone() { return new a.Point(this); }, morph(t, e) { return this.destination = new a.Point(t, e), this; } } }), a.extend(a.Element, { point(t, e) { return new a.Point(t, e).transform(this.screenCTM().inverse()); } }), a.extend(a.Element, { attr(e, i, s) { if (e == null) { for (e = {}, s = (i = this.node.attributes).length - 1; s >= 0; s--)e[i[s].nodeName] = a.regex.isNumber.test(i[s].nodeValue) ? parseFloat(i[s].nodeValue) : i[s].nodeValue; return e; } if (t(e) === 'object') for (i in e) this.attr(i, e[i]); else if (i === null) this.node.removeAttribute(e); else { if (i == null) return (i = this.node.getAttribute(e)) == null ? a.defaults.attrs[e] : a.regex.isNumber.test(i) ? parseFloat(i) : i; e == 'stroke-width' ? this.attr('stroke', parseFloat(i) > 0 ? this._stroke : null) : e == 'stroke' && (this._stroke = i), e != 'fill' && e != 'stroke' || (a.regex.isImage.test(i) && (i = this.doc().defs().image(i, 0, 0)), i instanceof a.Image && (i = this.doc().defs().pattern(0, 0, (function () { this.add(i); })))), typeof i === 'number' ? i = new a.Number(i) : a.Color.isColor(i) ? i = new a.Color(i) : Array.isArray(i) && (i = new a.Array(i)), e == 'leading' ? this.leading && this.leading(i) : typeof s === 'string' ? this.node.setAttributeNS(s, e, i.toString()) : this.node.setAttribute(e, i.toString()), !this.rebuild || e != 'font-size' && e != 'x' || this.rebuild(e, i); } return this; } }), a.extend(a.Element, { transform(e, i) { let s; return t(e) !== 'object' ? (s = new a.Matrix(this).extract(), typeof e === 'string' ? s[e] : s) : (s = new a.Matrix(this), i = !!i || !!e.relative, e.a != null && (s = i ? s.multiply(new a.Matrix(e)) : new a.Matrix(e)), this.attr('transform', s)); } }), a.extend(a.Element, {
      untransform() { return this.attr('transform', null); }, matrixify() { return (this.attr('transform') || '').split(a.regex.transforms).slice(0, -1).map(((t) => { const e = t.trim().split('('); return [e[0], e[1].split(a.regex.delimiter).map(((t) => parseFloat(t)))]; })).reduce(((t, e) => (e[0] == 'matrix' ? t.multiply(p(e[1])) : t[e[0]].apply(t, e[1]))), new a.Matrix()); }, toParent(t) { if (this == t) return this; const e = this.screenCTM(); const i = t.screenCTM().inverse(); return this.addTo(t).untransform().transform(i.multiply(e)), this; }, toDoc() { return this.toParent(this.doc()); },
    }), a.Transformation = a.invent({ create(e, i) { if (arguments.length > 1 && typeof i !== 'boolean') return this.constructor.call(this, [].slice.call(arguments)); if (Array.isArray(e)) for (var a = 0, s = this.arguments.length; a < s; ++a) this[this.arguments[a]] = e[a]; else if (t(e) === 'object') for (a = 0, s = this.arguments.length; a < s; ++a) this[this.arguments[a]] = e[this.arguments[a]]; this.inversed = !1, !0 === i && (this.inversed = !0); } }), a.Translate = a.invent({
      parent: a.Matrix, inherit: a.Transformation, create(t, e) { this.constructor.apply(this, [].slice.call(arguments)); }, extend: { arguments: ['transformedX', 'transformedY'], method: 'translate' },
    }), a.extend(a.Element, { style(e, i) { if (arguments.length == 0) return this.node.style.cssText || ''; if (arguments.length < 2) if (t(e) === 'object') for (i in e) this.style(i, e[i]); else { if (!a.regex.isCss.test(e)) return this.node.style[c(e)]; for (e = e.split(/\s*;\s*/).filter(((t) => !!t)).map(((t) => t.split(/\s*:\s*/))); i = e.pop();) this.style(i[0], i[1]); } else this.node.style[c(e)] = i === null || a.regex.isBlank.test(i) ? '' : i; return this; } }), a.Parent = a.invent({
      create(t) { this.constructor.call(this, t); },
      inherit: a.Element,
      extend: {
        children() { return a.utils.map(a.utils.filterSVGElements(this.node.childNodes), ((t) => a.adopt(t))); }, add(t, e) { return e == null ? this.node.appendChild(t.node) : t.node != this.node.childNodes[e] && this.node.insertBefore(t.node, this.node.childNodes[e]), this; }, put(t, e) { return this.add(t, e), t; }, has(t) { return this.index(t) >= 0; }, index(t) { return [].slice.call(this.node.childNodes).indexOf(t.node); }, get(t) { return a.adopt(this.node.childNodes[t]); }, first() { return this.get(0); }, last() { return this.get(this.node.childNodes.length - 1); }, each(t, e) { let i; let s; const r = this.children(); for (i = 0, s = r.length; i < s; i++)r[i] instanceof a.Element && t.apply(r[i], [i, r]), e && r[i] instanceof a.Container && r[i].each(t, e); return this; }, removeElement(t) { return this.node.removeChild(t.node), this; }, clear() { for (;this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild); return delete this._defs, this; }, defs() { return this.doc().defs(); },
      },
    }), a.extend(a.Parent, { ungroup(t, e) { return e === 0 || this instanceof a.Defs || this.node == a.parser.draw ? this : (t = t || (this instanceof a.Doc ? this : this.parent(a.Parent)), e = e || 1 / 0, this.each((function () { return this instanceof a.Defs ? this : this instanceof a.Parent ? this.ungroup(t, e - 1) : this.toParent(t); })), this.node.firstChild || this.remove(), this); }, flatten(t, e) { return this.ungroup(t, e); } }), a.Container = a.invent({ create(t) { this.constructor.call(this, t); }, inherit: a.Parent }), a.ViewBox = a.invent({ parent: a.Container, construct: {} }), ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].forEach(((t) => { a.Element.prototype[t] = function (e) { return a.on(this.node, t, e), this; }; })), a.listeners = [], a.handlerMap = [], a.listenerId = 0, a.on = function (t, e, i, s, r) { const n = i.bind(s || t.instance || t); const o = (a.handlerMap.indexOf(t) + 1 || a.handlerMap.push(t)) - 1; const l = e.split('.')[0]; const h = e.split('.')[1] || '*'; a.listeners[o] = a.listeners[o] || {}, a.listeners[o][l] = a.listeners[o][l] || {}, a.listeners[o][l][h] = a.listeners[o][l][h] || {}, i._svgjsListenerId || (i._svgjsListenerId = ++a.listenerId), a.listeners[o][l][h][i._svgjsListenerId] = n, t.addEventListener(l, n, r || !1); }, a.off = function (t, e, i) { const s = a.handlerMap.indexOf(t); const r = e && e.split('.')[0]; const n = e && e.split('.')[1]; let o = ''; if (s != -1) if (i) { if (typeof i === 'function' && (i = i._svgjsListenerId), !i) return; a.listeners[s][r] && a.listeners[s][r][n || '*'] && (t.removeEventListener(r, a.listeners[s][r][n || '*'][i], !1), delete a.listeners[s][r][n || '*'][i]); } else if (n && r) { if (a.listeners[s][r] && a.listeners[s][r][n]) { for (i in a.listeners[s][r][n])a.off(t, [r, n].join('.'), i); delete a.listeners[s][r][n]; } } else if (n) for (e in a.listeners[s]) for (o in a.listeners[s][e])n === o && a.off(t, [e, n].join('.')); else if (r) { if (a.listeners[s][r]) { for (o in a.listeners[s][r])a.off(t, [r, o].join('.')); delete a.listeners[s][r]; } } else { for (e in a.listeners[s])a.off(t, e); delete a.listeners[s], delete a.handlerMap[s]; } }, a.extend(a.Element, {
      on(t, e, i, s) { return a.on(this.node, t, e, i, s), this; }, off(t, e) { return a.off(this.node, t, e), this; }, fire(t, i) { return t instanceof e.Event ? this.node.dispatchEvent(t) : this.node.dispatchEvent(t = new a.CustomEvent(t, { detail: i, cancelable: !0 })), this._event = t, this; }, event() { return this._event; },
    }), a.Defs = a.invent({ create: 'defs', inherit: a.Container }), a.G = a.invent({
      create: 'g', inherit: a.Container, extend: { x(t) { return t == null ? this.transform('x') : this.transform({ x: t - this.x() }, !0); } }, construct: { group() { return this.put(new a.G()); } },
    }), a.Doc = a.invent({
      create(t) { t && ((t = typeof t === 'string' ? i.getElementById(t) : t).nodeName == 'svg' ? this.constructor.call(this, t) : (this.constructor.call(this, a.create('svg')), t.appendChild(this.node), this.size('100%', '100%')), this.namespace().defs()); },
      inherit: a.Container,
      extend: {
        namespace() { return this.attr({ xmlns: a.ns, version: '1.1' }).attr('xmlns:xlink', a.xlink, a.xmlns).attr('xmlns:svgjs', a.svgjs, a.xmlns); }, defs() { let t; return this._defs || ((t = this.node.getElementsByTagName('defs')[0]) ? this._defs = a.adopt(t) : this._defs = new a.Defs(), this.node.appendChild(this._defs.node)), this._defs; }, parent() { return this.node.parentNode && this.node.parentNode.nodeName != '#document' ? this.node.parentNode : null; }, remove() { return this.parent() && this.parent().removeChild(this.node), this; }, clear() { for (;this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild); return delete this._defs, a.parser.draw && !a.parser.draw.parentNode && this.node.appendChild(a.parser.draw), this; }, clone(t) { this.writeDataToDom(); const e = this.node; const i = x(e.cloneNode(!0)); return t ? (t.node || t).appendChild(i.node) : e.parentNode.insertBefore(i.node, e.nextSibling), i; },
      },
    }), a.extend(a.Element, {}), a.Gradient = a.invent({
      create(t) { this.constructor.call(this, a.create(`${t}Gradient`)), this.type = t; },
      inherit: a.Container,
      extend: {
        at(t, e, i) { return this.put(new a.Stop()).update(t, e, i); }, update(t) { return this.clear(), typeof t === 'function' && t.call(this, this), this; }, fill() { return `url(#${this.id()})`; }, toString() { return this.fill(); }, attr(t, e, i) { return t == 'transform' && (t = 'gradientTransform'), a.Container.prototype.attr.call(this, t, e, i); },
      },
      construct: { gradient(t, e) { return this.defs().gradient(t, e); } },
    }), a.extend(a.Gradient, a.FX, { from(t, e) { return (this._target || this).type == 'radial' ? this.attr({ fx: new a.Number(t), fy: new a.Number(e) }) : this.attr({ x1: new a.Number(t), y1: new a.Number(e) }); }, to(t, e) { return (this._target || this).type == 'radial' ? this.attr({ cx: new a.Number(t), cy: new a.Number(e) }) : this.attr({ x2: new a.Number(t), y2: new a.Number(e) }); } }), a.extend(a.Defs, { gradient(t, e) { return this.put(new a.Gradient(t)).update(e); } }), a.Stop = a.invent({ create: 'stop', inherit: a.Element, extend: { update(t) { return (typeof t === 'number' || t instanceof a.Number) && (t = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), t.opacity != null && this.attr('stop-opacity', t.opacity), t.color != null && this.attr('stop-color', t.color), t.offset != null && this.attr('offset', new a.Number(t.offset)), this; } } }), a.Pattern = a.invent({
      create: 'pattern',
      inherit: a.Container,
      extend: {
        fill() { return `url(#${this.id()})`; }, update(t) { return this.clear(), typeof t === 'function' && t.call(this, this), this; }, toString() { return this.fill(); }, attr(t, e, i) { return t == 'transform' && (t = 'patternTransform'), a.Container.prototype.attr.call(this, t, e, i); },
      },
      construct: { pattern(t, e, i) { return this.defs().pattern(t, e, i); } },
    }), a.extend(a.Defs, {
      pattern(t, e, i) {
        return this.put(new a.Pattern()).update(i).attr({
          x: 0, y: 0, width: t, height: e, patternUnits: 'userSpaceOnUse',
        });
      },
    }), a.Shape = a.invent({ create(t) { this.constructor.call(this, t); }, inherit: a.Element }), a.Symbol = a.invent({ create: 'symbol', inherit: a.Container, construct: { symbol() { return this.put(new a.Symbol()); } } }), a.Use = a.invent({
      create: 'use', inherit: a.Shape, extend: { element(t, e) { return this.attr('href', `${e || ''}#${t}`, a.xlink); } }, construct: { use(t, e) { return this.put(new a.Use()).element(t, e); } },
    }), a.Rect = a.invent({ create: 'rect', inherit: a.Shape, construct: { rect(t, e) { return this.put(new a.Rect()).size(t, e); } } }), a.Circle = a.invent({ create: 'circle', inherit: a.Shape, construct: { circle(t) { return this.put(new a.Circle()).rx(new a.Number(t).divide(2)).move(0, 0); } } }), a.extend(a.Circle, a.FX, { rx(t) { return this.attr('r', t); }, ry(t) { return this.rx(t); } }), a.Ellipse = a.invent({ create: 'ellipse', inherit: a.Shape, construct: { ellipse(t, e) { return this.put(new a.Ellipse()).size(t, e).move(0, 0); } } }), a.extend(a.Ellipse, a.Rect, a.FX, { rx(t) { return this.attr('rx', t); }, ry(t) { return this.attr('ry', t); } }), a.extend(a.Circle, a.Ellipse, {
      x(t) { return t == null ? this.cx() - this.rx() : this.cx(t + this.rx()); }, y(t) { return t == null ? this.cy() - this.ry() : this.cy(t + this.ry()); }, cx(t) { return t == null ? this.attr('cx') : this.attr('cx', t); }, cy(t) { return t == null ? this.attr('cy') : this.attr('cy', t); }, width(t) { return t == null ? 2 * this.rx() : this.rx(new a.Number(t).divide(2)); }, height(t) { return t == null ? 2 * this.ry() : this.ry(new a.Number(t).divide(2)); }, size(t, e) { const i = u(this, t, e); return this.rx(new a.Number(i.width).divide(2)).ry(new a.Number(i.height).divide(2)); },
    }), a.Line = a.invent({
      create: 'line',
      inherit: a.Shape,
      extend: {
        array() { return new a.PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]); },
        plot(t, e, i, s) {
          return t == null ? this.array() : (t = void 0 !== e ? {
            x1: t, y1: e, x2: i, y2: s,
          } : new a.PointArray(t).toLine(), this.attr(t));
        },
        move(t, e) { return this.attr(this.array().move(t, e).toLine()); },
        size(t, e) { const i = u(this, t, e); return this.attr(this.array().size(i.width, i.height).toLine()); },
      },
      construct: { line(t, e, i, s) { return a.Line.prototype.plot.apply(this.put(new a.Line()), t != null ? [t, e, i, s] : [0, 0, 0, 0]); } },
    }), a.Polyline = a.invent({ create: 'polyline', inherit: a.Shape, construct: { polyline(t) { return this.put(new a.Polyline()).plot(t || new a.PointArray()); } } }), a.Polygon = a.invent({ create: 'polygon', inherit: a.Shape, construct: { polygon(t) { return this.put(new a.Polygon()).plot(t || new a.PointArray()); } } }), a.extend(a.Polyline, a.Polygon, {
      array() { return this._array || (this._array = new a.PointArray(this.attr('points'))); }, plot(t) { return t == null ? this.array() : this.clear().attr('points', typeof t === 'string' ? t : this._array = new a.PointArray(t)); }, clear() { return delete this._array, this; }, move(t, e) { return this.attr('points', this.array().move(t, e)); }, size(t, e) { const i = u(this, t, e); return this.attr('points', this.array().size(i.width, i.height)); },
    }), a.extend(a.Line, a.Polyline, a.Polygon, {
      morphArray: a.PointArray, x(t) { return t == null ? this.bbox().x : this.move(t, this.bbox().y); }, y(t) { return t == null ? this.bbox().y : this.move(this.bbox().x, t); }, width(t) { const e = this.bbox(); return t == null ? e.width : this.size(t, e.height); }, height(t) { const e = this.bbox(); return t == null ? e.height : this.size(e.width, t); },
    }), a.Path = a.invent({
      create: 'path',
      inherit: a.Shape,
      extend: {
        morphArray: a.PathArray, array() { return this._array || (this._array = new a.PathArray(this.attr('d'))); }, plot(t) { return t == null ? this.array() : this.clear().attr('d', typeof t === 'string' ? t : this._array = new a.PathArray(t)); }, clear() { return delete this._array, this; },
      },
      construct: { path(t) { return this.put(new a.Path()).plot(t || new a.PathArray()); } },
    }), a.Image = a.invent({
      create: 'image',
      inherit: a.Shape,
      extend: {
        load(t) {
          if (!t) return this; const i = this; const s = new e.Image(); return a.on(s, 'load', (() => {
            a.off(s); const e = i.parent(a.Pattern); e !== null && (i.width() == 0 && i.height() == 0 && i.size(s.width, s.height), e && e.width() == 0 && e.height() == 0 && e.size(i.width(), i.height()), typeof i._loaded === 'function' && i._loaded.call(i, {
              width: s.width, height: s.height, ratio: s.width / s.height, url: t,
            }));
          })), a.on(s, 'error', ((t) => { a.off(s), typeof i._error === 'function' && i._error.call(i, t); })), this.attr('href', s.src = this.src = t, a.xlink);
        },
        loaded(t) { return this._loaded = t, this; },
        error(t) { return this._error = t, this; },
      },
      construct: { image(t, e, i) { return this.put(new a.Image()).load(t).size(e || 0, i || e || 0); } },
    }), a.Text = a.invent({
      create() { this.constructor.call(this, a.create('text')), this.dom.leading = new a.Number(1.3), this._rebuild = !0, this._build = !1, this.attr('font-family', a.defaults.attrs['font-family']); },
      inherit: a.Shape,
      extend: {
        x(t) { return t == null ? this.attr('x') : this.attr('x', t); }, text(t) { if (void 0 === t) { t = ''; for (var e = this.node.childNodes, i = 0, s = e.length; i < s; ++i)i != 0 && e[i].nodeType != 3 && a.adopt(e[i]).dom.newLined == 1 && (t += '\n'), t += e[i].textContent; return t; } if (this.clear().build(!0), typeof t === 'function')t.call(this, this); else { i = 0; for (let r = (t = t.split('\n')).length; i < r; i++) this.tspan(t[i]).newLine(); } return this.build(!1).rebuild(); }, size(t) { return this.attr('font-size', t).rebuild(); }, leading(t) { return t == null ? this.dom.leading : (this.dom.leading = new a.Number(t), this.rebuild()); }, lines() { const t = (this.textPath && this.textPath() || this).node; const e = a.utils.map(a.utils.filterSVGElements(t.childNodes), ((t) => a.adopt(t))); return new a.Set(e); }, rebuild(t) { if (typeof t === 'boolean' && (this._rebuild = t), this._rebuild) { const e = this; let i = 0; const s = this.dom.leading * new a.Number(this.attr('font-size')); this.lines().each((function () { this.dom.newLined && (e.textPath() || this.attr('x', e.attr('x')), this.text() == '\n' ? i += s : (this.attr('dy', s + i), i = 0)); })), this.fire('rebuild'); } return this; }, build(t) { return this._build = !!t, this; }, setData(t) { return this.dom = t, this.dom.leading = new a.Number(t.leading || 1.3), this; },
      },
      construct: { text(t) { return this.put(new a.Text()).text(t); }, plain(t) { return this.put(new a.Text()).plain(t); } },
    }), a.Tspan = a.invent({
      create: 'tspan',
      inherit: a.Shape,
      extend: {
        text(t) { return t == null ? this.node.textContent + (this.dom.newLined ? '\n' : '') : (typeof t === 'function' ? t.call(this, this) : this.plain(t), this); }, dx(t) { return this.attr('dx', t); }, dy(t) { return this.attr('dy', t); }, newLine() { const t = this.parent(a.Text); return this.dom.newLined = !0, this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x()); },
      },
    }), a.extend(a.Text, a.Tspan, {
      plain(t) { return !1 === this._build && this.clear(), this.node.appendChild(i.createTextNode(t)), this; }, tspan(t) { const e = (this.textPath && this.textPath() || this).node; const i = new a.Tspan(); return !1 === this._build && this.clear(), e.appendChild(i.node), i.text(t); }, clear() { for (let t = (this.textPath && this.textPath() || this).node; t.hasChildNodes();)t.removeChild(t.lastChild); return this; }, length() { return this.node.getComputedTextLength(); },
    }), a.TextPath = a.invent({
      create: 'textPath',
      inherit: a.Parent,
      parent: a.Text,
      construct: {
        morphArray: a.PathArray, array() { const t = this.track(); return t ? t.array() : null; }, plot(t) { const e = this.track(); let i = null; return e && (i = e.plot(t)), t == null ? i : this; }, track() { const t = this.textPath(); if (t) return t.reference('href'); }, textPath() { if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath') return a.adopt(this.node.firstChild); },
      },
    }), a.Nested = a.invent({ create() { this.constructor.call(this, a.create('svg')), this.style('overflow', 'visible'); }, inherit: a.Container, construct: { nested() { return this.put(new a.Nested()); } } }); const l = { stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'], fill: ['color', 'opacity', 'rule'], prefix(t, e) { return e == 'color' ? t : `${t}-${e}`; } }; function h(t, e, i, s) { return i + s.replace(a.regex.dots, ' .'); } function c(t) { return t.toLowerCase().replace(/-(.)/g, ((t, e) => e.toUpperCase())); } function d(t) { return t.charAt(0).toUpperCase() + t.slice(1); } function g(t) { const e = t.toString(16); return e.length == 1 ? `0${e}` : e; } function u(t, e, i) { if (e == null || i == null) { const a = t.bbox(); e == null ? e = a.width / a.height * i : i == null && (i = a.height / a.width * e); } return { width: e, height: i }; } function f(t, e, i) { return { x: e * t.a + i * t.c + 0, y: e * t.b + i * t.d + 0 }; } function p(t) {
      return {
        a: t[0], b: t[1], c: t[2], d: t[3], e: t[4], f: t[5],
      };
    } function x(t) { for (let i = t.childNodes.length - 1; i >= 0; i--)t.childNodes[i] instanceof e.SVGElement && x(t.childNodes[i]); return a.adopt(t).id(a.eid(t.nodeName)); } function b(t) { return t.x == null && (t.x = 0, t.y = 0, t.width = 0, t.height = 0), t.w = t.width, t.h = t.height, t.x2 = t.x + t.width, t.y2 = t.y + t.height, t.cx = t.x + t.width / 2, t.cy = t.y + t.height / 2, t; } function m(t) { return Math.abs(t) > 1e-37 ? t : 0; }['fill', 'stroke'].forEach(((t) => { let e; const i = {}; i[t] = function (i) { if (void 0 === i) return this; if (typeof i === 'string' || a.Color.isRgb(i) || i && typeof i.fill === 'function') this.attr(t, i); else for (e = l[t].length - 1; e >= 0; e--)i[l[t][e]] != null && this.attr(l.prefix(t, l[t][e]), i[l[t][e]]); return this; }, a.extend(a.Element, a.FX, i); })), a.extend(a.Element, a.FX, {
      translate(t, e) { return this.transform({ x: t, y: e }); }, matrix(t) { return this.attr('transform', new a.Matrix(arguments.length == 6 ? [].slice.call(arguments) : t)); }, opacity(t) { return this.attr('opacity', t); }, dx(t) { return this.x(new a.Number(t).plus(this instanceof a.FX ? 0 : this.x()), !0); }, dy(t) { return this.y(new a.Number(t).plus(this instanceof a.FX ? 0 : this.y()), !0); },
    }), a.extend(a.Path, { length() { return this.node.getTotalLength(); }, pointAt(t) { return this.node.getPointAtLength(t); } }), a.Set = a.invent({
      create(t) { Array.isArray(t) ? this.members = t : this.clear(); },
      extend: {
        add() { let t; let e; const i = [].slice.call(arguments); for (t = 0, e = i.length; t < e; t++) this.members.push(i[t]); return this; }, remove(t) { const e = this.index(t); return e > -1 && this.members.splice(e, 1), this; }, each(t) { for (let e = 0, i = this.members.length; e < i; e++)t.apply(this.members[e], [e, this.members]); return this; }, clear() { return this.members = [], this; }, length() { return this.members.length; }, has(t) { return this.index(t) >= 0; }, index(t) { return this.members.indexOf(t); }, get(t) { return this.members[t]; }, first() { return this.get(0); }, last() { return this.get(this.members.length - 1); }, valueOf() { return this.members; },
      },
      construct: { set(t) { return new a.Set(t); } },
    }), a.FX.Set = a.invent({ create(t) { this.set = t; } }), a.Set.inherit = function () { let t = []; for (var e in a.Shape.prototype) typeof a.Shape.prototype[e] === 'function' && typeof a.Set.prototype[e] !== 'function' && t.push(e); for (var e in t.forEach(((t) => { a.Set.prototype[t] = function () { for (let e = 0, i = this.members.length; e < i; e++) this.members[e] && typeof this.members[e][t] === 'function' && this.members[e][t].apply(this.members[e], arguments); return t == 'animate' ? this.fx || (this.fx = new a.FX.Set(this)) : this; }; })), t = [], a.FX.prototype) typeof a.FX.prototype[e] === 'function' && typeof a.FX.Set.prototype[e] !== 'function' && t.push(e); t.forEach(((t) => { a.FX.Set.prototype[t] = function () { for (let e = 0, i = this.set.members.length; e < i; e++) this.set.members[e].fx[t].apply(this.set.members[e].fx, arguments); return this; }; })); }, a.extend(a.Element, {}), a.extend(a.Element, { remember(e, i) { if (t(arguments[0]) === 'object') for (var i in e) this.remember(i, e[i]); else { if (arguments.length == 1) return this.memory()[e]; this.memory()[e] = i; } return this; }, forget() { if (arguments.length == 0) this._memory = {}; else for (let t = arguments.length - 1; t >= 0; t--) delete this.memory()[arguments[t]]; return this; }, memory() { return this._memory || (this._memory = {}); } }), a.get = function (t) { const e = i.getElementById((function (t) { const e = (t || '').toString().match(a.regex.reference); if (e) return e[1]; }(t)) || t); return a.adopt(e); }, a.select = function (t, e) { return new a.Set(a.utils.map((e || i).querySelectorAll(t), ((t) => a.adopt(t)))); }, a.extend(a.Parent, { select(t) { return a.select(t, this.node); } }); var v = 'abcdef'.split(''); if (typeof e.CustomEvent !== 'function') { const y = function (t, e) { e = e || { bubbles: !1, cancelable: !1, detail: void 0 }; const a = i.createEvent('CustomEvent'); return a.initCustomEvent(t, e.bubbles, e.cancelable, e.detail), a; }; y.prototype = e.Event.prototype, a.CustomEvent = y; } else a.CustomEvent = e.CustomEvent; return a;
  }, typeof define === 'function' && define.amd ? define((() => w(y, y.document))) : (typeof exports === 'undefined' ? 'undefined' : t(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = y.document ? w(y, y.document) : function (t) { return w(t, t.document); } : y.SVG = w(y, y.document),
  /*! svg.filter.js - v2.0.2 - 2016-02-24
  * https://github.com/wout/svg.filter.js
  * Copyright (c) 2016 Wout Fierens; Licensed MIT */
  function () {
    SVG.Filter = SVG.invent({
      create: 'filter',
      inherit: SVG.Parent,
      extend: {
        source: 'SourceGraphic', sourceAlpha: 'SourceAlpha', background: 'BackgroundImage', backgroundAlpha: 'BackgroundAlpha', fill: 'FillPaint', stroke: 'StrokePaint', autoSetIn: !0, put(t, e) { return this.add(t, e), !t.attr('in') && this.autoSetIn && t.attr('in', this.source), t.attr('result') || t.attr('result', t), t; }, blend(t, e, i) { return this.put(new SVG.BlendEffect(t, e, i)); }, colorMatrix(t, e) { return this.put(new SVG.ColorMatrixEffect(t, e)); }, convolveMatrix(t) { return this.put(new SVG.ConvolveMatrixEffect(t)); }, componentTransfer(t) { return this.put(new SVG.ComponentTransferEffect(t)); }, composite(t, e, i) { return this.put(new SVG.CompositeEffect(t, e, i)); }, flood(t, e) { return this.put(new SVG.FloodEffect(t, e)); }, offset(t, e) { return this.put(new SVG.OffsetEffect(t, e)); }, image(t) { return this.put(new SVG.ImageEffect(t)); }, merge() { const t = [void 0]; for (const e in arguments)t.push(arguments[e]); return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t))()); }, gaussianBlur(t, e) { return this.put(new SVG.GaussianBlurEffect(t, e)); }, morphology(t, e) { return this.put(new SVG.MorphologyEffect(t, e)); }, diffuseLighting(t, e, i) { return this.put(new SVG.DiffuseLightingEffect(t, e, i)); }, displacementMap(t, e, i, a, s) { return this.put(new SVG.DisplacementMapEffect(t, e, i, a, s)); }, specularLighting(t, e, i, a) { return this.put(new SVG.SpecularLightingEffect(t, e, i, a)); }, tile() { return this.put(new SVG.TileEffect()); }, turbulence(t, e, i, a, s) { return this.put(new SVG.TurbulenceEffect(t, e, i, a, s)); }, toString() { return `url(#${this.attr('id')})`; },
      },
    }), SVG.extend(SVG.Defs, { filter(t) { const e = this.put(new SVG.Filter()); return typeof t === 'function' && t.call(e, e), e; } }), SVG.extend(SVG.Container, { filter(t) { return this.defs().filter(t); } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter(t) { return this.filterer = t instanceof SVG.Element ? t : this.doc().filter(t), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr('filter', this.filterer), this.filterer; }, unfilter(t) { return this.filterer && !0 === t && this.filterer.remove(), delete this.filterer, this.attr('filter', null); } }), SVG.Effect = SVG.invent({ create() { this.constructor.call(this); }, inherit: SVG.Element, extend: { in(t) { return t == null ? this.parent() && this.parent().select(`[result="${this.attr('in')}"]`).get(0) || this.attr('in') : this.attr('in', t); }, result(t) { return t == null ? this.attr('result') : this.attr('result', t); }, toString() { return this.result(); } } }), SVG.ParentEffect = SVG.invent({ create() { this.constructor.call(this); }, inherit: SVG.Parent, extend: { in(t) { return t == null ? this.parent() && this.parent().select(`[result="${this.attr('in')}"]`).get(0) || this.attr('in') : this.attr('in', t); }, result(t) { return t == null ? this.attr('result') : this.attr('result', t); }, toString() { return this.result(); } } }); const t = {
      blend(t, e) { return this.parent() && this.parent().blend(this, t, e); }, colorMatrix(t, e) { return this.parent() && this.parent().colorMatrix(t, e).in(this); }, convolveMatrix(t) { return this.parent() && this.parent().convolveMatrix(t).in(this); }, componentTransfer(t) { return this.parent() && this.parent().componentTransfer(t).in(this); }, composite(t, e) { return this.parent() && this.parent().composite(this, t, e); }, flood(t, e) { return this.parent() && this.parent().flood(t, e); }, offset(t, e) { return this.parent() && this.parent().offset(t, e).in(this); }, image(t) { return this.parent() && this.parent().image(t); }, merge() { return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments)); }, gaussianBlur(t, e) { return this.parent() && this.parent().gaussianBlur(t, e).in(this); }, morphology(t, e) { return this.parent() && this.parent().morphology(t, e).in(this); }, diffuseLighting(t, e, i) { return this.parent() && this.parent().diffuseLighting(t, e, i).in(this); }, displacementMap(t, e, i, a) { return this.parent() && this.parent().displacementMap(this, t, e, i, a); }, specularLighting(t, e, i, a) { return this.parent() && this.parent().specularLighting(t, e, i, a).in(this); }, tile() { return this.parent() && this.parent().tile().in(this); }, turbulence(t, e, i, a, s) { return this.parent() && this.parent().turbulence(t, e, i, a, s).in(this); },
    }; SVG.extend(SVG.Effect, t), SVG.extend(SVG.ParentEffect, t), SVG.ChildEffect = SVG.invent({ create() { this.constructor.call(this); }, inherit: SVG.Element, extend: { in(t) { this.attr('in', t); } } }); const e = {
      blend(t, e, i) { this.attr({ in: t, in2: e, mode: i || 'normal' }); },
      colorMatrix(t, e) { t == 'matrix' && (e = s(e)), this.attr({ type: t, values: void 0 === e ? null : e }); },
      convolveMatrix(t) { t = s(t), this.attr({ order: Math.sqrt(t.split(' ').length), kernelMatrix: t }); },
      composite(t, e, i) { this.attr({ in: t, in2: e, operator: i }); },
      flood(t, e) { this.attr('flood-color', t), e != null && this.attr('flood-opacity', e); },
      offset(t, e) { this.attr({ dx: t, dy: e }); },
      image(t) { this.attr('href', t, SVG.xlink); },
      displacementMap(t, e, i, a, s) {
        this.attr({
          in: t, in2: e, scale: i, xChannelSelector: a, yChannelSelector: s,
        });
      },
      gaussianBlur(t, e) { t != null || e != null ? this.attr('stdDeviation', r(Array.prototype.slice.call(arguments))) : this.attr('stdDeviation', '0 0'); },
      morphology(t, e) { this.attr({ operator: t, radius: e }); },
      tile() {},
      turbulence(t, e, i, a, s) {
        this.attr({
          numOctaves: e, seed: i, stitchTiles: a, baseFrequency: t, type: s,
        });
      },
    }; const i = {
      merge() { let t; if (arguments[0] instanceof SVG.Set) { const e = this; arguments[0].each((function (t) { this instanceof SVG.MergeNode ? e.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e.put(new SVG.MergeNode(this)); })); } else { t = Array.isArray(arguments[0]) ? arguments[0] : arguments; for (let i = 0; i < t.length; i++)t[i] instanceof SVG.MergeNode ? this.put(t[i]) : this.put(new SVG.MergeNode(t[i])); } },
      componentTransfer(t) { if (this.rgb = new SVG.Set(), ['r', 'g', 'b', 'a'].forEach((t) => { this[t] = new (SVG[`Func${t.toUpperCase()}`])('identity'), this.rgb.add(this[t]), this.node.appendChild(this[t].node); }), t) for (const e in t.rgb && (['r', 'g', 'b'].forEach((e) => { this[e].attr(t.rgb); }), delete t.rgb), t) this[e].attr(t[e]); },
      diffuseLighting(t, e, i) { this.attr({ surfaceScale: t, diffuseConstant: e, kernelUnitLength: i }); },
      specularLighting(t, e, i, a) {
        this.attr({
          surfaceScale: t, diffuseConstant: e, specularExponent: i, kernelUnitLength: a,
        });
      },
    }; const a = {
      distantLight(t, e) { this.attr({ azimuth: t, elevation: e }); },
      pointLight(t, e, i) { this.attr({ x: t, y: e, z: i }); },
      spotLight(t, e, i, a, s, r) {
        this.attr({
          x: t, y: e, z: i, pointsAtX: a, pointsAtY: s, pointsAtZ: r,
        });
      },
      mergeNode(t) { this.attr('in', t); },
    }; function s(t) { return Array.isArray(t) && (t = new SVG.Array(t)), t.toString().replace(/^\s+/, '').replace(/\s+$/, '').replace(/\s+/g, ' '); } function r(t) { if (!Array.isArray(t)) return t; for (var e = 0, i = t.length, a = []; e < i; e++)a.push(t[e]); return a.join(' '); } function n() { let t = function () {}; for (const e in typeof arguments[arguments.length - 1] === 'function' && (t = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments) for (const i in arguments[e])t(arguments[e][i], i, arguments[e]); }['r', 'g', 'b', 'a'].forEach(((t) => { a[`Func${t.toUpperCase()}`] = function (t) { switch (this.attr('type', t), t) { case 'table': this.attr('tableValues', arguments[1]); break; case 'linear': this.attr('slope', arguments[1]), this.attr('intercept', arguments[2]); break; case 'gamma': this.attr('amplitude', arguments[1]), this.attr('exponent', arguments[2]), this.attr('offset', arguments[2]); } }; })), n(e, ((t, e) => { const i = e.charAt(0).toUpperCase() + e.slice(1); SVG[`${i}Effect`] = SVG.invent({ create() { this.constructor.call(this, SVG.create(`fe${i}`)), t.apply(this, arguments), this.result(`${this.attr('id')}Out`); }, inherit: SVG.Effect, extend: {} }); })), n(i, ((t, e) => { const i = e.charAt(0).toUpperCase() + e.slice(1); SVG[`${i}Effect`] = SVG.invent({ create() { this.constructor.call(this, SVG.create(`fe${i}`)), t.apply(this, arguments), this.result(`${this.attr('id')}Out`); }, inherit: SVG.ParentEffect, extend: {} }); })), n(a, ((t, e) => { const i = e.charAt(0).toUpperCase() + e.slice(1); SVG[i] = SVG.invent({ create() { this.constructor.call(this, SVG.create(`fe${i}`)), t.apply(this, arguments); }, inherit: SVG.ChildEffect, extend: {} }); })), SVG.extend(SVG.MergeEffect, { in(t) { return t instanceof SVG.MergeNode ? this.add(t, 0) : this.add(new SVG.MergeNode(t), 0), this; } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2(t) { return t == null ? this.parent() && this.parent().select(`[result="${this.attr('in2')}"]`).get(0) || this.attr('in2') : this.attr('in2', t); } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
  }.call(void 0), (function () { function t(t, s, r, n, o, l, h) { for (var c = t.slice(s, r || h), d = n.slice(o, l || h), g = 0, u = { pos: [0, 0], start: [0, 0] }, f = { pos: [0, 0], start: [0, 0] }; ;) { if (c[g] = e.call(u, c[g]), d[g] = e.call(f, d[g]), c[g][0] != d[g][0] || c[g][0] == 'M' || c[g][0] == 'A' && (c[g][4] != d[g][4] || c[g][5] != d[g][5]) ? (Array.prototype.splice.apply(c, [g, 1].concat(a.call(u, c[g]))), Array.prototype.splice.apply(d, [g, 1].concat(a.call(f, d[g])))) : (c[g] = i.call(u, c[g]), d[g] = i.call(f, d[g])), ++g == c.length && g == d.length) break; g == c.length && c.push(['C', u.pos[0], u.pos[1], u.pos[0], u.pos[1], u.pos[0], u.pos[1]]), g == d.length && d.push(['C', f.pos[0], f.pos[1], f.pos[0], f.pos[1], f.pos[0], f.pos[1]]); } return { start: c, dest: d }; } function e(t) { switch (t[0]) { case 'z': case 'Z': t[0] = 'L', t[1] = this.start[0], t[2] = this.start[1]; break; case 'H': t[0] = 'L', t[2] = this.pos[1]; break; case 'V': t[0] = 'L', t[2] = t[1], t[1] = this.pos[0]; break; case 'T': t[0] = 'Q', t[3] = t[1], t[4] = t[2], t[1] = this.reflection[1], t[2] = this.reflection[0]; break; case 'S': t[0] = 'C', t[6] = t[4], t[5] = t[3], t[4] = t[2], t[3] = t[1], t[2] = this.reflection[1], t[1] = this.reflection[0]; } return t; } function i(t) { const e = t.length; return this.pos = [t[e - 2], t[e - 1]], 'SCQT'.indexOf(t[0]) != -1 && (this.reflection = [2 * this.pos[0] - t[e - 4], 2 * this.pos[1] - t[e - 3]]), t; } function a(t) { let e = [t]; switch (t[0]) { case 'M': return this.pos = this.start = [t[1], t[2]], e; case 'L': t[5] = t[3] = t[1], t[6] = t[4] = t[2], t[1] = this.pos[0], t[2] = this.pos[1]; break; case 'Q': t[6] = t[4], t[5] = t[3], t[4] = 1 * t[4] / 3 + 2 * t[2] / 3, t[3] = 1 * t[3] / 3 + 2 * t[1] / 3, t[2] = 1 * this.pos[1] / 3 + 2 * t[2] / 3, t[1] = 1 * this.pos[0] / 3 + 2 * t[1] / 3; break; case 'A': t = (e = (function (t, e) { let i; let a; let s; let r; let n; let o; let l; let h; let c; let d; let g; let u; let f; let p; let x; let b; let m; let v; let y; let w; let k; let A; let S; let C; let L; let P; let T = Math.abs(e[1]); let z = Math.abs(e[2]); const I = e[3] % 360; const M = e[4]; const X = e[5]; let E = e[6]; let Y = e[7]; let F = new SVG.Point(t); let D = new SVG.Point(E, Y); const R = []; if (T === 0 || z === 0 || F.x === D.x && F.y === D.y) return [['C', F.x, F.y, D.x, D.y, D.x, D.y]]; i = new SVG.Point((F.x - D.x) / 2, (F.y - D.y) / 2).transform((new SVG.Matrix()).rotate(I)), (a = i.x * i.x / (T * T) + i.y * i.y / (z * z)) > 1 && (a = Math.sqrt(a), T *= a, z *= a); s = (new SVG.Matrix()).rotate(I).scale(1 / T, 1 / z).rotate(-I), F = F.transform(s), D = D.transform(s), r = [D.x - F.x, D.y - F.y], o = r[0] * r[0] + r[1] * r[1], n = Math.sqrt(o), r[0] /= n, r[1] /= n, l = o < 4 ? Math.sqrt(1 - o / 4) : 0, M === X && (l *= -1); h = new SVG.Point((D.x + F.x) / 2 + l * -r[1], (D.y + F.y) / 2 + l * r[0]), c = new SVG.Point(F.x - h.x, F.y - h.y), d = new SVG.Point(D.x - h.x, D.y - h.y), g = Math.acos(c.x / Math.sqrt(c.x * c.x + c.y * c.y)), c.y < 0 && (g *= -1); u = Math.acos(d.x / Math.sqrt(d.x * d.x + d.y * d.y)), d.y < 0 && (u *= -1); X && g > u && (u += 2 * Math.PI); !X && g < u && (u -= 2 * Math.PI); for (p = Math.ceil(2 * Math.abs(g - u) / Math.PI), b = [], m = g, f = (u - g) / p, x = 4 * Math.tan(f / 4) / 3, k = 0; k <= p; k++)y = Math.cos(m), v = Math.sin(m), w = new SVG.Point(h.x + y, h.y + v), b[k] = [new SVG.Point(w.x + x * v, w.y - x * y), w, new SVG.Point(w.x - x * v, w.y + x * y)], m += f; for (b[0][0] = b[0][1].clone(), b[b.length - 1][2] = b[b.length - 1][1].clone(), s = (new SVG.Matrix()).rotate(I).scale(T, z).rotate(-I), k = 0, A = b.length; k < A; k++)b[k][0] = b[k][0].transform(s), b[k][1] = b[k][1].transform(s), b[k][2] = b[k][2].transform(s); for (k = 1, A = b.length; k < A; k++)w = b[k - 1][2], S = w.x, C = w.y, w = b[k][0], L = w.x, P = w.y, w = b[k][1], E = w.x, Y = w.y, R.push(['C', S, C, L, P, E, Y]); return R; }(this.pos, t)))[0]; } return t[0] = 'C', this.pos = [t[5], t[6]], this.reflection = [2 * t[5] - t[3], 2 * t[6] - t[4]], e; } function s(t, e) { if (!1 === e) return !1; for (let i = e, a = t.length; i < a; ++i) if (t[i][0] == 'M') return i; return !1; }SVG.extend(SVG.PathArray, { morph(e) { for (var i = this.value, a = this.parse(e), r = 0, n = 0, o = !1, l = !1; !1 !== r || !1 !== n;) { var h; o = s(i, !1 !== r && r + 1), l = s(a, !1 !== n && n + 1), !1 === r && (r = (h = new SVG.PathArray(c.start).bbox()).height == 0 || h.width == 0 ? i.push(i[0]) - 1 : i.push(['M', h.x + h.width / 2, h.y + h.height / 2]) - 1), !1 === n && (n = (h = new SVG.PathArray(c.dest).bbox()).height == 0 || h.width == 0 ? a.push(a[0]) - 1 : a.push(['M', h.x + h.width / 2, h.y + h.height / 2]) - 1); var c = t(i, r, o, a, n, l); i = i.slice(0, r).concat(c.start, !1 === o ? [] : i.slice(o)), a = a.slice(0, n).concat(c.dest, !1 === l ? [] : a.slice(l)), r = !1 !== o && r + c.start.length, n = !1 !== l && n + c.dest.length; } return this.value = i, this.destination = new SVG.PathArray(), this.destination.value = a, this; } }); }()),
  /*! svg.draggable.js - v2.2.2 - 2019-01-08
  * https://github.com/svgdotjs/svg.draggable.js
  * Copyright (c) 2019 Wout Fierens; Licensed MIT */
  function () {
    function t(t) { t.remember('_draggable', this), this.el = t; }t.prototype.init = function (t, e) { const i = this; this.constraint = t, this.value = e, this.el.on('mousedown.drag', ((t) => { i.start(t); })), this.el.on('touchstart.drag', ((t) => { i.start(t); })); }, t.prototype.transformPoint = function (t, e) { const i = (t = t || window.event).changedTouches && t.changedTouches[0] || t; return this.p.x = i.clientX - (e || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m); }, t.prototype.getBBox = function () { let t = this.el.bbox(); return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t; }, t.prototype.start = function (t) {
      if (t.type != 'click' && t.type != 'mousedown' && t.type != 'mousemove' || (t.which || t.buttons) == 1) {
        const e = this; if (this.el.fire('beforedrag', { event: t, handler: this }), !this.el.event().defaultPrevented) {
          t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse(); let i; const a = this.getBBox(); if (this.el instanceof SVG.Text) switch (i = this.el.node.getComputedTextLength(), this.el.attr('text-anchor')) { case 'middle': i /= 2; break; case 'start': i = 0; } this.startPoints = { point: this.transformPoint(t, i), box: a, transform: this.el.transform() }, SVG.on(window, 'mousemove.drag', ((t) => { e.drag(t); })), SVG.on(window, 'touchmove.drag', ((t) => { e.drag(t); })), SVG.on(window, 'mouseup.drag', ((t) => { e.end(t); })), SVG.on(window, 'touchend.drag', ((t) => { e.end(t); })), this.el.fire('dragstart', {
            event: t, p: this.startPoints.point, m: this.m, handler: this,
          });
        }
      }
    }, t.prototype.drag = function (t) {
      const e = this.getBBox(); const i = this.transformPoint(t); let a = this.startPoints.box.x + i.x - this.startPoints.point.x; let s = this.startPoints.box.y + i.y - this.startPoints.point.y; const r = this.constraint; let n = i.x - this.startPoints.point.x; let o = i.y - this.startPoints.point.y; if (this.el.fire('dragmove', {
        event: t, p: i, m: this.m, handler: this,
      }), this.el.event().defaultPrevented) return i; if (typeof r === 'function') { let l = r.call(this.el, a, s, this.m); typeof l === 'boolean' && (l = { x: l, y: l }), !0 === l.x ? this.el.x(a) : !1 !== l.x && this.el.x(l.x), !0 === l.y ? this.el.y(s) : !1 !== l.y && this.el.y(l.y); } else typeof r === 'object' && (r.minX != null && a < r.minX ? n = (a = r.minX) - this.startPoints.box.x : r.maxX != null && a > r.maxX - e.width && (n = (a = r.maxX - e.width) - this.startPoints.box.x), r.minY != null && s < r.minY ? o = (s = r.minY) - this.startPoints.box.y : r.maxY != null && s > r.maxY - e.height && (o = (s = r.maxY - e.height) - this.startPoints.box.y), r.snapToGrid != null && (a -= a % r.snapToGrid, s -= s % r.snapToGrid, n -= n % r.snapToGrid, o -= o % r.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: n, y: o }, !0) : this.el.move(a, s)); return i;
    }, t.prototype.end = function (t) {
      const e = this.drag(t); this.el.fire('dragend', {
        event: t, p: e, m: this.m, handler: this,
      }), SVG.off(window, 'mousemove.drag'), SVG.off(window, 'touchmove.drag'), SVG.off(window, 'mouseup.drag'), SVG.off(window, 'touchend.drag');
    }, SVG.extend(SVG.Element, { draggable(e, i) { typeof e !== 'function' && typeof e !== 'object' || (i = e, e = !0); const a = this.remember('_draggable') || new t(this); return (e = void 0 === e || e) ? a.init(i || {}, e) : (this.off('mousedown.drag'), this.off('touchstart.drag')), this; } });
  }.call(void 0), (function () {
    function t(t) { this.el = t, t.remember('_selectHandler', this), this.pointSelection = { isSelected: !1 }, this.rectSelection = { isSelected: !1 }; }t.prototype.init = function (t, e) { const i = this.el.bbox(); for (const a in this.options = {}, this.el.selectize.defaults) this.options[a] = this.el.selectize.defaults[a], void 0 !== e[a] && (this.options[a] = e[a]); this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && ['line', 'polyline', 'polygon'].indexOf(this.el.type) !== -1 ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup(); }, t.prototype.selectPoints = function (t) { return this.pointSelection.isSelected = t, this.pointSelection.set ? this : (this.pointSelection.set = this.parent.set(), this.drawCircles(), this); }, t.prototype.getPointArray = function () { const t = this.el.bbox(); return this.el.array().valueOf().map(((e) => [e[0] - t.x, e[1] - t.y])); }, t.prototype.drawCircles = function () {
      for (var t = this, e = this.getPointArray(), i = 0, a = e.length; i < a; ++i) {
        const s = (function (e) {
          return function (i) {
            (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation(); const a = i.pageX || i.touches[0].pageX; const s = i.pageY || i.touches[0].pageY; t.el.fire('point', {
              x: a, y: s, i: e, event: i,
            });
          };
        }(i)); this.pointSelection.set.add(this.nested.circle(this.options.radius).center(e[i][0], e[i][1]).addClass(this.options.classPoints).addClass(`${this.options.classPoints}_point`)
          .on('touchstart', s)
          .on('mousedown', s));
      }
    }, t.prototype.updatePointSelection = function () { const t = this.getPointArray(); this.pointSelection.set.each((function (e) { this.cx() === t[e][0] && this.cy() === t[e][1] || this.center(t[e][0], t[e][1]); })); }, t.prototype.updateRectSelection = function () { const t = this.el.bbox(); this.rectSelection.set.get(0).attr({ width: t.width, height: t.height }), this.options.points && (this.rectSelection.set.get(2).center(t.width, 0), this.rectSelection.set.get(3).center(t.width, t.height), this.rectSelection.set.get(4).center(0, t.height), this.rectSelection.set.get(5).center(t.width / 2, 0), this.rectSelection.set.get(6).center(t.width, t.height / 2), this.rectSelection.set.get(7).center(t.width / 2, t.height), this.rectSelection.set.get(8).center(0, t.height / 2)), this.options.rotationPoint && (this.options.points ? this.rectSelection.set.get(9).center(t.width / 2, 20) : this.rectSelection.set.get(1).center(t.width / 2, 20)); }, t.prototype.selectRect = function (t) {
      const e = this; const i = this.el.bbox(); function a(t) { return function (i) { (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation(); const a = i.pageX || i.touches[0].pageX; const s = i.pageY || i.touches[0].pageY; e.el.fire(t, { x: a, y: s, event: i }); }; } if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points && !this.rectSelection.set.get(1)) {
        const s = 'touchstart'; const r = 'mousedown'; this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, 0).attr('class', `${this.options.classPoints}_lt`).on(r, a('lt'))
          .on(s, a('lt'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width, 0).attr('class', `${this.options.classPoints}_rt`).on(r, a('rt'))
          .on(s, a('rt'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width, i.height).attr('class', `${this.options.classPoints}_rb`).on(r, a('rb'))
          .on(s, a('rb'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, i.height).attr('class', `${this.options.classPoints}_lb`).on(r, a('lb'))
          .on(s, a('lb'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width / 2, 0).attr('class', `${this.options.classPoints}_t`).on(r, a('t'))
          .on(s, a('t'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width, i.height / 2).attr('class', `${this.options.classPoints}_r`).on(r, a('r'))
          .on(s, a('r'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width / 2, i.height).attr('class', `${this.options.classPoints}_b`).on(r, a('b'))
          .on(s, a('b'))), this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, i.height / 2).attr('class', `${this.options.classPoints}_l`).on(r, a('l'))
          .on(s, a('l'))), this.rectSelection.set.each((function () { this.addClass(e.options.classPoints); }));
      } if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
        const n = function (t) { (t = t || window.event).preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation(); const i = t.pageX || t.touches[0].pageX; const a = t.pageY || t.touches[0].pageY; e.el.fire('rot', { x: i, y: a, event: t }); }; this.rectSelection.set.add(this.nested.circle(this.options.radius).center(i.width / 2, 20).attr('class', `${this.options.classPoints}_rot`).on('touchstart', n)
          .on('mousedown', n));
      }
    }, t.prototype.handler = function () { const t = this.el.bbox(); this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection(); }, t.prototype.observe = function () { const t = this; if (MutationObserver) if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(((() => { t.handler(); }))), this.observerInst.observe(this.el.node, { attributes: !0 }); else try { this.observerInst.disconnect(), delete this.observerInst; } catch (t) {} else this.el.off('DOMAttrModified.select'), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on('DOMAttrModified.select', (() => { t.handler(); })); }, t.prototype.cleanup = function () { !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each((function () { this.remove(); })), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each((function () { this.remove(); })), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested); }, SVG.extend(SVG.Element, { selectize(e, i) { return typeof e === 'object' && (i = e, e = !0), (this.remember('_selectHandler') || new t(this)).init(void 0 === e || e, i || {}), this; } }), SVG.Element.prototype.selectize.defaults = {
      points: !0, classRect: 'svg_select_boundingRect', classPoints: 'svg_select_points', radius: 7, rotationPoint: !0, deepSelect: !1,
    };
  }()), (function () {
    (function () {
      function t(t) { t.remember('_resizeHandler', this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint(); }t.prototype.transformPoint = function (t, e, i) { return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = e - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m); }, t.prototype._extractPosition = function (t) { return { x: t.clientX != null ? t.clientX : t.touches[0].clientX, y: t.clientY != null ? t.clientY : t.touches[0].clientY }; }, t.prototype.init = function (t) { const e = this; if (this.stop(), t !== 'stop') { for (const i in this.options = {}, this.el.resize.defaults) this.options[i] = this.el.resize.defaults[i], void 0 !== t[i] && (this.options[i] = t[i]); this.el.on('lt.resize', ((t) => { e.resize(t || window.event); })), this.el.on('rt.resize', ((t) => { e.resize(t || window.event); })), this.el.on('rb.resize', ((t) => { e.resize(t || window.event); })), this.el.on('lb.resize', ((t) => { e.resize(t || window.event); })), this.el.on('t.resize', ((t) => { e.resize(t || window.event); })), this.el.on('r.resize', ((t) => { e.resize(t || window.event); })), this.el.on('b.resize', ((t) => { e.resize(t || window.event); })), this.el.on('l.resize', ((t) => { e.resize(t || window.event); })), this.el.on('rot.resize', ((t) => { e.resize(t || window.event); })), this.el.on('point.resize', ((t) => { e.resize(t || window.event); })), this.update(); } }, t.prototype.stop = function () { return this.el.off('lt.resize'), this.el.off('rt.resize'), this.el.off('rb.resize'), this.el.off('lb.resize'), this.el.off('t.resize'), this.el.off('r.resize'), this.el.off('b.resize'), this.el.off('l.resize'), this.el.off('rot.resize'), this.el.off('point.resize'), this; }, t.prototype.resize = function (t) {
        const e = this; this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset }; const i = this._extractPosition(t.detail.event); if (this.parameters = {
          type: this.el.type, p: this.transformPoint(i.x, i.y), x: t.detail.x, y: t.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation,
        }, this.el.type === 'text' && (this.parameters.fontSize = this.el.attr()['font-size']), void 0 !== t.detail.i) { const a = this.el.array().valueOf(); this.parameters.i = t.detail.i, this.parameters.pointCoords = [a[t.detail.i][0], a[t.detail.i][1]]; } switch (t.type) { case 'lt': this.calc = function (t, e) { let i = this.snapToGrid(t, e); if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height - i[1] > 0) { if (this.parameters.type === 'text') return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr('font-size', this.parameters.fontSize - i[0]); i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y + i[1]).size(this.parameters.box.width - i[0], this.parameters.box.height - i[1]); } }; break; case 'rt': this.calc = function (t, e) { let i = this.snapToGrid(t, e, 2); if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height - i[1] > 0) { if (this.parameters.type === 'text') return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr('font-size', this.parameters.fontSize + i[0]); i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).size(this.parameters.box.width + i[0], this.parameters.box.height - i[1]); } }; break; case 'rb': this.calc = function (t, e) { let i = this.snapToGrid(t, e, 0); if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height + i[1] > 0) { if (this.parameters.type === 'text') return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr('font-size', this.parameters.fontSize + i[0]); i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i[0], this.parameters.box.height + i[1]); } }; break; case 'lb': this.calc = function (t, e) { let i = this.snapToGrid(t, e, 1); if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height + i[1] > 0) { if (this.parameters.type === 'text') return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr('font-size', this.parameters.fontSize - i[0]); i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).size(this.parameters.box.width - i[0], this.parameters.box.height + i[1]); } }; break; case 't': this.calc = function (t, e) { const i = this.snapToGrid(t, e, 2); if (this.parameters.box.height - i[1] > 0) { if (this.parameters.type === 'text') return; this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).height(this.parameters.box.height - i[1]); } }; break; case 'r': this.calc = function (t, e) { const i = this.snapToGrid(t, e, 0); if (this.parameters.box.width + i[0] > 0) { if (this.parameters.type === 'text') return; this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i[0]); } }; break; case 'b': this.calc = function (t, e) { const i = this.snapToGrid(t, e, 0); if (this.parameters.box.height + i[1] > 0) { if (this.parameters.type === 'text') return; this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i[1]); } }; break; case 'l': this.calc = function (t, e) { const i = this.snapToGrid(t, e, 1); if (this.parameters.box.width - i[0] > 0) { if (this.parameters.type === 'text') return; this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).width(this.parameters.box.width - i[0]); } }; break; case 'rot': this.calc = function (t, e) { const i = t + this.parameters.p.x; const a = e + this.parameters.p.y; const s = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2); const r = Math.atan2(a - this.parameters.box.y - this.parameters.box.height / 2, i - this.parameters.box.x - this.parameters.box.width / 2); const n = this.parameters.rotation + 180 * (r - s) / Math.PI + this.options.snapToAngle / 2; this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(n - n % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy); }; break; case 'point': this.calc = function (t, e) { const i = this.snapToGrid(t, e, this.parameters.pointCoords[0], this.parameters.pointCoords[1]); const a = this.el.array().valueOf(); a[this.parameters.i][0] = this.parameters.pointCoords[0] + i[0], a[this.parameters.i][1] = this.parameters.pointCoords[1] + i[1], this.el.plot(a); }; } this.el.fire('resizestart', { dx: this.parameters.x, dy: this.parameters.y, event: t }), SVG.on(window, 'touchmove.resize', ((t) => { e.update(t || window.event); })), SVG.on(window, 'touchend.resize', (() => { e.done(); })), SVG.on(window, 'mousemove.resize', ((t) => { e.update(t || window.event); })), SVG.on(window, 'mouseup.resize', (() => { e.done(); }));
      }, t.prototype.update = function (t) { if (t) { const e = this._extractPosition(t); const i = this.transformPoint(e.x, e.y); const a = i.x - this.parameters.p.x; const s = i.y - this.parameters.p.y; this.lastUpdateCall = [a, s], this.calc(a, s), this.el.fire('resizing', { dx: a, dy: s, event: t }); } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]); }, t.prototype.done = function () { this.lastUpdateCall = null, SVG.off(window, 'mousemove.resize'), SVG.off(window, 'mouseup.resize'), SVG.off(window, 'touchmove.resize'), SVG.off(window, 'touchend.resize'), this.el.fire('resizedone'); }, t.prototype.snapToGrid = function (t, e, i, a) { let s; return void 0 !== a ? s = [(i + t) % this.options.snapToGrid, (a + e) % this.options.snapToGrid] : (i = i == null ? 3 : i, s = [(this.parameters.box.x + t + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t < 0 && (s[0] -= this.options.snapToGrid), e < 0 && (s[1] -= this.options.snapToGrid), t -= Math.abs(s[0]) < this.options.snapToGrid / 2 ? s[0] : s[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e -= Math.abs(s[1]) < this.options.snapToGrid / 2 ? s[1] : s[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, e, i, a); }, t.prototype.constraintToBox = function (t, e, i, a) { let s; let r; const n = this.options.constraint || {}; return void 0 !== a ? (s = i, r = a) : (s = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), r = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), void 0 !== n.minX && s + t < n.minX && (t = n.minX - s), void 0 !== n.maxX && s + t > n.maxX && (t = n.maxX - s), void 0 !== n.minY && r + e < n.minY && (e = n.minY - r), void 0 !== n.maxY && r + e > n.maxY && (e = n.maxY - r), [t, e]; }, t.prototype.checkAspectRatio = function (t, e) { if (!this.options.saveAspectRatio) return t; const i = t.slice(); const a = this.parameters.box.width / this.parameters.box.height; const s = this.parameters.box.width + t[0]; const r = this.parameters.box.height - t[1]; const n = s / r; return n < a ? (i[1] = s / a - this.parameters.box.height, e && (i[1] = -i[1])) : n > a && (i[0] = this.parameters.box.width - r * a, e && (i[0] = -i[0])), i; }, SVG.extend(SVG.Element, { resize(e) { return (this.remember('_resizeHandler') || new t(this)).init(e || {}), this; } }), SVG.Element.prototype.resize.defaults = {
        snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: !1,
      };
    }).call(this);
  }()); !(function (t, e) { void 0 === e && (e = {}); const i = e.insertAt; if (t && typeof document !== 'undefined') { const a = document.head || document.getElementsByTagName('head')[0]; const s = document.createElement('style'); s.type = 'text/css', i === 'top' && a.firstChild ? a.insertBefore(s, a.firstChild) : a.appendChild(s), s.styleSheet ? s.styleSheet.cssText = t : s.appendChild(document.createTextNode(t)); } }('.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5);\n}\n.apexcharts-canvas.apexcharts-theme-dark {\n  background: #343F57;\n}\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-gridline, .apexcharts-annotation-rect {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30,30,30, 0.8);\n}\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n.apexcharts-tooltip-series-group.apexcharts-active, .apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n.apexcharts-tooltip-candlestick {\n  padding: 4px 8px;\n}\n.apexcharts-tooltip-candlestick > div {\n  margin: 4px 0;\n}\n.apexcharts-tooltip-candlestick span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after, .apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after, .apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after, .apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color:#ECEFF1\n}\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color:rgba(0, 0, 0, 0.5);\n}\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after, .apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after, .apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after, .apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs, .apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active, .apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-zoom-rect {\n  pointer-events: none;\n}\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_points, .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n.svg_select_points_l, .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n  fill: #888;\n}\n.apexcharts-canvas.apexcharts-zoomable .hovering-zoom {\n  cursor: crosshair\n}\n.apexcharts-canvas.apexcharts-zoomable .hovering-pan {\n  cursor: move\n}\n\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg{\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon, .apexcharts-menu-icon {\n  position: relative;\n}\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n.apexcharts-zoom-icon, .apexcharts-reset-icon, .apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon, .apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  top: 0px;\n  right: 3px;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-toolbar svg {\n  pointer-events: none;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels, .apexcharts-datalabel, .apexcharts-datalabel-label, .apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events, .apexcharts-radar-series path, .apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n/* Resize generated styles */\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers, .resize-triggers > div, .contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers > div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}\n')), (function () { function t(t) { const e = t.__resizeTriggers__; const i = e.firstElementChild; const a = e.lastElementChild; const s = i ? i.firstElementChild : null; a && (a.scrollLeft = a.scrollWidth, a.scrollTop = a.scrollHeight), s && (s.style.width = `${i.offsetWidth + 1}px`, s.style.height = `${i.offsetHeight + 1}px`), i && (i.scrollLeft = i.scrollWidth, i.scrollTop = i.scrollHeight); } function e(e) { const i = this; t(this), this.__resizeRAF__ && r(this.__resizeRAF__), this.__resizeRAF__ = s((() => { (function (t) { return t.offsetWidth != t.__resizeLast__.width || t.offsetHeight != t.__resizeLast__.height; }(i)) && (i.__resizeLast__.width = i.offsetWidth, i.__resizeLast__.height = i.offsetHeight, i.__resizeListeners__.forEach(((t) => { t.call(e); }))); })); } let i; let a; var s = (i = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (t) { return window.setTimeout(t, 20); }, function (t) { return i(t); }); var r = (a = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout, function (t) { return a(t); }); let n = !1; let o = 'animationstart'; const l = 'Webkit Moz O ms'.split(' '); const h = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '); const c = document.createElement('fakeelement'); if (void 0 !== c.style.animationName && (n = !0), !1 === n) for (let d = 0; d < l.length; d++) if (void 0 !== c.style[`${l[d]}AnimationName`]) { o = h[d]; break; }window.addResizeListener = function (i, a) { i.__resizeTriggers__ || (getComputedStyle(i).position == 'static' && (i.style.position = 'relative'), i.__resizeLast__ = {}, i.__resizeListeners__ = [], (i.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers', i.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', i.appendChild(i.__resizeTriggers__), t(i), i.addEventListener('scroll', e, !0), o && i.__resizeTriggers__.addEventListener(o, ((e) => { e.animationName == 'resizeanim' && t(i); }))), i.__resizeListeners__.push(a); }, window.removeResizeListener = function (t, i) { t && (t.__resizeListeners__.splice(t.__resizeListeners__.indexOf(i), 1), t.__resizeListeners__.length || (t.removeEventListener('scroll', e), t.__resizeTriggers__.parentNode && (t.__resizeTriggers__ = !t.removeChild(t.__resizeTriggers__)))); }; }()), window.Apex = {}; const zt = (function () { function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'initModules', value() { this.ctx.publicMethods = ['updateOptions', 'updateSeries', 'appendData', 'appendSeries', 'toggleSeries', 'showSeries', 'hideSeries', 'setLocale', 'resetSeries', 'toggleDataPointSelection', 'dataURI', 'addXaxisAnnotation', 'addYaxisAnnotation', 'addPointAnnotation', 'addText', 'addImage', 'clearAnnotations', 'removeAnnotation', 'paper', 'destroy'], this.ctx.eventList = ['click', 'mousedown', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'], this.ctx.animations = new f(this.ctx), this.ctx.axes = new U(this.ctx), this.ctx.core = new Pt(this.ctx.el, this.ctx), this.ctx.data = new D(this.ctx), this.ctx.grid = new W(this.ctx), this.ctx.coreUtils = new I(this.ctx), this.ctx.crosshairs = new q(this.ctx), this.ctx.events = new _(this.ctx), this.ctx.localization = new j(this.ctx), this.ctx.options = new A(), this.ctx.responsive = new Z(this.ctx), this.ctx.series = new F(this.ctx), this.ctx.theme = new $(this.ctx), this.ctx.formatters = new R(this.ctx), this.ctx.titleSubtitle = new J(this.ctx), this.ctx.legend = new rt(this.ctx), this.ctx.toolbar = new nt(this.ctx), this.ctx.dimensions = new it(this.ctx), this.ctx.updateHelpers = new Tt(this.ctx), this.ctx.zoomPanSelection = new ot(this.ctx), this.ctx.w.globals.tooltip = new ft(this.ctx); } }]), t; }()); const It = (function () { function t(i) { e(this, t), this.ctx = i, this.w = i.w; } return a(t, [{ key: 'clear', value() { this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements(); } }, { key: 'killSVG', value(t) { t.each((function (t, e) { this.removeClass('*'), this.off(), this.stop(); }), !0), t.ungroup(), t.clear(); } }, { key: 'clearDomElements', value() { const t = this; this.ctx.eventList.forEach(((e) => { document.removeEventListener(e, t.ctx.events.documentEvent); })); const e = this.w.globals.dom; if (this.ctx.el !== null) for (;this.ctx.el.firstChild;) this.ctx.el.removeChild(this.ctx.el.firstChild); this.killSVG(e.Paper), e.Paper.remove(), e.elWrap = null, e.elGraphical = null, e.elLegendWrap = null, e.baseEl = null, e.elGridRect = null, e.elGridRectMask = null, e.elGridRectMarkerMask = null, e.elDefs = null; } }]), t; }()); return (function () {
    function t(i, a) { e(this, t), this.opts = a, this.ctx = this, this.w = new z(a).init(), this.el = i, this.w.globals.cuid = g.randomId(), this.w.globals.chartID = this.w.config.chart.id ? this.w.config.chart.id : this.w.globals.cuid, new zt(this).initModules(), this.create = g.bind(this.create, this), this.windowResizeHandler = this._windowResize.bind(this); } return a(t, [{ key: 'render', value() { const t = this; return new Promise((((e, i) => { if (t.el !== null) { void 0 === Apex._chartInstances && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({ id: t.w.globals.chartID, group: t.w.config.chart.group, chart: t }), t.setLocale(t.w.config.chart.defaultLocale); const a = t.w.config.chart.events.beforeMount; typeof a === 'function' && a(t, t.w), t.events.fireEvent('beforeMount', [t, t.w]), window.addEventListener('resize', t.windowResizeHandler), window.addResizeListener(t.el.parentNode, t._parentResizeCallback.bind(t)); const s = t.create(t.w.config.series, {}); if (!s) return e(t); t.mount(s).then((() => { typeof t.w.config.chart.events.mounted === 'function' && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent('mounted', [t, t.w]), e(s); })).catch(((t) => { i(t); })); } else i(new Error('Element not found')); }))); } }, {
      key: 'create',
      value(t, e) {
        const i = this.w; new zt(this).initModules(); const a = this.w.globals; (a.noData = !1, a.animationEnded = !1, this.responsive.checkResponsiveConfig(e), i.config.xaxis.convertedCatToNumeric) && new L(i.config).convertCatToNumericXaxis(i.config, this.ctx); if (this.el === null) return a.animationEnded = !0, null; if (this.core.setupElements(), a.svgWidth === 0) return a.animationEnded = !0, null; const s = I.checkComboSeries(t); a.comboCharts = s.comboCharts, a.comboBarCount = s.comboBarCount, (t.length === 0 || t.length === 1 && t[0].data && t[0].data.length === 0) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new X(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a.noData && a.collapsedSeries.length !== a.series.length || this.legend.init(), this.series.hasAllSeriesEqualX(), a.axisCharts && (this.core.coreCalculations(), i.config.xaxis.type !== 'category' && this.formatters.setLabelFormatters()), this.formatters.heatmapLabelFormatters(), this.dimensions.plotCoords(); const r = this.core.xySettings(); this.grid.createGridMask(); const n = this.core.plotChartType(t, r); const o = new Y(this); o.bringForward(), i.config.dataLabels.background.enabled && o.dataLabelsBackground(), this.core.shiftGraphPosition(); const l = {
          plot: {
            left: i.globals.translateX, top: i.globals.translateY, width: i.globals.gridWidth, height: i.globals.gridHeight,
          },
        }; return {
          elGraph: n, xyRatios: r, elInner: i.globals.dom.elGraphical, dimensions: l,
        };
      },
    }, { key: 'mount', value() { const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; const i = this; const a = i.w; return new Promise((((s, r) => { if (i.el === null) return r(new Error('Not enough data to display or target element not found')); (e === null || a.globals.allSeriesCollapsed) && i.series.handleNoData(), i.axes.drawAxis(a.config.chart.type, e.xyRatios), i.grid = new W(i); let n = null; a.config.grid.position === 'back' && (n = i.grid.drawGrid()); const o = new O(t.ctx); const l = new G(t.ctx); if (n !== null && (o.xAxisLabelCorrections(n.xAxisTickWidth), l.setYAxisTextAlignments()), i.annotations = new S(i), a.config.annotations.position === 'back' && i.annotations.drawAnnotations(), e.elGraph instanceof Array) for (let h = 0; h < e.elGraph.length; h++)a.globals.dom.elGraphical.add(e.elGraph[h]); else a.globals.dom.elGraphical.add(e.elGraph); if (a.config.grid.position === 'front' && i.grid.drawGrid(), a.config.xaxis.crosshairs.position === 'front' && i.crosshairs.drawXCrosshairs(), a.config.yaxis[0].crosshairs.position === 'front' && i.crosshairs.drawYCrosshairs(), a.config.annotations.position === 'front' && i.annotations.drawAnnotations(), !a.globals.noData) { if (a.config.tooltip.enabled && !a.globals.noData && i.w.globals.tooltip.drawTooltip(e.xyRatios), a.globals.axisCharts && (a.globals.isXNumeric || a.config.xaxis.convertedCatToNumeric))(a.config.chart.zoom.enabled || a.config.chart.selection && a.config.chart.selection.enabled || a.config.chart.pan && a.config.chart.pan.enabled) && i.zoomPanSelection.init({ xyRatios: e.xyRatios }); else { const c = a.config.chart.toolbar.tools; ['zoom', 'zoomin', 'zoomout', 'selection', 'pan', 'reset'].forEach(((t) => { c[t] = !1; })); }a.config.chart.toolbar.show && !a.globals.allSeriesCollapsed && i.toolbar.createToolbar(); }a.globals.memory.methodsToExec.length > 0 && a.globals.memory.methodsToExec.forEach(((t) => { t.method(t.params, !1, t.context); })), a.globals.axisCharts || a.globals.noData || i.core.resizeNonAxisCharts(), s(i); }))); } }, { key: 'destroy', value() { window.removeEventListener('resize', this.windowResizeHandler), window.removeResizeListener(this.el.parentNode, this._parentResizeCallback.bind(this)); const t = this.w.config.chart.id; t && Apex._chartInstances.forEach(((e, i) => { e.id === t && Apex._chartInstances.splice(i, 1); })), new It(this.ctx).clear(); } }, { key: 'updateOptions', value(t) { const e = this; const i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; const r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]; const n = this.w; return t.series && (this.series.resetSeries(!1), t.series.length && t.series[0].data && (t.series = t.series.map(((t, i) => e.updateHelpers._extendSeries(t, i)))), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), n.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, i, a, s, r); } }, { key: 'updateSeries', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, e, i); } }, { key: 'appendSeries', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const a = this.w.config.series.slice(); return a.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a, e, i); } }, { key: 'appendData', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = this; i.w.globals.dataChanged = !0, i.series.getPreviousPaths(); for (var a = i.w.config.series.slice(), s = 0; s < a.length; s++) if (void 0 !== t[s]) for (let r = 0; r < t[s].data.length; r++)a[s].data.push(t[s].data[r]); return i.w.config.series = a, e && (i.w.globals.initialSeries = JSON.parse(JSON.stringify(i.w.config.series))), this.update(); } }, { key: 'update', value(t) { const e = this; return new Promise((((i, a) => { new It(e.ctx).clear(); const s = e.create(e.w.config.series, t); if (!s) return i(e); e.mount(s).then((() => { typeof e.w.config.chart.events.updated === 'function' && e.w.config.chart.events.updated(e, e.w), e.events.fireEvent('updated', [e, e.w]), e.w.globals.isDirty = !0, i(e); })).catch(((t) => { a(t); })); }))); } }, { key: 'getSyncedCharts', value() { const t = this.getGroupedCharts(); let e = [this]; return t.length && (e = [], t.forEach(((t) => { e.push(t); }))), e; } }, { key: 'getGroupedCharts', value() { const t = this; return Apex._chartInstances.filter(((t) => { if (t.group) return !0; })).map(((e) => (t.w.config.chart.group === e.group ? e.chart : t))); } }, { key: 'toggleSeries', value(t) { return this.series.toggleSeries(t); } }, { key: 'showSeries', value(t) { this.series.showSeries(t); } }, { key: 'hideSeries', value(t) { this.series.hideSeries(t); } }, { key: 'resetSeries', value() { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; this.series.resetSeries(t); } }, { key: 'addEventListener', value(t, e) { this.events.addEventListener(t, e); } }, { key: 'removeEventListener', value(t, e) { this.events.removeEventListener(t, e); } }, { key: 'addXaxisAnnotation', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; let a = this; i && (a = i), a.annotations.addXaxisAnnotationExternal(t, e, a); } }, { key: 'addYaxisAnnotation', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; let a = this; i && (a = i), a.annotations.addYaxisAnnotationExternal(t, e, a); } }, { key: 'addPointAnnotation', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; let a = this; i && (a = i), a.annotations.addPointAnnotationExternal(t, e, a); } }, { key: 'clearAnnotations', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0; let e = this; t && (e = t), e.annotations.clearAnnotations(e); } }, { key: 'removeAnnotation', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0; let i = this; e && (i = e), i.annotations.removeAnnotation(i, t); } }, { key: 'addText', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; let a = this; i && (a = i), a.annotations.addText(t, e, a); } }, { key: 'addImage', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; let a = this; i && (a = i), a.annotations.addImage(t, e, a); } }, { key: 'getChartArea', value() { return this.w.globals.dom.baseEl.querySelector('.apexcharts-inner'); } }, { key: 'getSeriesTotalXRange', value(t, e) { return this.coreUtils.getSeriesTotalsXRange(t, e); } }, { key: 'getHighestValueInSeries', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = new V(this.ctx); return e.getMinYMaxY(t).highestY; } }, { key: 'getLowestValueInSeries', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = new V(this.ctx); return e.getMinYMaxY(t).lowestY; } }, { key: 'getSeriesTotal', value() { return this.w.globals.seriesTotals; } }, { key: 'toggleDataPointSelection', value(t, e) { return this.updateHelpers.toggleDataPointSelection(t, e); } }, { key: 'setLocale', value(t) { this.localization.setCurrentLocaleValues(t); } }, { key: 'dataURI', value() { return new N(this.ctx).dataURI(); } }, { key: 'paper', value() { return this.w.globals.dom.Paper; } }, { key: '_parentResizeCallback', value() { this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize(); } }, { key: '_windowResize', value() { const t = this; clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout((() => { t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update(); }), 150); } }], [{ key: 'getChartByID', value(t) { const e = Apex._chartInstances.filter(((e) => e.id === t))[0]; return e && e.chart; } }, { key: 'initOnLoad', value() { for (let e = document.querySelectorAll('[data-apexcharts]'), i = 0; i < e.length; i++) { new t(e[i], JSON.parse(e[i].getAttribute('data-options'))).render(); } } }, { key: 'exec', value(t, e) { const i = this.getChartByID(t); if (i) { i.w.globals.isExecCalled = !0; let a = null; if (i.publicMethods.indexOf(e) !== -1) { for (var s = arguments.length, r = new Array(s > 2 ? s - 2 : 0), n = 2; n < s; n++)r[n - 2] = arguments[n]; a = i[e].apply(i, r); } return a; } } }, { key: 'merge', value(t, e) { return g.extend(t, e); } }]), t;
  }());
})));
